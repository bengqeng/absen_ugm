/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/user/app.js":
/*!**********************************!*\
  !*** ./resources/js/user/app.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bootstrap_bundle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bootstrap.bundle */ "./resources/js/user/bootstrap.bundle.js");
/* harmony import */ var _bootstrap_bundle__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_bootstrap_bundle__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./resources/js/user/bootstrap.bundle.js":
/*!***********************************************!*\
  !*** ./resources/js/user/bootstrap.bundle.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*!\r\n  * Bootstrap v5.2.3 (https://getbootstrap.com/)\r\n  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\r\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n  */\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function () {\n  'use strict';\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): util/index.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  var _KEY_TO_DIRECTION;\n  var MAX_UID = 1000000;\n  var MILLISECONDS_MULTIPLIER = 1000;\n  var TRANSITION_END = 'transitionend'; // Shout-out Angus Croll (https://goo.gl/pxwQGp)\n\n  var toType = function toType(object) {\n    if (object === null || object === undefined) {\n      return \"\".concat(object);\n    }\n    return Object.prototype.toString.call(object).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  };\n  /**\r\n   * Public Util API\r\n   */\n\n  var getUID = function getUID(prefix) {\n    do {\n      prefix += Math.floor(Math.random() * MAX_UID);\n    } while (document.getElementById(prefix));\n    return prefix;\n  };\n  var getSelector = function getSelector(element) {\n    var selector = element.getAttribute('data-bs-target');\n    if (!selector || selector === '#') {\n      var hrefAttribute = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,\n      // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n      // `document.querySelector` will rightfully complain it is invalid.\n      // See https://github.com/twbs/bootstrap/issues/32273\n\n      if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {\n        return null;\n      } // Just in case some CMS puts out a full URL with the anchor appended\n\n      if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {\n        hrefAttribute = \"#\".concat(hrefAttribute.split('#')[1]);\n      }\n      selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;\n    }\n    return selector;\n  };\n  var getSelectorFromElement = function getSelectorFromElement(element) {\n    var selector = getSelector(element);\n    if (selector) {\n      return document.querySelector(selector) ? selector : null;\n    }\n    return null;\n  };\n  var getElementFromSelector = function getElementFromSelector(element) {\n    var selector = getSelector(element);\n    return selector ? document.querySelector(selector) : null;\n  };\n  var getTransitionDurationFromElement = function getTransitionDurationFromElement(element) {\n    if (!element) {\n      return 0;\n    } // Get transition-duration of the element\n\n    var _window$getComputedSt = window.getComputedStyle(element),\n      transitionDuration = _window$getComputedSt.transitionDuration,\n      transitionDelay = _window$getComputedSt.transitionDelay;\n    var floatTransitionDuration = Number.parseFloat(transitionDuration);\n    var floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found\n\n    if (!floatTransitionDuration && !floatTransitionDelay) {\n      return 0;\n    } // If multiple durations are defined, take the first\n\n    transitionDuration = transitionDuration.split(',')[0];\n    transitionDelay = transitionDelay.split(',')[0];\n    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n  };\n  var triggerTransitionEnd = function triggerTransitionEnd(element) {\n    element.dispatchEvent(new Event(TRANSITION_END));\n  };\n  var isElement$1 = function isElement$1(object) {\n    if (!object || _typeof(object) !== 'object') {\n      return false;\n    }\n    if (typeof object.jquery !== 'undefined') {\n      object = object[0];\n    }\n    return typeof object.nodeType !== 'undefined';\n  };\n  var getElement = function getElement(object) {\n    // it's a jQuery object or a node element\n    if (isElement$1(object)) {\n      return object.jquery ? object[0] : object;\n    }\n    if (typeof object === 'string' && object.length > 0) {\n      return document.querySelector(object);\n    }\n    return null;\n  };\n  var isVisible = function isVisible(element) {\n    if (!isElement$1(element) || element.getClientRects().length === 0) {\n      return false;\n    }\n    var elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible'; // Handle `details` element as its content may falsie appear visible when it is closed\n\n    var closedDetails = element.closest('details:not([open])');\n    if (!closedDetails) {\n      return elementIsVisible;\n    }\n    if (closedDetails !== element) {\n      var summary = element.closest('summary');\n      if (summary && summary.parentNode !== closedDetails) {\n        return false;\n      }\n      if (summary === null) {\n        return false;\n      }\n    }\n    return elementIsVisible;\n  };\n  var isDisabled = function isDisabled(element) {\n    if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n      return true;\n    }\n    if (element.classList.contains('disabled')) {\n      return true;\n    }\n    if (typeof element.disabled !== 'undefined') {\n      return element.disabled;\n    }\n    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';\n  };\n  var findShadowRoot = function findShadowRoot(element) {\n    if (!document.documentElement.attachShadow) {\n      return null;\n    } // Can find the shadow root otherwise it'll return the document\n\n    if (typeof element.getRootNode === 'function') {\n      var root = element.getRootNode();\n      return root instanceof ShadowRoot ? root : null;\n    }\n    if (element instanceof ShadowRoot) {\n      return element;\n    } // when we don't find a shadow root\n\n    if (!element.parentNode) {\n      return null;\n    }\n    return findShadowRoot(element.parentNode);\n  };\n  var noop = function noop() {};\n  /**\r\n   * Trick to restart an element's animation\r\n   *\r\n   * @param {HTMLElement} element\r\n   * @return void\r\n   *\r\n   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation\r\n   */\n\n  var reflow = function reflow(element) {\n    element.offsetHeight; // eslint-disable-line no-unused-expressions\n  };\n\n  var getjQuery = function getjQuery() {\n    if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {\n      return window.jQuery;\n    }\n    return null;\n  };\n  var DOMContentLoadedCallbacks = [];\n  var onDOMContentLoaded = function onDOMContentLoaded(callback) {\n    if (document.readyState === 'loading') {\n      // add listener on the first call when the document is in loading state\n      if (!DOMContentLoadedCallbacks.length) {\n        document.addEventListener('DOMContentLoaded', function () {\n          var _iterator = _createForOfIteratorHelper(DOMContentLoadedCallbacks),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _callback = _step.value;\n              _callback();\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        });\n      }\n      DOMContentLoadedCallbacks.push(callback);\n    } else {\n      callback();\n    }\n  };\n  var isRTL = function isRTL() {\n    return document.documentElement.dir === 'rtl';\n  };\n  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {\n    onDOMContentLoaded(function () {\n      var $ = getjQuery();\n      /* istanbul ignore if */\n\n      if ($) {\n        var name = plugin.NAME;\n        var JQUERY_NO_CONFLICT = $.fn[name];\n        $.fn[name] = plugin.jQueryInterface;\n        $.fn[name].Constructor = plugin;\n        $.fn[name].noConflict = function () {\n          $.fn[name] = JQUERY_NO_CONFLICT;\n          return plugin.jQueryInterface;\n        };\n      }\n    });\n  };\n  var execute = function execute(callback) {\n    if (typeof callback === 'function') {\n      callback();\n    }\n  };\n  var executeAfterTransition = function executeAfterTransition(callback, transitionElement) {\n    var waitForTransition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (!waitForTransition) {\n      execute(callback);\n      return;\n    }\n    var durationPadding = 5;\n    var emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;\n    var called = false;\n    var handler = function handler(_ref6) {\n      var target = _ref6.target;\n      if (target !== transitionElement) {\n        return;\n      }\n      called = true;\n      transitionElement.removeEventListener(TRANSITION_END, handler);\n      execute(callback);\n    };\n    transitionElement.addEventListener(TRANSITION_END, handler);\n    setTimeout(function () {\n      if (!called) {\n        triggerTransitionEnd(transitionElement);\n      }\n    }, emulatedDuration);\n  };\n  /**\r\n   * Return the previous/next element of a list.\r\n   *\r\n   * @param {array} list    The list of elements\r\n   * @param activeElement   The active element\r\n   * @param shouldGetNext   Choose to get next or previous element\r\n   * @param isCycleAllowed\r\n   * @return {Element|elem} The proper element\r\n   */\n\n  var getNextActiveElement = function getNextActiveElement(list, activeElement, shouldGetNext, isCycleAllowed) {\n    var listLength = list.length;\n    var index = list.indexOf(activeElement); // if the element does not exist in the list return an element\n    // depending on the direction and if cycle is allowed\n\n    if (index === -1) {\n      return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];\n    }\n    index += shouldGetNext ? 1 : -1;\n    if (isCycleAllowed) {\n      index = (index + listLength) % listLength;\n    }\n    return list[Math.max(0, Math.min(index, listLength - 1))];\n  };\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): dom/event-handler.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n\n  var namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\n  var stripNameRegex = /\\..*/;\n  var stripUidRegex = /::\\d+$/;\n  var eventRegistry = {}; // Events storage\n\n  var uidEvent = 1;\n  var customEvents = {\n    mouseenter: 'mouseover',\n    mouseleave: 'mouseout'\n  };\n  var nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);\n  /**\r\n   * Private methods\r\n   */\n\n  function makeEventUid(element, uid) {\n    return uid && \"\".concat(uid, \"::\").concat(uidEvent++) || element.uidEvent || uidEvent++;\n  }\n  function getElementEvents(element) {\n    var uid = makeEventUid(element);\n    element.uidEvent = uid;\n    eventRegistry[uid] = eventRegistry[uid] || {};\n    return eventRegistry[uid];\n  }\n  function bootstrapHandler(element, fn) {\n    return function handler(event) {\n      hydrateObj(event, {\n        delegateTarget: element\n      });\n      if (handler.oneOff) {\n        EventHandler.off(element, event.type, fn);\n      }\n      return fn.apply(element, [event]);\n    };\n  }\n  function bootstrapDelegationHandler(element, selector, fn) {\n    return function handler(event) {\n      var domElements = element.querySelectorAll(selector);\n      for (var target = event.target; target && target !== this; target = target.parentNode) {\n        var _iterator2 = _createForOfIteratorHelper(domElements),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var domElement = _step2.value;\n            if (domElement !== target) {\n              continue;\n            }\n            hydrateObj(event, {\n              delegateTarget: target\n            });\n            if (handler.oneOff) {\n              EventHandler.off(element, event.type, selector, fn);\n            }\n            return fn.apply(target, [event]);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    };\n  }\n  function findHandler(events, callable) {\n    var delegationSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return Object.values(events).find(function (event) {\n      return event.callable === callable && event.delegationSelector === delegationSelector;\n    });\n  }\n  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {\n    var isDelegated = typeof handler === 'string'; // todo: tooltip passes `false` instead of selector, so we need to check\n\n    var callable = isDelegated ? delegationFunction : handler || delegationFunction;\n    var typeEvent = getTypeEvent(originalTypeEvent);\n    if (!nativeEvents.has(typeEvent)) {\n      typeEvent = originalTypeEvent;\n    }\n    return [isDelegated, callable, typeEvent];\n  }\n  function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {\n    if (typeof originalTypeEvent !== 'string' || !element) {\n      return;\n    }\n    var _normalizeParameters = normalizeParameters(originalTypeEvent, handler, delegationFunction),\n      _normalizeParameters2 = _slicedToArray(_normalizeParameters, 3),\n      isDelegated = _normalizeParameters2[0],\n      callable = _normalizeParameters2[1],\n      typeEvent = _normalizeParameters2[2]; // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\n    // this prevents the handler from being dispatched the same way as mouseover or mouseout does\n\n    if (originalTypeEvent in customEvents) {\n      var wrapFunction = function wrapFunction(fn) {\n        return function (event) {\n          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\n            return fn.call(this, event);\n          }\n        };\n      };\n      callable = wrapFunction(callable);\n    }\n    var events = getElementEvents(element);\n    var handlers = events[typeEvent] || (events[typeEvent] = {});\n    var previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);\n    if (previousFunction) {\n      previousFunction.oneOff = previousFunction.oneOff && oneOff;\n      return;\n    }\n    var uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));\n    var fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);\n    fn.delegationSelector = isDelegated ? handler : null;\n    fn.callable = callable;\n    fn.oneOff = oneOff;\n    fn.uidEvent = uid;\n    handlers[uid] = fn;\n    element.addEventListener(typeEvent, fn, isDelegated);\n  }\n  function removeHandler(element, events, typeEvent, handler, delegationSelector) {\n    var fn = findHandler(events[typeEvent], handler, delegationSelector);\n    if (!fn) {\n      return;\n    }\n    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\n    delete events[typeEvent][fn.uidEvent];\n  }\n  function removeNamespacedHandlers(element, events, typeEvent, namespace) {\n    var storeElementEvent = events[typeEvent] || {};\n    for (var _i2 = 0, _Object$keys = Object.keys(storeElementEvent); _i2 < _Object$keys.length; _i2++) {\n      var handlerKey = _Object$keys[_i2];\n      if (handlerKey.includes(namespace)) {\n        var event = storeElementEvent[handlerKey];\n        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n      }\n    }\n  }\n  function getTypeEvent(event) {\n    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')\n    event = event.replace(stripNameRegex, '');\n    return customEvents[event] || event;\n  }\n  var EventHandler = {\n    on: function on(element, event, handler, delegationFunction) {\n      addHandler(element, event, handler, delegationFunction, false);\n    },\n    one: function one(element, event, handler, delegationFunction) {\n      addHandler(element, event, handler, delegationFunction, true);\n    },\n    off: function off(element, originalTypeEvent, handler, delegationFunction) {\n      if (typeof originalTypeEvent !== 'string' || !element) {\n        return;\n      }\n      var _normalizeParameters3 = normalizeParameters(originalTypeEvent, handler, delegationFunction),\n        _normalizeParameters4 = _slicedToArray(_normalizeParameters3, 3),\n        isDelegated = _normalizeParameters4[0],\n        callable = _normalizeParameters4[1],\n        typeEvent = _normalizeParameters4[2];\n      var inNamespace = typeEvent !== originalTypeEvent;\n      var events = getElementEvents(element);\n      var storeElementEvent = events[typeEvent] || {};\n      var isNamespace = originalTypeEvent.startsWith('.');\n      if (typeof callable !== 'undefined') {\n        // Simplest case: handler is passed, remove that listener ONLY.\n        if (!Object.keys(storeElementEvent).length) {\n          return;\n        }\n        removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);\n        return;\n      }\n      if (isNamespace) {\n        for (var _i3 = 0, _Object$keys2 = Object.keys(events); _i3 < _Object$keys2.length; _i3++) {\n          var elementEvent = _Object$keys2[_i3];\n          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\n        }\n      }\n      for (var _i4 = 0, _Object$keys3 = Object.keys(storeElementEvent); _i4 < _Object$keys3.length; _i4++) {\n        var keyHandlers = _Object$keys3[_i4];\n        var handlerKey = keyHandlers.replace(stripUidRegex, '');\n        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\n          var event = storeElementEvent[keyHandlers];\n          removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n        }\n      }\n    },\n    trigger: function trigger(element, event, args) {\n      if (typeof event !== 'string' || !element) {\n        return null;\n      }\n      var $ = getjQuery();\n      var typeEvent = getTypeEvent(event);\n      var inNamespace = event !== typeEvent;\n      var jQueryEvent = null;\n      var bubbles = true;\n      var nativeDispatch = true;\n      var defaultPrevented = false;\n      if (inNamespace && $) {\n        jQueryEvent = $.Event(event, args);\n        $(element).trigger(jQueryEvent);\n        bubbles = !jQueryEvent.isPropagationStopped();\n        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\n        defaultPrevented = jQueryEvent.isDefaultPrevented();\n      }\n      var evt = new Event(event, {\n        bubbles: bubbles,\n        cancelable: true\n      });\n      evt = hydrateObj(evt, args);\n      if (defaultPrevented) {\n        evt.preventDefault();\n      }\n      if (nativeDispatch) {\n        element.dispatchEvent(evt);\n      }\n      if (evt.defaultPrevented && jQueryEvent) {\n        jQueryEvent.preventDefault();\n      }\n      return evt;\n    }\n  };\n  function hydrateObj(obj, meta) {\n    var _loop2 = function _loop2() {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i5], 2),\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n      try {\n        obj[key] = value;\n      } catch (_unused) {\n        Object.defineProperty(obj, key, {\n          configurable: true,\n          get: function get() {\n            return value;\n          }\n        });\n      }\n    };\n    for (var _i5 = 0, _Object$entries = Object.entries(meta || {}); _i5 < _Object$entries.length; _i5++) {\n      _loop2();\n    }\n    return obj;\n  }\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): dom/data.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n\n  /**\r\n   * Constants\r\n   */\n  var elementMap = new Map();\n  var Data = {\n    set: function set(element, key, instance) {\n      if (!elementMap.has(element)) {\n        elementMap.set(element, new Map());\n      }\n      var instanceMap = elementMap.get(element); // make it clear we only want one instance per element\n      // can be removed later when multiple key/instances are fine to be used\n\n      if (!instanceMap.has(key) && instanceMap.size !== 0) {\n        // eslint-disable-next-line no-console\n        console.error(\"Bootstrap doesn't allow more than one instance per element. Bound instance: \".concat(Array.from(instanceMap.keys())[0], \".\"));\n        return;\n      }\n      instanceMap.set(key, instance);\n    },\n    get: function get(element, key) {\n      if (elementMap.has(element)) {\n        return elementMap.get(element).get(key) || null;\n      }\n      return null;\n    },\n    remove: function remove(element, key) {\n      if (!elementMap.has(element)) {\n        return;\n      }\n      var instanceMap = elementMap.get(element);\n      instanceMap[\"delete\"](key); // free up element references if there are no instances left for an element\n\n      if (instanceMap.size === 0) {\n        elementMap[\"delete\"](element);\n      }\n    }\n  };\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): dom/manipulator.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  function normalizeData(value) {\n    if (value === 'true') {\n      return true;\n    }\n    if (value === 'false') {\n      return false;\n    }\n    if (value === Number(value).toString()) {\n      return Number(value);\n    }\n    if (value === '' || value === 'null') {\n      return null;\n    }\n    if (typeof value !== 'string') {\n      return value;\n    }\n    try {\n      return JSON.parse(decodeURIComponent(value));\n    } catch (_unused) {\n      return value;\n    }\n  }\n  function normalizeDataKey(key) {\n    return key.replace(/[A-Z]/g, function (chr) {\n      return \"-\".concat(chr.toLowerCase());\n    });\n  }\n  var Manipulator = {\n    setDataAttribute: function setDataAttribute(element, key, value) {\n      element.setAttribute(\"data-bs-\".concat(normalizeDataKey(key)), value);\n    },\n    removeDataAttribute: function removeDataAttribute(element, key) {\n      element.removeAttribute(\"data-bs-\".concat(normalizeDataKey(key)));\n    },\n    getDataAttributes: function getDataAttributes(element) {\n      if (!element) {\n        return {};\n      }\n      var attributes = {};\n      var bsKeys = Object.keys(element.dataset).filter(function (key) {\n        return key.startsWith('bs') && !key.startsWith('bsConfig');\n      });\n      var _iterator3 = _createForOfIteratorHelper(bsKeys),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var key = _step3.value;\n          var pureKey = key.replace(/^bs/, '');\n          pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\n          attributes[pureKey] = normalizeData(element.dataset[key]);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return attributes;\n    },\n    getDataAttribute: function getDataAttribute(element, key) {\n      return normalizeData(element.getAttribute(\"data-bs-\".concat(normalizeDataKey(key))));\n    }\n  };\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): util/config.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Class definition\r\n   */\n  var Config = /*#__PURE__*/function () {\n    function Config() {\n      _classCallCheck(this, Config);\n    }\n    _createClass(Config, [{\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        config = this._mergeConfigObj(config);\n        config = this._configAfterMerge(config);\n        this._typeCheckConfig(config);\n        return config;\n      }\n    }, {\n      key: \"_configAfterMerge\",\n      value: function _configAfterMerge(config) {\n        return config;\n      }\n    }, {\n      key: \"_mergeConfigObj\",\n      value: function _mergeConfigObj(config, element) {\n        var jsonConfig = isElement$1(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse\n\n        return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, this.constructor.Default), _typeof(jsonConfig) === 'object' ? jsonConfig : {}), isElement$1(element) ? Manipulator.getDataAttributes(element) : {}), _typeof(config) === 'object' ? config : {});\n      }\n    }, {\n      key: \"_typeCheckConfig\",\n      value: function _typeCheckConfig(config) {\n        var configTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.constructor.DefaultType;\n        for (var _i6 = 0, _Object$keys4 = Object.keys(configTypes); _i6 < _Object$keys4.length; _i6++) {\n          var property = _Object$keys4[_i6];\n          var expectedTypes = configTypes[property];\n          var value = config[property];\n          var valueType = isElement$1(value) ? 'element' : toType(value);\n          if (!new RegExp(expectedTypes).test(valueType)) {\n            throw new TypeError(\"\".concat(this.constructor.NAME.toUpperCase(), \": Option \\\"\").concat(property, \"\\\" provided type \\\"\").concat(valueType, \"\\\" but expected type \\\"\").concat(expectedTypes, \"\\\".\"));\n          }\n        }\n      }\n    }], [{\n      key: \"Default\",\n      get:\n      // Getters\n      function get() {\n        return {};\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return {};\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        throw new Error('You have to implement the static method \"NAME\", for each component!');\n      }\n    }]);\n    return Config;\n  }();\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): base-component.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n  var VERSION = '5.2.3';\n  /**\r\n   * Class definition\r\n   */\n  var BaseComponent = /*#__PURE__*/function (_Config) {\n    _inherits(BaseComponent, _Config);\n    var _super = _createSuper(BaseComponent);\n    function BaseComponent(element, config) {\n      var _this;\n      _classCallCheck(this, BaseComponent);\n      _this = _super.call(this);\n      element = getElement(element);\n      if (!element) {\n        return _possibleConstructorReturn(_this);\n      }\n      _this._element = element;\n      _this._config = _this._getConfig(config);\n      Data.set(_this._element, _this.constructor.DATA_KEY, _assertThisInitialized(_this));\n      return _this;\n    } // Public\n    _createClass(BaseComponent, [{\n      key: \"dispose\",\n      value: function dispose() {\n        Data.remove(this._element, this.constructor.DATA_KEY);\n        EventHandler.off(this._element, this.constructor.EVENT_KEY);\n        var _iterator4 = _createForOfIteratorHelper(Object.getOwnPropertyNames(this)),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var propertyName = _step4.value;\n            this[propertyName] = null;\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    }, {\n      key: \"_queueCallback\",\n      value: function _queueCallback(callback, element) {\n        var isAnimated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        executeAfterTransition(callback, element, isAnimated);\n      }\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        config = this._mergeConfigObj(config, this._element);\n        config = this._configAfterMerge(config);\n        this._typeCheckConfig(config);\n        return config;\n      } // Static\n    }], [{\n      key: \"getInstance\",\n      value: function getInstance(element) {\n        return Data.get(getElement(element), this.DATA_KEY);\n      }\n    }, {\n      key: \"getOrCreateInstance\",\n      value: function getOrCreateInstance(element) {\n        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return this.getInstance(element) || new this(element, _typeof(config) === 'object' ? config : null);\n      }\n    }, {\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return \"bs.\".concat(this.NAME);\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return \".\".concat(this.DATA_KEY);\n      }\n    }, {\n      key: \"eventName\",\n      value: function eventName(name) {\n        return \"\".concat(name).concat(this.EVENT_KEY);\n      }\n    }]);\n    return BaseComponent;\n  }(Config);\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): util/component-functions.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  var enableDismissTrigger = function enableDismissTrigger(component) {\n    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hide';\n    var clickEvent = \"click.dismiss\".concat(component.EVENT_KEY);\n    var name = component.NAME;\n    EventHandler.on(document, clickEvent, \"[data-bs-dismiss=\\\"\".concat(name, \"\\\"]\"), function (event) {\n      if (['A', 'AREA'].includes(this.tagName)) {\n        event.preventDefault();\n      }\n      if (isDisabled(this)) {\n        return;\n      }\n      var target = getElementFromSelector(this) || this.closest(\".\".concat(name));\n      var instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method\n\n      instance[method]();\n    });\n  };\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): alert.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n\n  var NAME$f = 'alert';\n  var DATA_KEY$a = 'bs.alert';\n  var EVENT_KEY$b = \".\".concat(DATA_KEY$a);\n  var EVENT_CLOSE = \"close\".concat(EVENT_KEY$b);\n  var EVENT_CLOSED = \"closed\".concat(EVENT_KEY$b);\n  var CLASS_NAME_FADE$5 = 'fade';\n  var CLASS_NAME_SHOW$8 = 'show';\n  /**\r\n   * Class definition\r\n   */\n  var Alert = /*#__PURE__*/function (_BaseComponent) {\n    _inherits(Alert, _BaseComponent);\n    var _super2 = _createSuper(Alert);\n    function Alert() {\n      _classCallCheck(this, Alert);\n      return _super2.apply(this, arguments);\n    }\n    _createClass(Alert, [{\n      key: \"close\",\n      value:\n      // Public\n\n      function close() {\n        var _this2 = this;\n        var closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\n        if (closeEvent.defaultPrevented) {\n          return;\n        }\n        this._element.classList.remove(CLASS_NAME_SHOW$8);\n        var isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);\n        this._queueCallback(function () {\n          return _this2._destroyElement();\n        }, this._element, isAnimated);\n      } // Private\n    }, {\n      key: \"_destroyElement\",\n      value: function _destroyElement() {\n        this._element.remove();\n        EventHandler.trigger(this._element, EVENT_CLOSED);\n        this.dispose();\n      } // Static\n    }], [{\n      key: \"NAME\",\n      get:\n      // Getters\n      function get() {\n        return NAME$f;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Alert.getOrCreateInstance(this);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config](this);\n        });\n      }\n    }]);\n    return Alert;\n  }(BaseComponent);\n  /**\r\n   * Data API implementation\r\n   */\n  enableDismissTrigger(Alert, 'close');\n  /**\r\n   * jQuery\r\n   */\n\n  defineJQueryPlugin(Alert);\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): button.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n\n  var NAME$e = 'button';\n  var DATA_KEY$9 = 'bs.button';\n  var EVENT_KEY$a = \".\".concat(DATA_KEY$9);\n  var DATA_API_KEY$6 = '.data-api';\n  var CLASS_NAME_ACTIVE$3 = 'active';\n  var SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\"button\"]';\n  var EVENT_CLICK_DATA_API$6 = \"click\".concat(EVENT_KEY$a).concat(DATA_API_KEY$6);\n  /**\r\n   * Class definition\r\n   */\n  var Button = /*#__PURE__*/function (_BaseComponent2) {\n    _inherits(Button, _BaseComponent2);\n    var _super3 = _createSuper(Button);\n    function Button() {\n      _classCallCheck(this, Button);\n      return _super3.apply(this, arguments);\n    }\n    _createClass(Button, [{\n      key: \"toggle\",\n      value:\n      // Public\n\n      function toggle() {\n        // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\n        this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\n      } // Static\n    }], [{\n      key: \"NAME\",\n      get:\n      // Getters\n      function get() {\n        return NAME$e;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Button.getOrCreateInstance(this);\n          if (config === 'toggle') {\n            data[config]();\n          }\n        });\n      }\n    }]);\n    return Button;\n  }(BaseComponent);\n  /**\r\n   * Data API implementation\r\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, function (event) {\n    event.preventDefault();\n    var button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\n    var data = Button.getOrCreateInstance(button);\n    data.toggle();\n  });\n  /**\r\n   * jQuery\r\n   */\n\n  defineJQueryPlugin(Button);\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): dom/selector-engine.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n\n  var SelectorEngine = {\n    find: function find(selector) {\n      var _ref7;\n      var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;\n      return (_ref7 = []).concat.apply(_ref7, _toConsumableArray(Element.prototype.querySelectorAll.call(element, selector)));\n    },\n    findOne: function findOne(selector) {\n      var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;\n      return Element.prototype.querySelector.call(element, selector);\n    },\n    children: function children(element, selector) {\n      var _ref8;\n      return (_ref8 = []).concat.apply(_ref8, _toConsumableArray(element.children)).filter(function (child) {\n        return child.matches(selector);\n      });\n    },\n    parents: function parents(element, selector) {\n      var parents = [];\n      var ancestor = element.parentNode.closest(selector);\n      while (ancestor) {\n        parents.push(ancestor);\n        ancestor = ancestor.parentNode.closest(selector);\n      }\n      return parents;\n    },\n    prev: function prev(element, selector) {\n      var previous = element.previousElementSibling;\n      while (previous) {\n        if (previous.matches(selector)) {\n          return [previous];\n        }\n        previous = previous.previousElementSibling;\n      }\n      return [];\n    },\n    // TODO: this is now unused; remove later along with prev()\n    next: function next(element, selector) {\n      var next = element.nextElementSibling;\n      while (next) {\n        if (next.matches(selector)) {\n          return [next];\n        }\n        next = next.nextElementSibling;\n      }\n      return [];\n    },\n    focusableChildren: function focusableChildren(element) {\n      var focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable=\"true\"]'].map(function (selector) {\n        return \"\".concat(selector, \":not([tabindex^=\\\"-\\\"])\");\n      }).join(',');\n      return this.find(focusables, element).filter(function (el) {\n        return !isDisabled(el) && isVisible(el);\n      });\n    }\n  };\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): util/swipe.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n\n  var NAME$d = 'swipe';\n  var EVENT_KEY$9 = '.bs.swipe';\n  var EVENT_TOUCHSTART = \"touchstart\".concat(EVENT_KEY$9);\n  var EVENT_TOUCHMOVE = \"touchmove\".concat(EVENT_KEY$9);\n  var EVENT_TOUCHEND = \"touchend\".concat(EVENT_KEY$9);\n  var EVENT_POINTERDOWN = \"pointerdown\".concat(EVENT_KEY$9);\n  var EVENT_POINTERUP = \"pointerup\".concat(EVENT_KEY$9);\n  var POINTER_TYPE_TOUCH = 'touch';\n  var POINTER_TYPE_PEN = 'pen';\n  var CLASS_NAME_POINTER_EVENT = 'pointer-event';\n  var SWIPE_THRESHOLD = 40;\n  var Default$c = {\n    endCallback: null,\n    leftCallback: null,\n    rightCallback: null\n  };\n  var DefaultType$c = {\n    endCallback: '(function|null)',\n    leftCallback: '(function|null)',\n    rightCallback: '(function|null)'\n  };\n  /**\r\n   * Class definition\r\n   */\n  var Swipe = /*#__PURE__*/function (_Config2) {\n    _inherits(Swipe, _Config2);\n    var _super4 = _createSuper(Swipe);\n    function Swipe(element, config) {\n      var _this3;\n      _classCallCheck(this, Swipe);\n      _this3 = _super4.call(this);\n      _this3._element = element;\n      if (!element || !Swipe.isSupported()) {\n        return _possibleConstructorReturn(_this3);\n      }\n      _this3._config = _this3._getConfig(config);\n      _this3._deltaX = 0;\n      _this3._supportPointerEvents = Boolean(window.PointerEvent);\n      _this3._initEvents();\n      return _this3;\n    } // Getters\n    _createClass(Swipe, [{\n      key: \"dispose\",\n      value:\n      // Public\n\n      function dispose() {\n        EventHandler.off(this._element, EVENT_KEY$9);\n      } // Private\n    }, {\n      key: \"_start\",\n      value: function _start(event) {\n        if (!this._supportPointerEvents) {\n          this._deltaX = event.touches[0].clientX;\n          return;\n        }\n        if (this._eventIsPointerPenTouch(event)) {\n          this._deltaX = event.clientX;\n        }\n      }\n    }, {\n      key: \"_end\",\n      value: function _end(event) {\n        if (this._eventIsPointerPenTouch(event)) {\n          this._deltaX = event.clientX - this._deltaX;\n        }\n        this._handleSwipe();\n        execute(this._config.endCallback);\n      }\n    }, {\n      key: \"_move\",\n      value: function _move(event) {\n        this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;\n      }\n    }, {\n      key: \"_handleSwipe\",\n      value: function _handleSwipe() {\n        var absDeltaX = Math.abs(this._deltaX);\n        if (absDeltaX <= SWIPE_THRESHOLD) {\n          return;\n        }\n        var direction = absDeltaX / this._deltaX;\n        this._deltaX = 0;\n        if (!direction) {\n          return;\n        }\n        execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);\n      }\n    }, {\n      key: \"_initEvents\",\n      value: function _initEvents() {\n        var _this4 = this;\n        if (this._supportPointerEvents) {\n          EventHandler.on(this._element, EVENT_POINTERDOWN, function (event) {\n            return _this4._start(event);\n          });\n          EventHandler.on(this._element, EVENT_POINTERUP, function (event) {\n            return _this4._end(event);\n          });\n          this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n        } else {\n          EventHandler.on(this._element, EVENT_TOUCHSTART, function (event) {\n            return _this4._start(event);\n          });\n          EventHandler.on(this._element, EVENT_TOUCHMOVE, function (event) {\n            return _this4._move(event);\n          });\n          EventHandler.on(this._element, EVENT_TOUCHEND, function (event) {\n            return _this4._end(event);\n          });\n        }\n      }\n    }, {\n      key: \"_eventIsPointerPenTouch\",\n      value: function _eventIsPointerPenTouch(event) {\n        return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$c;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$c;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$d;\n      }\n    }, {\n      key: \"isSupported\",\n      value: function isSupported() {\n        return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\n      }\n    }]);\n    return Swipe;\n  }(Config);\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): carousel.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n  var NAME$c = 'carousel';\n  var DATA_KEY$8 = 'bs.carousel';\n  var EVENT_KEY$8 = \".\".concat(DATA_KEY$8);\n  var DATA_API_KEY$5 = '.data-api';\n  var ARROW_LEFT_KEY$1 = 'ArrowLeft';\n  var ARROW_RIGHT_KEY$1 = 'ArrowRight';\n  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\n  var ORDER_NEXT = 'next';\n  var ORDER_PREV = 'prev';\n  var DIRECTION_LEFT = 'left';\n  var DIRECTION_RIGHT = 'right';\n  var EVENT_SLIDE = \"slide\".concat(EVENT_KEY$8);\n  var EVENT_SLID = \"slid\".concat(EVENT_KEY$8);\n  var EVENT_KEYDOWN$1 = \"keydown\".concat(EVENT_KEY$8);\n  var EVENT_MOUSEENTER$1 = \"mouseenter\".concat(EVENT_KEY$8);\n  var EVENT_MOUSELEAVE$1 = \"mouseleave\".concat(EVENT_KEY$8);\n  var EVENT_DRAG_START = \"dragstart\".concat(EVENT_KEY$8);\n  var EVENT_LOAD_DATA_API$3 = \"load\".concat(EVENT_KEY$8).concat(DATA_API_KEY$5);\n  var EVENT_CLICK_DATA_API$5 = \"click\".concat(EVENT_KEY$8).concat(DATA_API_KEY$5);\n  var CLASS_NAME_CAROUSEL = 'carousel';\n  var CLASS_NAME_ACTIVE$2 = 'active';\n  var CLASS_NAME_SLIDE = 'slide';\n  var CLASS_NAME_END = 'carousel-item-end';\n  var CLASS_NAME_START = 'carousel-item-start';\n  var CLASS_NAME_NEXT = 'carousel-item-next';\n  var CLASS_NAME_PREV = 'carousel-item-prev';\n  var SELECTOR_ACTIVE = '.active';\n  var SELECTOR_ITEM = '.carousel-item';\n  var SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;\n  var SELECTOR_ITEM_IMG = '.carousel-item img';\n  var SELECTOR_INDICATORS = '.carousel-indicators';\n  var SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';\n  var SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\n  var KEY_TO_DIRECTION = (_KEY_TO_DIRECTION = {}, _defineProperty(_KEY_TO_DIRECTION, ARROW_LEFT_KEY$1, DIRECTION_RIGHT), _defineProperty(_KEY_TO_DIRECTION, ARROW_RIGHT_KEY$1, DIRECTION_LEFT), _KEY_TO_DIRECTION);\n  var Default$b = {\n    interval: 5000,\n    keyboard: true,\n    pause: 'hover',\n    ride: false,\n    touch: true,\n    wrap: true\n  };\n  var DefaultType$b = {\n    interval: '(number|boolean)',\n    // TODO:v6 remove boolean support\n    keyboard: 'boolean',\n    pause: '(string|boolean)',\n    ride: '(boolean|string)',\n    touch: 'boolean',\n    wrap: 'boolean'\n  };\n  /**\r\n   * Class definition\r\n   */\n  var Carousel = /*#__PURE__*/function (_BaseComponent3) {\n    _inherits(Carousel, _BaseComponent3);\n    var _super5 = _createSuper(Carousel);\n    function Carousel(element, config) {\n      var _this5;\n      _classCallCheck(this, Carousel);\n      _this5 = _super5.call(this, element, config);\n      _this5._interval = null;\n      _this5._activeElement = null;\n      _this5._isSliding = false;\n      _this5.touchTimeout = null;\n      _this5._swipeHelper = null;\n      _this5._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, _this5._element);\n      _this5._addEventListeners();\n      if (_this5._config.ride === CLASS_NAME_CAROUSEL) {\n        _this5.cycle();\n      }\n      return _this5;\n    } // Getters\n    _createClass(Carousel, [{\n      key: \"next\",\n      value:\n      // Public\n\n      function next() {\n        this._slide(ORDER_NEXT);\n      }\n    }, {\n      key: \"nextWhenVisible\",\n      value: function nextWhenVisible() {\n        // FIXME TODO use `document.visibilityState`\n        // Don't call next when the page isn't visible\n        // or the carousel or its parent isn't visible\n        if (!document.hidden && isVisible(this._element)) {\n          this.next();\n        }\n      }\n    }, {\n      key: \"prev\",\n      value: function prev() {\n        this._slide(ORDER_PREV);\n      }\n    }, {\n      key: \"pause\",\n      value: function pause() {\n        if (this._isSliding) {\n          triggerTransitionEnd(this._element);\n        }\n        this._clearInterval();\n      }\n    }, {\n      key: \"cycle\",\n      value: function cycle() {\n        var _this6 = this;\n        this._clearInterval();\n        this._updateInterval();\n        this._interval = setInterval(function () {\n          return _this6.nextWhenVisible();\n        }, this._config.interval);\n      }\n    }, {\n      key: \"_maybeEnableCycle\",\n      value: function _maybeEnableCycle() {\n        var _this7 = this;\n        if (!this._config.ride) {\n          return;\n        }\n        if (this._isSliding) {\n          EventHandler.one(this._element, EVENT_SLID, function () {\n            return _this7.cycle();\n          });\n          return;\n        }\n        this.cycle();\n      }\n    }, {\n      key: \"to\",\n      value: function to(index) {\n        var _this8 = this;\n        var items = this._getItems();\n        if (index > items.length - 1 || index < 0) {\n          return;\n        }\n        if (this._isSliding) {\n          EventHandler.one(this._element, EVENT_SLID, function () {\n            return _this8.to(index);\n          });\n          return;\n        }\n        var activeIndex = this._getItemIndex(this._getActive());\n        if (activeIndex === index) {\n          return;\n        }\n        var order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n        this._slide(order, items[index]);\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        if (this._swipeHelper) {\n          this._swipeHelper.dispose();\n        }\n        _get(_getPrototypeOf(Carousel.prototype), \"dispose\", this).call(this);\n      } // Private\n    }, {\n      key: \"_configAfterMerge\",\n      value: function _configAfterMerge(config) {\n        config.defaultInterval = config.interval;\n        return config;\n      }\n    }, {\n      key: \"_addEventListeners\",\n      value: function _addEventListeners() {\n        var _this9 = this;\n        if (this._config.keyboard) {\n          EventHandler.on(this._element, EVENT_KEYDOWN$1, function (event) {\n            return _this9._keydown(event);\n          });\n        }\n        if (this._config.pause === 'hover') {\n          EventHandler.on(this._element, EVENT_MOUSEENTER$1, function () {\n            return _this9.pause();\n          });\n          EventHandler.on(this._element, EVENT_MOUSELEAVE$1, function () {\n            return _this9._maybeEnableCycle();\n          });\n        }\n        if (this._config.touch && Swipe.isSupported()) {\n          this._addTouchEventListeners();\n        }\n      }\n    }, {\n      key: \"_addTouchEventListeners\",\n      value: function _addTouchEventListeners() {\n        var _this10 = this;\n        var _iterator5 = _createForOfIteratorHelper(SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var img = _step5.value;\n            EventHandler.on(img, EVENT_DRAG_START, function (event) {\n              return event.preventDefault();\n            });\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        var endCallBack = function endCallBack() {\n          if (_this10._config.pause !== 'hover') {\n            return;\n          } // If it's a touch-enabled device, mouseenter/leave are fired as\n          // part of the mouse compatibility events on first tap - the carousel\n          // would stop cycling until user tapped out of it;\n          // here, we listen for touchend, explicitly pause the carousel\n          // (as if it's the second time we tap on it, mouseenter compat event\n          // is NOT fired) and after a timeout (to allow for mouse compatibility\n          // events to fire) we explicitly restart cycling\n\n          _this10.pause();\n          if (_this10.touchTimeout) {\n            clearTimeout(_this10.touchTimeout);\n          }\n          _this10.touchTimeout = setTimeout(function () {\n            return _this10._maybeEnableCycle();\n          }, TOUCHEVENT_COMPAT_WAIT + _this10._config.interval);\n        };\n        var swipeConfig = {\n          leftCallback: function leftCallback() {\n            return _this10._slide(_this10._directionToOrder(DIRECTION_LEFT));\n          },\n          rightCallback: function rightCallback() {\n            return _this10._slide(_this10._directionToOrder(DIRECTION_RIGHT));\n          },\n          endCallback: endCallBack\n        };\n        this._swipeHelper = new Swipe(this._element, swipeConfig);\n      }\n    }, {\n      key: \"_keydown\",\n      value: function _keydown(event) {\n        if (/input|textarea/i.test(event.target.tagName)) {\n          return;\n        }\n        var direction = KEY_TO_DIRECTION[event.key];\n        if (direction) {\n          event.preventDefault();\n          this._slide(this._directionToOrder(direction));\n        }\n      }\n    }, {\n      key: \"_getItemIndex\",\n      value: function _getItemIndex(element) {\n        return this._getItems().indexOf(element);\n      }\n    }, {\n      key: \"_setActiveIndicatorElement\",\n      value: function _setActiveIndicatorElement(index) {\n        if (!this._indicatorsElement) {\n          return;\n        }\n        var activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);\n        activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\n        activeIndicator.removeAttribute('aria-current');\n        var newActiveIndicator = SelectorEngine.findOne(\"[data-bs-slide-to=\\\"\".concat(index, \"\\\"]\"), this._indicatorsElement);\n        if (newActiveIndicator) {\n          newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);\n          newActiveIndicator.setAttribute('aria-current', 'true');\n        }\n      }\n    }, {\n      key: \"_updateInterval\",\n      value: function _updateInterval() {\n        var element = this._activeElement || this._getActive();\n        if (!element) {\n          return;\n        }\n        var elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);\n        this._config.interval = elementInterval || this._config.defaultInterval;\n      }\n    }, {\n      key: \"_slide\",\n      value: function _slide(order) {\n        var _this11 = this;\n        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        if (this._isSliding) {\n          return;\n        }\n        var activeElement = this._getActive();\n        var isNext = order === ORDER_NEXT;\n        var nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);\n        if (nextElement === activeElement) {\n          return;\n        }\n        var nextElementIndex = this._getItemIndex(nextElement);\n        var triggerEvent = function triggerEvent(eventName) {\n          return EventHandler.trigger(_this11._element, eventName, {\n            relatedTarget: nextElement,\n            direction: _this11._orderToDirection(order),\n            from: _this11._getItemIndex(activeElement),\n            to: nextElementIndex\n          });\n        };\n        var slideEvent = triggerEvent(EVENT_SLIDE);\n        if (slideEvent.defaultPrevented) {\n          return;\n        }\n        if (!activeElement || !nextElement) {\n          // Some weirdness is happening, so we bail\n          // todo: change tests that use empty divs to avoid this check\n          return;\n        }\n        var isCycling = Boolean(this._interval);\n        this.pause();\n        this._isSliding = true;\n        this._setActiveIndicatorElement(nextElementIndex);\n        this._activeElement = nextElement;\n        var directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n        var orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n        nextElement.classList.add(orderClassName);\n        reflow(nextElement);\n        activeElement.classList.add(directionalClassName);\n        nextElement.classList.add(directionalClassName);\n        var completeCallBack = function completeCallBack() {\n          nextElement.classList.remove(directionalClassName, orderClassName);\n          nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n          activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\n          _this11._isSliding = false;\n          triggerEvent(EVENT_SLID);\n        };\n        this._queueCallback(completeCallBack, activeElement, this._isAnimated());\n        if (isCycling) {\n          this.cycle();\n        }\n      }\n    }, {\n      key: \"_isAnimated\",\n      value: function _isAnimated() {\n        return this._element.classList.contains(CLASS_NAME_SLIDE);\n      }\n    }, {\n      key: \"_getActive\",\n      value: function _getActive() {\n        return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n      }\n    }, {\n      key: \"_getItems\",\n      value: function _getItems() {\n        return SelectorEngine.find(SELECTOR_ITEM, this._element);\n      }\n    }, {\n      key: \"_clearInterval\",\n      value: function _clearInterval() {\n        if (this._interval) {\n          clearInterval(this._interval);\n          this._interval = null;\n        }\n      }\n    }, {\n      key: \"_directionToOrder\",\n      value: function _directionToOrder(direction) {\n        if (isRTL()) {\n          return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n        }\n        return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n      }\n    }, {\n      key: \"_orderToDirection\",\n      value: function _orderToDirection(order) {\n        if (isRTL()) {\n          return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        }\n        return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$b;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$b;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$c;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Carousel.getOrCreateInstance(this, config);\n          if (typeof config === 'number') {\n            data.to(config);\n            return;\n          }\n          if (typeof config === 'string') {\n            if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n              throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n            }\n            data[config]();\n          }\n        });\n      }\n    }]);\n    return Carousel;\n  }(BaseComponent);\n  /**\r\n   * Data API implementation\r\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {\n    var target = getElementFromSelector(this);\n    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n      return;\n    }\n    event.preventDefault();\n    var carousel = Carousel.getOrCreateInstance(target);\n    var slideIndex = this.getAttribute('data-bs-slide-to');\n    if (slideIndex) {\n      carousel.to(slideIndex);\n      carousel._maybeEnableCycle();\n      return;\n    }\n    if (Manipulator.getDataAttribute(this, 'slide') === 'next') {\n      carousel.next();\n      carousel._maybeEnableCycle();\n      return;\n    }\n    carousel.prev();\n    carousel._maybeEnableCycle();\n  });\n  EventHandler.on(window, EVENT_LOAD_DATA_API$3, function () {\n    var carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\n    var _iterator6 = _createForOfIteratorHelper(carousels),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var carousel = _step6.value;\n        Carousel.getOrCreateInstance(carousel);\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n  });\n  /**\r\n   * jQuery\r\n   */\n\n  defineJQueryPlugin(Carousel);\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): collapse.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n\n  var NAME$b = 'collapse';\n  var DATA_KEY$7 = 'bs.collapse';\n  var EVENT_KEY$7 = \".\".concat(DATA_KEY$7);\n  var DATA_API_KEY$4 = '.data-api';\n  var EVENT_SHOW$6 = \"show\".concat(EVENT_KEY$7);\n  var EVENT_SHOWN$6 = \"shown\".concat(EVENT_KEY$7);\n  var EVENT_HIDE$6 = \"hide\".concat(EVENT_KEY$7);\n  var EVENT_HIDDEN$6 = \"hidden\".concat(EVENT_KEY$7);\n  var EVENT_CLICK_DATA_API$4 = \"click\".concat(EVENT_KEY$7).concat(DATA_API_KEY$4);\n  var CLASS_NAME_SHOW$7 = 'show';\n  var CLASS_NAME_COLLAPSE = 'collapse';\n  var CLASS_NAME_COLLAPSING = 'collapsing';\n  var CLASS_NAME_COLLAPSED = 'collapsed';\n  var CLASS_NAME_DEEPER_CHILDREN = \":scope .\".concat(CLASS_NAME_COLLAPSE, \" .\").concat(CLASS_NAME_COLLAPSE);\n  var CLASS_NAME_HORIZONTAL = 'collapse-horizontal';\n  var WIDTH = 'width';\n  var HEIGHT = 'height';\n  var SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';\n  var SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\"collapse\"]';\n  var Default$a = {\n    parent: null,\n    toggle: true\n  };\n  var DefaultType$a = {\n    parent: '(null|element)',\n    toggle: 'boolean'\n  };\n  /**\r\n   * Class definition\r\n   */\n  var Collapse = /*#__PURE__*/function (_BaseComponent4) {\n    _inherits(Collapse, _BaseComponent4);\n    var _super6 = _createSuper(Collapse);\n    function Collapse(element, config) {\n      var _this12;\n      _classCallCheck(this, Collapse);\n      _this12 = _super6.call(this, element, config);\n      _this12._isTransitioning = false;\n      _this12._triggerArray = [];\n      var toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\n      var _iterator7 = _createForOfIteratorHelper(toggleList),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var elem = _step7.value;\n          var selector = getSelectorFromElement(elem);\n          var filterElement = SelectorEngine.find(selector).filter(function (foundElement) {\n            return foundElement === _this12._element;\n          });\n          if (selector !== null && filterElement.length) {\n            _this12._triggerArray.push(elem);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      _this12._initializeChildren();\n      if (!_this12._config.parent) {\n        _this12._addAriaAndCollapsedClass(_this12._triggerArray, _this12._isShown());\n      }\n      if (_this12._config.toggle) {\n        _this12.toggle();\n      }\n      return _this12;\n    } // Getters\n    _createClass(Collapse, [{\n      key: \"toggle\",\n      value:\n      // Public\n\n      function toggle() {\n        if (this._isShown()) {\n          this.hide();\n        } else {\n          this.show();\n        }\n      }\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this13 = this;\n        if (this._isTransitioning || this._isShown()) {\n          return;\n        }\n        var activeChildren = []; // find active children\n\n        if (this._config.parent) {\n          activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(function (element) {\n            return element !== _this13._element;\n          }).map(function (element) {\n            return Collapse.getOrCreateInstance(element, {\n              toggle: false\n            });\n          });\n        }\n        if (activeChildren.length && activeChildren[0]._isTransitioning) {\n          return;\n        }\n        var startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);\n        if (startEvent.defaultPrevented) {\n          return;\n        }\n        var _iterator8 = _createForOfIteratorHelper(activeChildren),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var activeInstance = _step8.value;\n            activeInstance.hide();\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n        var dimension = this._getDimension();\n        this._element.classList.remove(CLASS_NAME_COLLAPSE);\n        this._element.classList.add(CLASS_NAME_COLLAPSING);\n        this._element.style[dimension] = 0;\n        this._addAriaAndCollapsedClass(this._triggerArray, true);\n        this._isTransitioning = true;\n        var complete = function complete() {\n          _this13._isTransitioning = false;\n          _this13._element.classList.remove(CLASS_NAME_COLLAPSING);\n          _this13._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n          _this13._element.style[dimension] = '';\n          EventHandler.trigger(_this13._element, EVENT_SHOWN$6);\n        };\n        var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n        var scrollSize = \"scroll\".concat(capitalizedDimension);\n        this._queueCallback(complete, this._element, true);\n        this._element.style[dimension] = \"\".concat(this._element[scrollSize], \"px\");\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var _this14 = this;\n        if (this._isTransitioning || !this._isShown()) {\n          return;\n        }\n        var startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);\n        if (startEvent.defaultPrevented) {\n          return;\n        }\n        var dimension = this._getDimension();\n        this._element.style[dimension] = \"\".concat(this._element.getBoundingClientRect()[dimension], \"px\");\n        reflow(this._element);\n        this._element.classList.add(CLASS_NAME_COLLAPSING);\n        this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n        var _iterator9 = _createForOfIteratorHelper(this._triggerArray),\n          _step9;\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var trigger = _step9.value;\n            var element = getElementFromSelector(trigger);\n            if (element && !this._isShown(element)) {\n              this._addAriaAndCollapsedClass([trigger], false);\n            }\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n        this._isTransitioning = true;\n        var complete = function complete() {\n          _this14._isTransitioning = false;\n          _this14._element.classList.remove(CLASS_NAME_COLLAPSING);\n          _this14._element.classList.add(CLASS_NAME_COLLAPSE);\n          EventHandler.trigger(_this14._element, EVENT_HIDDEN$6);\n        };\n        this._element.style[dimension] = '';\n        this._queueCallback(complete, this._element, true);\n      }\n    }, {\n      key: \"_isShown\",\n      value: function _isShown() {\n        var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._element;\n        return element.classList.contains(CLASS_NAME_SHOW$7);\n      } // Private\n    }, {\n      key: \"_configAfterMerge\",\n      value: function _configAfterMerge(config) {\n        config.toggle = Boolean(config.toggle); // Coerce string values\n\n        config.parent = getElement(config.parent);\n        return config;\n      }\n    }, {\n      key: \"_getDimension\",\n      value: function _getDimension() {\n        return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;\n      }\n    }, {\n      key: \"_initializeChildren\",\n      value: function _initializeChildren() {\n        if (!this._config.parent) {\n          return;\n        }\n        var children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);\n        var _iterator10 = _createForOfIteratorHelper(children),\n          _step10;\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var element = _step10.value;\n            var selected = getElementFromSelector(element);\n            if (selected) {\n              this._addAriaAndCollapsedClass([element], this._isShown(selected));\n            }\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n    }, {\n      key: \"_getFirstLevelChildren\",\n      value: function _getFirstLevelChildren(selector) {\n        var children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent); // remove children if greater depth\n\n        return SelectorEngine.find(selector, this._config.parent).filter(function (element) {\n          return !children.includes(element);\n        });\n      }\n    }, {\n      key: \"_addAriaAndCollapsedClass\",\n      value: function _addAriaAndCollapsedClass(triggerArray, isOpen) {\n        if (!triggerArray.length) {\n          return;\n        }\n        var _iterator11 = _createForOfIteratorHelper(triggerArray),\n          _step11;\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var element = _step11.value;\n            element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);\n            element.setAttribute('aria-expanded', isOpen);\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$a;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$a;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$b;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        var _config = {};\n        if (typeof config === 'string' && /show|hide/.test(config)) {\n          _config.toggle = false;\n        }\n        return this.each(function () {\n          var data = Collapse.getOrCreateInstance(this, _config);\n          if (typeof config === 'string') {\n            if (typeof data[config] === 'undefined') {\n              throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n            }\n            data[config]();\n          }\n        });\n      }\n    }]);\n    return Collapse;\n  }(BaseComponent);\n  /**\r\n   * Data API implementation\r\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {\n    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n    if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {\n      event.preventDefault();\n    }\n    var selector = getSelectorFromElement(this);\n    var selectorElements = SelectorEngine.find(selector);\n    var _iterator12 = _createForOfIteratorHelper(selectorElements),\n      _step12;\n    try {\n      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n        var element = _step12.value;\n        Collapse.getOrCreateInstance(element, {\n          toggle: false\n        }).toggle();\n      }\n    } catch (err) {\n      _iterator12.e(err);\n    } finally {\n      _iterator12.f();\n    }\n  });\n  /**\r\n   * jQuery\r\n   */\n\n  defineJQueryPlugin(Collapse);\n  var top = 'top';\n  var bottom = 'bottom';\n  var right = 'right';\n  var left = 'left';\n  var auto = 'auto';\n  var basePlacements = [top, bottom, right, left];\n  var start = 'start';\n  var end = 'end';\n  var clippingParents = 'clippingParents';\n  var viewport = 'viewport';\n  var popper = 'popper';\n  var reference = 'reference';\n  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n    return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n  }, []);\n  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n    return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n  }, []); // modifiers that need to read the DOM\n\n  var beforeRead = 'beforeRead';\n  var read = 'read';\n  var afterRead = 'afterRead'; // pure-logic modifiers\n\n  var beforeMain = 'beforeMain';\n  var main = 'main';\n  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\n  var beforeWrite = 'beforeWrite';\n  var write = 'write';\n  var afterWrite = 'afterWrite';\n  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n  function getNodeName(element) {\n    return element ? (element.nodeName || '').toLowerCase() : null;\n  }\n  function getWindow(node) {\n    if (node == null) {\n      return window;\n    }\n    if (node.toString() !== '[object Window]') {\n      var ownerDocument = node.ownerDocument;\n      return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n    return node;\n  }\n  function isElement(node) {\n    var OwnElement = getWindow(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n  }\n  function isHTMLElement(node) {\n    var OwnElement = getWindow(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n  }\n  function isShadowRoot(node) {\n    // IE 11 has no ShadowRoot\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n  }\n\n  // and applies them to the HTMLElements such as popper and arrow\n\n  function applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function (name) {\n      var style = state.styles[name] || {};\n      var attributes = state.attributes[name] || {};\n      var element = state.elements[name]; // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      } // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe[cannot-write]\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (name) {\n        var value = attributes[name];\n        if (value === false) {\n          element.removeAttribute(name);\n        } else {\n          element.setAttribute(name, value === true ? '' : value);\n        }\n      });\n    });\n  }\n  function effect$2(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: '0',\n        top: '0',\n        margin: '0'\n      },\n      arrow: {\n        position: 'absolute'\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n    return function () {\n      Object.keys(state.elements).forEach(function (name) {\n        var element = state.elements[name];\n        var attributes = state.attributes[name] || {};\n        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n        var style = styleProperties.reduce(function (style, property) {\n          style[property] = '';\n          return style;\n        }, {}); // arrow is optional + virtual elements\n\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n          return;\n        }\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function (attribute) {\n          element.removeAttribute(attribute);\n        });\n      });\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var applyStyles$1 = {\n    name: 'applyStyles',\n    enabled: true,\n    phase: 'write',\n    fn: applyStyles,\n    effect: effect$2,\n    requires: ['computeStyles']\n  };\n  function getBasePlacement(placement) {\n    return placement.split('-')[0];\n  }\n  var max = Math.max;\n  var min = Math.min;\n  var round = Math.round;\n  function getUAString() {\n    var uaData = navigator.userAgentData;\n    if (uaData != null && uaData.brands) {\n      return uaData.brands.map(function (item) {\n        return item.brand + \"/\" + item.version;\n      }).join(' ');\n    }\n    return navigator.userAgent;\n  }\n  function isLayoutViewport() {\n    return !/^((?!chrome|android).)*safari/i.test(getUAString());\n  }\n  function getBoundingClientRect(element, includeScale, isFixedStrategy) {\n    if (includeScale === void 0) {\n      includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n      isFixedStrategy = false;\n    }\n    var clientRect = element.getBoundingClientRect();\n    var scaleX = 1;\n    var scaleY = 1;\n    if (includeScale && isHTMLElement(element)) {\n      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n    }\n    var _ref = isElement(element) ? getWindow(element) : window,\n      visualViewport = _ref.visualViewport;\n    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n    var width = clientRect.width / scaleX;\n    var height = clientRect.height / scaleY;\n    return {\n      width: width,\n      height: height,\n      top: y,\n      right: x + width,\n      bottom: y + height,\n      left: x,\n      x: x,\n      y: y\n    };\n  }\n\n  // means it doesn't take into account transforms.\n\n  function getLayoutRect(element) {\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n    if (Math.abs(clientRect.width - width) <= 1) {\n      width = clientRect.width;\n    }\n    if (Math.abs(clientRect.height - height) <= 1) {\n      height = clientRect.height;\n    }\n    return {\n      x: element.offsetLeft,\n      y: element.offsetTop,\n      width: width,\n      height: height\n    };\n  }\n  function contains(parent, child) {\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n    if (parent.contains(child)) {\n      return true;\n    } // then fallback to custom implementation with Shadow DOM support\n    else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n    return false;\n  }\n  function getComputedStyle$1(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n  }\n  function getDocumentElement(element) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return ((isElement(element) ? element.ownerDocument :\n    // $FlowFixMe[prop-missing]\n    element.document) || window.document).documentElement;\n  }\n  function getParentNode(element) {\n    if (getNodeName(element) === 'html') {\n      return element;\n    }\n    return (\n      // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n      // $FlowFixMe[incompatible-return]\n      // $FlowFixMe[prop-missing]\n      element.assignedSlot ||\n      // step into the shadow DOM of the parent of a slotted node\n      element.parentNode || (\n      // DOM Element detected\n      isShadowRoot(element) ? element.host : null) ||\n      // ShadowRoot detected\n      // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n      getDocumentElement(element) // fallback\n    );\n  }\n\n  function getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) ||\n    // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle$1(element).position === 'fixed') {\n      return null;\n    }\n    return element.offsetParent;\n  } // `.offsetParent` reports `null` for fixed elements, while absolute elements\n  // return the containing block\n\n  function getContainingBlock(element) {\n    var isFirefox = /firefox/i.test(getUAString());\n    var isIE = /Trident/i.test(getUAString());\n    if (isIE && isHTMLElement(element)) {\n      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n      var elementCss = getComputedStyle$1(element);\n      if (elementCss.position === 'fixed') {\n        return null;\n      }\n    }\n    var currentNode = getParentNode(element);\n    if (isShadowRoot(currentNode)) {\n      currentNode = currentNode.host;\n    }\n    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n      var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n      // create a containing block.\n      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n        return currentNode;\n      } else {\n        currentNode = currentNode.parentNode;\n      }\n    }\n    return null;\n  } // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n\n  function getOffsetParent(element) {\n    var window = getWindow(element);\n    var offsetParent = getTrueOffsetParent(element);\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {\n      return window;\n    }\n    return offsetParent || getContainingBlock(element) || window;\n  }\n  function getMainAxisFromPlacement(placement) {\n    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n  }\n  function within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n  }\n  function withinMaxClamp(min, value, max) {\n    var v = within(min, value, max);\n    return v > max ? max : v;\n  }\n  function getFreshSideObject() {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n  function mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), paddingObject);\n  }\n  function expandToHashMap(value, keys) {\n    return keys.reduce(function (hashMap, key) {\n      hashMap[key] = value;\n      return hashMap;\n    }, {});\n  }\n  var toPaddingObject = function toPaddingObject(padding, state) {\n    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : padding;\n    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  };\n  function arrow(_ref) {\n    var _state$modifiersData$;\n    var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [left, right].indexOf(basePlacement) >= 0;\n    var len = isVertical ? 'height' : 'width';\n    if (!arrowElement || !popperOffsets) {\n      return;\n    }\n    var paddingObject = toPaddingObject(options.padding, state);\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === 'y' ? top : left;\n    var maxProp = axis === 'y' ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = getOffsetParent(arrowElement);\n    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n\n    var min = paddingObject[minProp];\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n    var axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n  }\n  function effect$1(_ref2) {\n    var state = _ref2.state,\n      options = _ref2.options;\n    var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n    if (arrowElement == null) {\n      return;\n    } // CSS selector\n\n    if (typeof arrowElement === 'string') {\n      arrowElement = state.elements.popper.querySelector(arrowElement);\n      if (!arrowElement) {\n        return;\n      }\n    }\n    if (!contains(state.elements.popper, arrowElement)) {\n      return;\n    }\n    state.elements.arrow = arrowElement;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var arrow$1 = {\n    name: 'arrow',\n    enabled: true,\n    phase: 'main',\n    fn: arrow,\n    effect: effect$1,\n    requires: ['popperOffsets'],\n    requiresIfExists: ['preventOverflow']\n  };\n  function getVariation(placement) {\n    return placement.split('-')[1];\n  }\n  var unsetSides = {\n    top: 'auto',\n    right: 'auto',\n    bottom: 'auto',\n    left: 'auto'\n  }; // Round the offsets to the nearest suitable subpixel based on the DPR.\n  // Zooming can change the DPR, but it seems to report a value that will\n  // cleanly divide the values into the appropriate subpixels.\n\n  function roundOffsetsByDPR(_ref) {\n    var x = _ref.x,\n      y = _ref.y;\n    var win = window;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n      x: round(x * dpr) / dpr || 0,\n      y: round(y * dpr) / dpr || 0\n    };\n  }\n  function mapToStyles(_ref2) {\n    var _Object$assign2;\n    var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n    var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n      x: x,\n      y: y\n    }) : {\n      x: x,\n      y: y\n    };\n    x = _ref3.x;\n    y = _ref3.y;\n    var hasX = offsets.hasOwnProperty('x');\n    var hasY = offsets.hasOwnProperty('y');\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n    if (adaptive) {\n      var offsetParent = getOffsetParent(popper);\n      var heightProp = 'clientHeight';\n      var widthProp = 'clientWidth';\n      if (offsetParent === getWindow(popper)) {\n        offsetParent = getDocumentElement(popper);\n        if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {\n          heightProp = 'scrollHeight';\n          widthProp = 'scrollWidth';\n        }\n      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n      offsetParent = offsetParent;\n      if (placement === top || (placement === left || placement === right) && variation === end) {\n        sideY = bottom;\n        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :\n        // $FlowFixMe[prop-missing]\n        offsetParent[heightProp];\n        y -= offsetY - popperRect.height;\n        y *= gpuAcceleration ? 1 : -1;\n      }\n      if (placement === left || (placement === top || placement === bottom) && variation === end) {\n        sideX = right;\n        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :\n        // $FlowFixMe[prop-missing]\n        offsetParent[widthProp];\n        x -= offsetX - popperRect.width;\n        x *= gpuAcceleration ? 1 : -1;\n      }\n    }\n    var commonStyles = Object.assign({\n      position: position\n    }, adaptive && unsetSides);\n    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n      x: x,\n      y: y\n    }) : {\n      x: x,\n      y: y\n    };\n    x = _ref4.x;\n    y = _ref4.y;\n    if (gpuAcceleration) {\n      var _Object$assign;\n      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n  }\n  function computeStyles(_ref5) {\n    var state = _ref5.state,\n      options = _ref5.options;\n    var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n    var commonStyles = {\n      placement: getBasePlacement(state.placement),\n      variation: getVariation(state.placement),\n      popper: state.elements.popper,\n      popperRect: state.rects.popper,\n      gpuAcceleration: gpuAcceleration,\n      isFixed: state.options.strategy === 'fixed'\n    };\n    if (state.modifiersData.popperOffsets != null) {\n      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.popperOffsets,\n        position: state.options.strategy,\n        adaptive: adaptive,\n        roundOffsets: roundOffsets\n      })));\n    }\n    if (state.modifiersData.arrow != null) {\n      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        adaptive: false,\n        roundOffsets: roundOffsets\n      })));\n    }\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-placement': state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var computeStyles$1 = {\n    name: 'computeStyles',\n    enabled: true,\n    phase: 'beforeWrite',\n    fn: computeStyles,\n    data: {}\n  };\n  var passive = {\n    passive: true\n  };\n  function effect(_ref) {\n    var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n    var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n    var window = getWindow(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.addEventListener('scroll', instance.update, passive);\n      });\n    }\n    if (resize) {\n      window.addEventListener('resize', instance.update, passive);\n    }\n    return function () {\n      if (scroll) {\n        scrollParents.forEach(function (scrollParent) {\n          scrollParent.removeEventListener('scroll', instance.update, passive);\n        });\n      }\n      if (resize) {\n        window.removeEventListener('resize', instance.update, passive);\n      }\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var eventListeners = {\n    name: 'eventListeners',\n    enabled: true,\n    phase: 'write',\n    fn: function fn() {},\n    effect: effect,\n    data: {}\n  };\n  var hash$1 = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash$1[matched];\n    });\n  }\n  var hash = {\n    start: 'end',\n    end: 'start'\n  };\n  function getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function (matched) {\n      return hash[matched];\n    });\n  }\n  function getWindowScroll(node) {\n    var win = getWindow(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n      scrollLeft: scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    // Popper 1 is broken in this case and never had a bug report so let's assume\n    // it's not an issue. I don't think anyone ever specifies width on <html>\n    // anyway.\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\n    // this (e.g. Edge 2019, IE11, Safari)\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n  }\n  function getViewportRect(element, strategy) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0;\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height;\n      var layoutViewport = isLayoutViewport();\n      if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n    return {\n      width: width,\n      height: height,\n      x: x + getWindowScrollBarX(element),\n      y: y\n    };\n  }\n\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\n  function getDocumentRect(element) {\n    var _element$ownerDocumen;\n    var html = getDocumentElement(element);\n    var winScroll = getWindowScroll(element);\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -winScroll.scrollTop;\n    if (getComputedStyle$1(body || html).direction === 'rtl') {\n      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n  function isScrollParent(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    var _getComputedStyle = getComputedStyle$1(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n  }\n  function getScrollParent(node) {\n    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n      // $FlowFixMe[incompatible-return]: assume body is always available\n      return node.ownerDocument.body;\n    }\n    if (isHTMLElement(node) && isScrollParent(node)) {\n      return node;\n    }\n    return getScrollParent(getParentNode(node));\n  }\n\n  /*\r\n  given a DOM element, return the list of all scroll parents, up the list of ancesors\r\n  until we get to the top window object. This list is what we attach scroll listeners\r\n  to, because if any of these parent elements scroll, we'll need to re-calculate the\r\n  reference element's position.\r\n  */\n\n  function listScrollParents(element, list) {\n    var _element$ownerDocumen;\n    if (list === void 0) {\n      list = [];\n    }\n    var scrollParent = getScrollParent(element);\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n    var win = getWindow(scrollParent);\n    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList :\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    updatedList.concat(listScrollParents(getParentNode(target)));\n  }\n  function rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n      left: rect.x,\n      top: rect.y,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    });\n  }\n  function getInnerBoundingClientRect(element, strategy) {\n    var rect = getBoundingClientRect(element, false, strategy === 'fixed');\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n  }\n  function getClientRectFromMixedType(element, clippingParent, strategy) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n  } // A \"clipping parent\" is an overflowable container with the characteristic of\n  // clipping (or hiding) overflowing elements with a position different from\n  // `initial`\n\n  function getClippingParents(element) {\n    var clippingParents = listScrollParents(getParentNode(element));\n    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n      return [];\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n    return clippingParents.filter(function (clippingParent) {\n      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n    });\n  } // Gets the maximum area that the element is visible in due to any number of\n  // clipping parents\n\n  function getClippingRect(element, boundary, rootBoundary, strategy) {\n    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n    var firstClippingParent = clippingParents[0];\n    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n      var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n  }\n  function computeOffsets(_ref) {\n    var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\n    var offsets;\n    switch (basePlacement) {\n      case top:\n        offsets = {\n          x: commonX,\n          y: reference.y - element.height\n        };\n        break;\n      case bottom:\n        offsets = {\n          x: commonX,\n          y: reference.y + reference.height\n        };\n        break;\n      case right:\n        offsets = {\n          x: reference.x + reference.width,\n          y: commonY\n        };\n        break;\n      case left:\n        offsets = {\n          x: reference.x - element.width,\n          y: commonY\n        };\n        break;\n      default:\n        offsets = {\n          x: reference.x,\n          y: reference.y\n        };\n    }\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n    if (mainAxis != null) {\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      switch (variation) {\n        case start:\n          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n          break;\n        case end:\n          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n          break;\n      }\n    }\n    return offsets;\n  }\n  function detectOverflow(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$strategy = _options.strategy,\n      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n    var referenceClientRect = getBoundingClientRect(state.elements.reference);\n    var popperOffsets = computeOffsets({\n      reference: referenceClientRect,\n      element: popperRect,\n      strategy: 'absolute',\n      placement: placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n\n    var overflowOffsets = {\n      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n      right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n    if (elementContext === popper && offsetData) {\n      var offset = offsetData[placement];\n      Object.keys(overflowOffsets).forEach(function (key) {\n        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n        overflowOffsets[key] += offset[axis] * multiply;\n      });\n    }\n    return overflowOffsets;\n  }\n  function computeAutoPlacement(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n      return getVariation(placement) === variation;\n    }) : basePlacements;\n    var allowedPlacements = placements$1.filter(function (placement) {\n      return allowedAutoPlacements.indexOf(placement) >= 0;\n    });\n    if (allowedPlacements.length === 0) {\n      allowedPlacements = placements$1;\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n    var overflows = allowedPlacements.reduce(function (acc, placement) {\n      acc[placement] = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding\n      })[getBasePlacement(placement)];\n      return acc;\n    }, {});\n    return Object.keys(overflows).sort(function (a, b) {\n      return overflows[a] - overflows[b];\n    });\n  }\n  function getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n      return [];\n    }\n    var oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n  }\n  function flip(_ref) {\n    var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n    if (state.modifiersData[name]._skip) {\n      return;\n    }\n    var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding,\n        flipVariations: flipVariations,\n        allowedAutoPlacements: allowedAutoPlacements\n      }) : placement);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements[0];\n    for (var i = 0; i < placements.length; i++) {\n      var placement = placements[i];\n      var _basePlacement = getBasePlacement(placement);\n      var isStartVariation = getVariation(placement) === start;\n      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n      var len = isVertical ? 'width' : 'height';\n      var overflow = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        altBoundary: altBoundary,\n        padding: padding\n      });\n      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n      if (referenceRect[len] > popperRect[len]) {\n        mainVariationSide = getOppositePlacement(mainVariationSide);\n      }\n      var altVariationSide = getOppositePlacement(mainVariationSide);\n      var checks = [];\n      if (checkMainAxis) {\n        checks.push(overflow[_basePlacement] <= 0);\n      }\n      if (checkAltAxis) {\n        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n      }\n      if (checks.every(function (check) {\n        return check;\n      })) {\n        firstFittingPlacement = placement;\n        makeFallbackChecks = false;\n        break;\n      }\n      checksMap.set(placement, checks);\n    }\n    if (makeFallbackChecks) {\n      // `2` may be desired in some cases – research later\n      var numberOfChecks = flipVariations ? 3 : 1;\n      var _loop = function _loop(_i) {\n        var fittingPlacement = placements.find(function (placement) {\n          var checks = checksMap.get(placement);\n          if (checks) {\n            return checks.slice(0, _i).every(function (check) {\n              return check;\n            });\n          }\n        });\n        if (fittingPlacement) {\n          firstFittingPlacement = fittingPlacement;\n          return \"break\";\n        }\n      };\n      for (var _i = numberOfChecks; _i > 0; _i--) {\n        var _ret = _loop(_i);\n        if (_ret === \"break\") break;\n      }\n    }\n    if (state.placement !== firstFittingPlacement) {\n      state.modifiersData[name]._skip = true;\n      state.placement = firstFittingPlacement;\n      state.reset = true;\n    }\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var flip$1 = {\n    name: 'flip',\n    enabled: true,\n    phase: 'main',\n    fn: flip,\n    requiresIfExists: ['offset'],\n    data: {\n      _skip: false\n    }\n  };\n  function getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n      preventedOffsets = {\n        x: 0,\n        y: 0\n      };\n    }\n    return {\n      top: overflow.top - rect.height - preventedOffsets.y,\n      right: overflow.right - rect.width + preventedOffsets.x,\n      bottom: overflow.bottom - rect.height + preventedOffsets.y,\n      left: overflow.left - rect.width - preventedOffsets.x\n    };\n  }\n  function isAnySideFullyClipped(overflow) {\n    return [top, right, bottom, left].some(function (side) {\n      return overflow[side] >= 0;\n    });\n  }\n  function hide(_ref) {\n    var state = _ref.state,\n      name = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n      elementContext: 'reference'\n    });\n    var popperAltOverflow = detectOverflow(state, {\n      altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name] = {\n      referenceClippingOffsets: referenceClippingOffsets,\n      popperEscapeOffsets: popperEscapeOffsets,\n      isReferenceHidden: isReferenceHidden,\n      hasPopperEscaped: hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-reference-hidden': isReferenceHidden,\n      'data-popper-escaped': hasPopperEscaped\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var hide$1 = {\n    name: 'hide',\n    enabled: true,\n    phase: 'main',\n    requiresIfExists: ['preventOverflow'],\n    fn: hide\n  };\n  function distanceAndSkiddingToXY(placement, rects, offset) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n        placement: placement\n      })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [left, right].indexOf(basePlacement) >= 0 ? {\n      x: distance,\n      y: skidding\n    } : {\n      x: skidding,\n      y: distance\n    };\n  }\n  function offset(_ref2) {\n    var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n    var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n    var data = placements.reduce(function (acc, placement) {\n      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n      return acc;\n    }, {});\n    var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n    if (state.modifiersData.popperOffsets != null) {\n      state.modifiersData.popperOffsets.x += x;\n      state.modifiersData.popperOffsets.y += y;\n    }\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var offset$1 = {\n    name: 'offset',\n    enabled: true,\n    phase: 'main',\n    requires: ['popperOffsets'],\n    fn: offset\n  };\n  function popperOffsets(_ref) {\n    var state = _ref.state,\n      name = _ref.name;\n    // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n    state.modifiersData[name] = computeOffsets({\n      reference: state.rects.reference,\n      element: state.rects.popper,\n      strategy: 'absolute',\n      placement: state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var popperOffsets$1 = {\n    name: 'popperOffsets',\n    enabled: true,\n    phase: 'read',\n    fn: popperOffsets,\n    data: {}\n  };\n  function getAltAxis(axis) {\n    return axis === 'x' ? 'y' : 'x';\n  }\n  function preventOverflow(_ref) {\n    var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n    var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      altBoundary: altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : tetherOffset;\n    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n      mainAxis: tetherOffsetValue,\n      altAxis: tetherOffsetValue\n    } : Object.assign({\n      mainAxis: 0,\n      altAxis: 0\n    }, tetherOffsetValue);\n    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n    var data = {\n      x: 0,\n      y: 0\n    };\n    if (!popperOffsets) {\n      return;\n    }\n    if (checkMainAxis) {\n      var _offsetModifierState$;\n      var mainSide = mainAxis === 'y' ? top : left;\n      var altSide = mainAxis === 'y' ? bottom : right;\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      var offset = popperOffsets[mainAxis];\n      var min$1 = offset + overflow[mainSide];\n      var max$1 = offset - overflow[altSide];\n      var additive = tether ? -popperRect[len] / 2 : 0;\n      var minLen = variation === start ? referenceRect[len] : popperRect[len];\n      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n      // outside the reference bounds\n\n      var arrowElement = state.elements.arrow;\n      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n        width: 0,\n        height: 0\n      };\n      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n      var arrowPaddingMin = arrowPaddingObject[mainSide];\n      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n      // to include its full size in the calculation. If the reference is small\n      // and near the edge of a boundary, the popper can overflow even if the\n      // reference is not overflowing as well (e.g. virtual elements with no\n      // width or height)\n\n      var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n      var tetherMax = offset + maxOffset - offsetModifierValue;\n      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n      popperOffsets[mainAxis] = preventedOffset;\n      data[mainAxis] = preventedOffset - offset;\n    }\n    if (checkAltAxis) {\n      var _offsetModifierState$2;\n      var _mainSide = mainAxis === 'x' ? top : left;\n      var _altSide = mainAxis === 'x' ? bottom : right;\n      var _offset = popperOffsets[altAxis];\n      var _len = altAxis === 'y' ? 'height' : 'width';\n      var _min = _offset + overflow[_mainSide];\n      var _max = _offset - overflow[_altSide];\n      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n      popperOffsets[altAxis] = _preventedOffset;\n      data[altAxis] = _preventedOffset - _offset;\n    }\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var preventOverflow$1 = {\n    name: 'preventOverflow',\n    enabled: true,\n    phase: 'main',\n    fn: preventOverflow,\n    requiresIfExists: ['offset']\n  };\n  function getHTMLElementScroll(element) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  function getNodeScroll(node) {\n    if (node === getWindow(node) || !isHTMLElement(node)) {\n      return getWindowScroll(node);\n    } else {\n      return getHTMLElementScroll(node);\n    }\n  }\n  function isElementScaled(element) {\n    var rect = element.getBoundingClientRect();\n    var scaleX = round(rect.width) / element.offsetWidth || 1;\n    var scaleY = round(rect.height) / element.offsetHeight || 1;\n    return scaleX !== 1 || scaleY !== 1;\n  } // Returns the composite rect of an element relative to its offsetParent.\n  // Composite means it takes into account transforms as well as layout.\n\n  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n      isFixed = false;\n    }\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== 'body' ||\n      // https://github.com/popperjs/popper-core/issues/1078\n      isScrollParent(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        offsets = getBoundingClientRect(offsetParent, true);\n        offsets.x += offsetParent.clientLeft;\n        offsets.y += offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n  function order(modifiers) {\n    var map = new Map();\n    var visited = new Set();\n    var result = [];\n    modifiers.forEach(function (modifier) {\n      map.set(modifier.name, modifier);\n    }); // On visiting object, check for its dependencies and visit them recursively\n\n    function sort(modifier) {\n      visited.add(modifier.name);\n      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n      requires.forEach(function (dep) {\n        if (!visited.has(dep)) {\n          var depModifier = map.get(dep);\n          if (depModifier) {\n            sort(depModifier);\n          }\n        }\n      });\n      result.push(modifier);\n    }\n    modifiers.forEach(function (modifier) {\n      if (!visited.has(modifier.name)) {\n        // check for visited object\n        sort(modifier);\n      }\n    });\n    return result;\n  }\n  function orderModifiers(modifiers) {\n    // order based on dependencies\n    var orderedModifiers = order(modifiers); // order based on phase\n\n    return modifierPhases.reduce(function (acc, phase) {\n      return acc.concat(orderedModifiers.filter(function (modifier) {\n        return modifier.phase === phase;\n      }));\n    }, []);\n  }\n  function debounce(fn) {\n    var pending;\n    return function () {\n      if (!pending) {\n        pending = new Promise(function (resolve) {\n          Promise.resolve().then(function () {\n            pending = undefined;\n            resolve(fn());\n          });\n        });\n      }\n      return pending;\n    };\n  }\n  function mergeByName(modifiers) {\n    var merged = modifiers.reduce(function (merged, current) {\n      var existing = merged[current.name];\n      merged[current.name] = existing ? Object.assign({}, existing, current, {\n        options: Object.assign({}, existing.options, current.options),\n        data: Object.assign({}, existing.data, current.data)\n      }) : current;\n      return merged;\n    }, {}); // IE11 does not support Object.values\n\n    return Object.keys(merged).map(function (key) {\n      return merged[key];\n    });\n  }\n  var DEFAULT_OPTIONS = {\n    placement: 'bottom',\n    modifiers: [],\n    strategy: 'absolute'\n  };\n  function areValidElements() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return !args.some(function (element) {\n      return !(element && typeof element.getBoundingClientRect === 'function');\n    });\n  }\n  function popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n      generatorOptions = {};\n    }\n    var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper(reference, popper, options) {\n      if (options === void 0) {\n        options = defaultOptions;\n      }\n      var state = {\n        placement: 'bottom',\n        orderedModifiers: [],\n        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n        modifiersData: {},\n        elements: {\n          reference: reference,\n          popper: popper\n        },\n        attributes: {},\n        styles: {}\n      };\n      var effectCleanupFns = [];\n      var isDestroyed = false;\n      var instance = {\n        state: state,\n        setOptions: function setOptions(setOptionsAction) {\n          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n          cleanupModifierEffects();\n          state.options = Object.assign({}, defaultOptions, state.options, options);\n          state.scrollParents = {\n            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n            popper: listScrollParents(popper)\n          }; // Orders the modifiers based on their dependencies and `phase`\n          // properties\n\n          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n          state.orderedModifiers = orderedModifiers.filter(function (m) {\n            return m.enabled;\n          }); // Validate the provided modifiers so that the consumer will get warned\n\n          runModifierEffects();\n          return instance.update();\n        },\n        // Sync update – it will always be executed, even if not necessary. This\n        // is useful for low frequency updates where sync behavior simplifies the\n        // logic.\n        // For high frequency updates (e.g. `resize` and `scroll` events), always\n        // prefer the async Popper#update method\n        forceUpdate: function forceUpdate() {\n          if (isDestroyed) {\n            return;\n          }\n          var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n          // anymore\n\n          if (!areValidElements(reference, popper)) {\n            return;\n          } // Store the reference and popper rects to be read by modifiers\n\n          state.rects = {\n            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n            popper: getLayoutRect(popper)\n          }; // Modifiers have the ability to reset the current update cycle. The\n          // most common use case for this is the `flip` modifier changing the\n          // placement, which then needs to re-run all the modifiers, because the\n          // logic was previously ran for the previous placement and is therefore\n          // stale/incorrect\n\n          state.reset = false;\n          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n          // is filled with the initial data specified by the modifier. This means\n          // it doesn't persist and is fresh on each update.\n          // To ensure persistent data, use `${name}#persistent`\n\n          state.orderedModifiers.forEach(function (modifier) {\n            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n          });\n          for (var index = 0; index < state.orderedModifiers.length; index++) {\n            if (state.reset === true) {\n              state.reset = false;\n              index = -1;\n              continue;\n            }\n            var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n            if (typeof fn === 'function') {\n              state = fn({\n                state: state,\n                options: _options,\n                name: name,\n                instance: instance\n              }) || state;\n            }\n          }\n        },\n        // Async and optimistically optimized update – it will not be executed if\n        // not necessary (debounced to run at most once-per-tick)\n        update: debounce(function () {\n          return new Promise(function (resolve) {\n            instance.forceUpdate();\n            resolve(state);\n          });\n        }),\n        destroy: function destroy() {\n          cleanupModifierEffects();\n          isDestroyed = true;\n        }\n      };\n      if (!areValidElements(reference, popper)) {\n        return instance;\n      }\n      instance.setOptions(options).then(function (state) {\n        if (!isDestroyed && options.onFirstUpdate) {\n          options.onFirstUpdate(state);\n        }\n      }); // Modifiers have the ability to execute arbitrary code before the first\n      // update cycle runs. They will be executed in the same order as the update\n      // cycle. This is useful when a modifier adds some persistent data that\n      // other modifiers need to use, but the modifier is run after the dependent\n      // one.\n\n      function runModifierEffects() {\n        state.orderedModifiers.forEach(function (_ref3) {\n          var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n          if (typeof effect === 'function') {\n            var cleanupFn = effect({\n              state: state,\n              name: name,\n              instance: instance,\n              options: options\n            });\n            var noopFn = function noopFn() {};\n            effectCleanupFns.push(cleanupFn || noopFn);\n          }\n        });\n      }\n      function cleanupModifierEffects() {\n        effectCleanupFns.forEach(function (fn) {\n          return fn();\n        });\n        effectCleanupFns = [];\n      }\n      return instance;\n    };\n  }\n  var createPopper$2 = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\n  var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];\n  var createPopper$1 = /*#__PURE__*/popperGenerator({\n    defaultModifiers: defaultModifiers$1\n  }); // eslint-disable-next-line import/no-unused-modules\n\n  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\n  var createPopper = /*#__PURE__*/popperGenerator({\n    defaultModifiers: defaultModifiers\n  }); // eslint-disable-next-line import/no-unused-modules\n\n  var Popper = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({\n    __proto__: null,\n    popperGenerator: popperGenerator,\n    detectOverflow: detectOverflow,\n    createPopperBase: createPopper$2,\n    createPopper: createPopper,\n    createPopperLite: createPopper$1,\n    top: top,\n    bottom: bottom,\n    right: right,\n    left: left,\n    auto: auto,\n    basePlacements: basePlacements,\n    start: start,\n    end: end,\n    clippingParents: clippingParents,\n    viewport: viewport,\n    popper: popper,\n    reference: reference,\n    variationPlacements: variationPlacements,\n    placements: placements,\n    beforeRead: beforeRead,\n    read: read,\n    afterRead: afterRead,\n    beforeMain: beforeMain,\n    main: main,\n    afterMain: afterMain,\n    beforeWrite: beforeWrite,\n    write: write,\n    afterWrite: afterWrite,\n    modifierPhases: modifierPhases,\n    applyStyles: applyStyles$1,\n    arrow: arrow$1,\n    computeStyles: computeStyles$1,\n    eventListeners: eventListeners,\n    flip: flip$1,\n    hide: hide$1,\n    offset: offset$1,\n    popperOffsets: popperOffsets$1,\n    preventOverflow: preventOverflow$1\n  }, Symbol.toStringTag, {\n    value: 'Module'\n  }));\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): dropdown.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n\n  var NAME$a = 'dropdown';\n  var DATA_KEY$6 = 'bs.dropdown';\n  var EVENT_KEY$6 = \".\".concat(DATA_KEY$6);\n  var DATA_API_KEY$3 = '.data-api';\n  var ESCAPE_KEY$2 = 'Escape';\n  var TAB_KEY$1 = 'Tab';\n  var ARROW_UP_KEY$1 = 'ArrowUp';\n  var ARROW_DOWN_KEY$1 = 'ArrowDown';\n  var RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\n\n  var EVENT_HIDE$5 = \"hide\".concat(EVENT_KEY$6);\n  var EVENT_HIDDEN$5 = \"hidden\".concat(EVENT_KEY$6);\n  var EVENT_SHOW$5 = \"show\".concat(EVENT_KEY$6);\n  var EVENT_SHOWN$5 = \"shown\".concat(EVENT_KEY$6);\n  var EVENT_CLICK_DATA_API$3 = \"click\".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);\n  var EVENT_KEYDOWN_DATA_API = \"keydown\".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);\n  var EVENT_KEYUP_DATA_API = \"keyup\".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);\n  var CLASS_NAME_SHOW$6 = 'show';\n  var CLASS_NAME_DROPUP = 'dropup';\n  var CLASS_NAME_DROPEND = 'dropend';\n  var CLASS_NAME_DROPSTART = 'dropstart';\n  var CLASS_NAME_DROPUP_CENTER = 'dropup-center';\n  var CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';\n  var SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\"dropdown\"]:not(.disabled):not(:disabled)';\n  var SELECTOR_DATA_TOGGLE_SHOWN = \"\".concat(SELECTOR_DATA_TOGGLE$3, \".\").concat(CLASS_NAME_SHOW$6);\n  var SELECTOR_MENU = '.dropdown-menu';\n  var SELECTOR_NAVBAR = '.navbar';\n  var SELECTOR_NAVBAR_NAV = '.navbar-nav';\n  var SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\n  var PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';\n  var PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';\n  var PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';\n  var PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';\n  var PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';\n  var PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';\n  var PLACEMENT_TOPCENTER = 'top';\n  var PLACEMENT_BOTTOMCENTER = 'bottom';\n  var Default$9 = {\n    autoClose: true,\n    boundary: 'clippingParents',\n    display: 'dynamic',\n    offset: [0, 2],\n    popperConfig: null,\n    reference: 'toggle'\n  };\n  var DefaultType$9 = {\n    autoClose: '(boolean|string)',\n    boundary: '(string|element)',\n    display: 'string',\n    offset: '(array|string|function)',\n    popperConfig: '(null|object|function)',\n    reference: '(string|element|object)'\n  };\n  /**\r\n   * Class definition\r\n   */\n  var Dropdown = /*#__PURE__*/function (_BaseComponent5) {\n    _inherits(Dropdown, _BaseComponent5);\n    var _super7 = _createSuper(Dropdown);\n    function Dropdown(element, config) {\n      var _this15;\n      _classCallCheck(this, Dropdown);\n      _this15 = _super7.call(this, element, config);\n      _this15._popper = null;\n      _this15._parent = _this15._element.parentNode; // dropdown wrapper\n      // todo: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.2/forms/input-group/\n\n      _this15._menu = SelectorEngine.next(_this15._element, SELECTOR_MENU)[0] || SelectorEngine.prev(_this15._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, _this15._parent);\n      _this15._inNavbar = _this15._detectNavbar();\n      return _this15;\n    } // Getters\n    _createClass(Dropdown, [{\n      key: \"toggle\",\n      value:\n      // Public\n\n      function toggle() {\n        return this._isShown() ? this.hide() : this.show();\n      }\n    }, {\n      key: \"show\",\n      value: function show() {\n        if (isDisabled(this._element) || this._isShown()) {\n          return;\n        }\n        var relatedTarget = {\n          relatedTarget: this._element\n        };\n        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);\n        if (showEvent.defaultPrevented) {\n          return;\n        }\n        this._createPopper(); // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n        if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {\n          var _ref9;\n          var _iterator13 = _createForOfIteratorHelper((_ref9 = []).concat.apply(_ref9, _toConsumableArray(document.body.children))),\n            _step13;\n          try {\n            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n              var element = _step13.value;\n              EventHandler.on(element, 'mouseover', noop);\n            }\n          } catch (err) {\n            _iterator13.e(err);\n          } finally {\n            _iterator13.f();\n          }\n        }\n        this._element.focus();\n        this._element.setAttribute('aria-expanded', true);\n        this._menu.classList.add(CLASS_NAME_SHOW$6);\n        this._element.classList.add(CLASS_NAME_SHOW$6);\n        EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        if (isDisabled(this._element) || !this._isShown()) {\n          return;\n        }\n        var relatedTarget = {\n          relatedTarget: this._element\n        };\n        this._completeHide(relatedTarget);\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        if (this._popper) {\n          this._popper.destroy();\n        }\n        _get(_getPrototypeOf(Dropdown.prototype), \"dispose\", this).call(this);\n      }\n    }, {\n      key: \"update\",\n      value: function update() {\n        this._inNavbar = this._detectNavbar();\n        if (this._popper) {\n          this._popper.update();\n        }\n      } // Private\n    }, {\n      key: \"_completeHide\",\n      value: function _completeHide(relatedTarget) {\n        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);\n        if (hideEvent.defaultPrevented) {\n          return;\n        } // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n\n        if ('ontouchstart' in document.documentElement) {\n          var _ref10;\n          var _iterator14 = _createForOfIteratorHelper((_ref10 = []).concat.apply(_ref10, _toConsumableArray(document.body.children))),\n            _step14;\n          try {\n            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n              var element = _step14.value;\n              EventHandler.off(element, 'mouseover', noop);\n            }\n          } catch (err) {\n            _iterator14.e(err);\n          } finally {\n            _iterator14.f();\n          }\n        }\n        if (this._popper) {\n          this._popper.destroy();\n        }\n        this._menu.classList.remove(CLASS_NAME_SHOW$6);\n        this._element.classList.remove(CLASS_NAME_SHOW$6);\n        this._element.setAttribute('aria-expanded', 'false');\n        Manipulator.removeDataAttribute(this._menu, 'popper');\n        EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);\n      }\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        config = _get(_getPrototypeOf(Dropdown.prototype), \"_getConfig\", this).call(this, config);\n        if (_typeof(config.reference) === 'object' && !isElement$1(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {\n          // Popper virtual elements require a getBoundingClientRect method\n          throw new TypeError(\"\".concat(NAME$a.toUpperCase(), \": Option \\\"reference\\\" provided type \\\"object\\\" without a required \\\"getBoundingClientRect\\\" method.\"));\n        }\n        return config;\n      }\n    }, {\n      key: \"_createPopper\",\n      value: function _createPopper() {\n        if (typeof Popper === 'undefined') {\n          throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org)');\n        }\n        var referenceElement = this._element;\n        if (this._config.reference === 'parent') {\n          referenceElement = this._parent;\n        } else if (isElement$1(this._config.reference)) {\n          referenceElement = getElement(this._config.reference);\n        } else if (_typeof(this._config.reference) === 'object') {\n          referenceElement = this._config.reference;\n        }\n        var popperConfig = this._getPopperConfig();\n        this._popper = createPopper(referenceElement, this._menu, popperConfig);\n      }\n    }, {\n      key: \"_isShown\",\n      value: function _isShown() {\n        return this._menu.classList.contains(CLASS_NAME_SHOW$6);\n      }\n    }, {\n      key: \"_getPlacement\",\n      value: function _getPlacement() {\n        var parentDropdown = this._parent;\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\n          return PLACEMENT_RIGHT;\n        }\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\n          return PLACEMENT_LEFT;\n        }\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {\n          return PLACEMENT_TOPCENTER;\n        }\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {\n          return PLACEMENT_BOTTOMCENTER;\n        } // We need to trim the value because custom properties can also include spaces\n\n        var isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\n          return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n        }\n        return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\n      }\n    }, {\n      key: \"_detectNavbar\",\n      value: function _detectNavbar() {\n        return this._element.closest(SELECTOR_NAVBAR) !== null;\n      }\n    }, {\n      key: \"_getOffset\",\n      value: function _getOffset() {\n        var _this16 = this;\n        var offset = this._config.offset;\n        if (typeof offset === 'string') {\n          return offset.split(',').map(function (value) {\n            return Number.parseInt(value, 10);\n          });\n        }\n        if (typeof offset === 'function') {\n          return function (popperData) {\n            return offset(popperData, _this16._element);\n          };\n        }\n        return offset;\n      }\n    }, {\n      key: \"_getPopperConfig\",\n      value: function _getPopperConfig() {\n        var defaultBsPopperConfig = {\n          placement: this._getPlacement(),\n          modifiers: [{\n            name: 'preventOverflow',\n            options: {\n              boundary: this._config.boundary\n            }\n          }, {\n            name: 'offset',\n            options: {\n              offset: this._getOffset()\n            }\n          }]\n        }; // Disable Popper if we have a static display or Dropdown is in Navbar\n\n        if (this._inNavbar || this._config.display === 'static') {\n          Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // todo:v6 remove\n\n          defaultBsPopperConfig.modifiers = [{\n            name: 'applyStyles',\n            enabled: false\n          }];\n        }\n        return _objectSpread(_objectSpread({}, defaultBsPopperConfig), typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig);\n      }\n    }, {\n      key: \"_selectMenuItem\",\n      value: function _selectMenuItem(_ref11) {\n        var key = _ref11.key,\n          target = _ref11.target;\n        var items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(function (element) {\n          return isVisible(element);\n        });\n        if (!items.length) {\n          return;\n        } // if target isn't included in items (e.g. when expanding the dropdown)\n        // allow cycling to get the last item in case key equals ARROW_UP_KEY\n\n        getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$9;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$9;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$a;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Dropdown.getOrCreateInstance(this, config);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        });\n      }\n    }, {\n      key: \"clearMenus\",\n      value: function clearMenus(event) {\n        if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {\n          return;\n        }\n        var openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);\n        var _iterator15 = _createForOfIteratorHelper(openToggles),\n          _step15;\n        try {\n          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n            var toggle = _step15.value;\n            var context = Dropdown.getInstance(toggle);\n            if (!context || context._config.autoClose === false) {\n              continue;\n            }\n            var composedPath = event.composedPath();\n            var isMenuTarget = composedPath.includes(context._menu);\n            if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {\n              continue;\n            } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\n\n            if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {\n              continue;\n            }\n            var relatedTarget = {\n              relatedTarget: context._element\n            };\n            if (event.type === 'click') {\n              relatedTarget.clickEvent = event;\n            }\n            context._completeHide(relatedTarget);\n          }\n        } catch (err) {\n          _iterator15.e(err);\n        } finally {\n          _iterator15.f();\n        }\n      }\n    }, {\n      key: \"dataApiKeydownHandler\",\n      value: function dataApiKeydownHandler(event) {\n        // If not an UP | DOWN | ESCAPE key => not a dropdown command\n        // If input/textarea && if key is other than ESCAPE => not a dropdown command\n        var isInput = /input|textarea/i.test(event.target.tagName);\n        var isEscapeEvent = event.key === ESCAPE_KEY$2;\n        var isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);\n        if (!isUpOrDownEvent && !isEscapeEvent) {\n          return;\n        }\n        if (isInput && !isEscapeEvent) {\n          return;\n        }\n        event.preventDefault(); // todo: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.2/forms/input-group/\n\n        var getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);\n        var instance = Dropdown.getOrCreateInstance(getToggleButton);\n        if (isUpOrDownEvent) {\n          event.stopPropagation();\n          instance.show();\n          instance._selectMenuItem(event);\n          return;\n        }\n        if (instance._isShown()) {\n          // else is escape and we check if it is shown\n          event.stopPropagation();\n          instance.hide();\n          getToggleButton.focus();\n        }\n      }\n    }]);\n    return Dropdown;\n  }(BaseComponent);\n  /**\r\n   * Data API implementation\r\n   */\n  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);\n  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\n  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);\n  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\n  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {\n    event.preventDefault();\n    Dropdown.getOrCreateInstance(this).toggle();\n  });\n  /**\r\n   * jQuery\r\n   */\n\n  defineJQueryPlugin(Dropdown);\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): util/scrollBar.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n\n  var SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\n  var SELECTOR_STICKY_CONTENT = '.sticky-top';\n  var PROPERTY_PADDING = 'padding-right';\n  var PROPERTY_MARGIN = 'margin-right';\n  /**\r\n   * Class definition\r\n   */\n  var ScrollBarHelper = /*#__PURE__*/function () {\n    function ScrollBarHelper() {\n      _classCallCheck(this, ScrollBarHelper);\n      this._element = document.body;\n    } // Public\n    _createClass(ScrollBarHelper, [{\n      key: \"getWidth\",\n      value: function getWidth() {\n        // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n        var documentWidth = document.documentElement.clientWidth;\n        return Math.abs(window.innerWidth - documentWidth);\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var width = this.getWidth();\n        this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width\n\n        this._setElementAttributes(this._element, PROPERTY_PADDING, function (calculatedValue) {\n          return calculatedValue + width;\n        }); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\n\n        this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, function (calculatedValue) {\n          return calculatedValue + width;\n        });\n        this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, function (calculatedValue) {\n          return calculatedValue - width;\n        });\n      }\n    }, {\n      key: \"reset\",\n      value: function reset() {\n        this._resetElementAttributes(this._element, 'overflow');\n        this._resetElementAttributes(this._element, PROPERTY_PADDING);\n        this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);\n        this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);\n      }\n    }, {\n      key: \"isOverflowing\",\n      value: function isOverflowing() {\n        return this.getWidth() > 0;\n      } // Private\n    }, {\n      key: \"_disableOverFlow\",\n      value: function _disableOverFlow() {\n        this._saveInitialAttribute(this._element, 'overflow');\n        this._element.style.overflow = 'hidden';\n      }\n    }, {\n      key: \"_setElementAttributes\",\n      value: function _setElementAttributes(selector, styleProperty, callback) {\n        var _this17 = this;\n        var scrollbarWidth = this.getWidth();\n        var manipulationCallBack = function manipulationCallBack(element) {\n          if (element !== _this17._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\n            return;\n          }\n          _this17._saveInitialAttribute(element, styleProperty);\n          var calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);\n          element.style.setProperty(styleProperty, \"\".concat(callback(Number.parseFloat(calculatedValue)), \"px\"));\n        };\n        this._applyManipulationCallback(selector, manipulationCallBack);\n      }\n    }, {\n      key: \"_saveInitialAttribute\",\n      value: function _saveInitialAttribute(element, styleProperty) {\n        var actualValue = element.style.getPropertyValue(styleProperty);\n        if (actualValue) {\n          Manipulator.setDataAttribute(element, styleProperty, actualValue);\n        }\n      }\n    }, {\n      key: \"_resetElementAttributes\",\n      value: function _resetElementAttributes(selector, styleProperty) {\n        var manipulationCallBack = function manipulationCallBack(element) {\n          var value = Manipulator.getDataAttribute(element, styleProperty); // We only want to remove the property if the value is `null`; the value can also be zero\n\n          if (value === null) {\n            element.style.removeProperty(styleProperty);\n            return;\n          }\n          Manipulator.removeDataAttribute(element, styleProperty);\n          element.style.setProperty(styleProperty, value);\n        };\n        this._applyManipulationCallback(selector, manipulationCallBack);\n      }\n    }, {\n      key: \"_applyManipulationCallback\",\n      value: function _applyManipulationCallback(selector, callBack) {\n        if (isElement$1(selector)) {\n          callBack(selector);\n          return;\n        }\n        var _iterator16 = _createForOfIteratorHelper(SelectorEngine.find(selector, this._element)),\n          _step16;\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var sel = _step16.value;\n            callBack(sel);\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      }\n    }]);\n    return ScrollBarHelper;\n  }();\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): util/backdrop.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n  var NAME$9 = 'backdrop';\n  var CLASS_NAME_FADE$4 = 'fade';\n  var CLASS_NAME_SHOW$5 = 'show';\n  var EVENT_MOUSEDOWN = \"mousedown.bs.\".concat(NAME$9);\n  var Default$8 = {\n    className: 'modal-backdrop',\n    clickCallback: null,\n    isAnimated: false,\n    isVisible: true,\n    // if false, we use the backdrop helper without adding any element to the dom\n    rootElement: 'body' // give the choice to place backdrop under different elements\n  };\n\n  var DefaultType$8 = {\n    className: 'string',\n    clickCallback: '(function|null)',\n    isAnimated: 'boolean',\n    isVisible: 'boolean',\n    rootElement: '(element|string)'\n  };\n  /**\r\n   * Class definition\r\n   */\n  var Backdrop = /*#__PURE__*/function (_Config3) {\n    _inherits(Backdrop, _Config3);\n    var _super8 = _createSuper(Backdrop);\n    function Backdrop(config) {\n      var _this18;\n      _classCallCheck(this, Backdrop);\n      _this18 = _super8.call(this);\n      _this18._config = _this18._getConfig(config);\n      _this18._isAppended = false;\n      _this18._element = null;\n      return _this18;\n    } // Getters\n    _createClass(Backdrop, [{\n      key: \"show\",\n      value:\n      // Public\n\n      function show(callback) {\n        if (!this._config.isVisible) {\n          execute(callback);\n          return;\n        }\n        this._append();\n        var element = this._getElement();\n        if (this._config.isAnimated) {\n          reflow(element);\n        }\n        element.classList.add(CLASS_NAME_SHOW$5);\n        this._emulateAnimation(function () {\n          execute(callback);\n        });\n      }\n    }, {\n      key: \"hide\",\n      value: function hide(callback) {\n        var _this19 = this;\n        if (!this._config.isVisible) {\n          execute(callback);\n          return;\n        }\n        this._getElement().classList.remove(CLASS_NAME_SHOW$5);\n        this._emulateAnimation(function () {\n          _this19.dispose();\n          execute(callback);\n        });\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        if (!this._isAppended) {\n          return;\n        }\n        EventHandler.off(this._element, EVENT_MOUSEDOWN);\n        this._element.remove();\n        this._isAppended = false;\n      } // Private\n    }, {\n      key: \"_getElement\",\n      value: function _getElement() {\n        if (!this._element) {\n          var backdrop = document.createElement('div');\n          backdrop.className = this._config.className;\n          if (this._config.isAnimated) {\n            backdrop.classList.add(CLASS_NAME_FADE$4);\n          }\n          this._element = backdrop;\n        }\n        return this._element;\n      }\n    }, {\n      key: \"_configAfterMerge\",\n      value: function _configAfterMerge(config) {\n        // use getElement() with the default \"body\" to get a fresh Element on each instantiation\n        config.rootElement = getElement(config.rootElement);\n        return config;\n      }\n    }, {\n      key: \"_append\",\n      value: function _append() {\n        var _this20 = this;\n        if (this._isAppended) {\n          return;\n        }\n        var element = this._getElement();\n        this._config.rootElement.append(element);\n        EventHandler.on(element, EVENT_MOUSEDOWN, function () {\n          execute(_this20._config.clickCallback);\n        });\n        this._isAppended = true;\n      }\n    }, {\n      key: \"_emulateAnimation\",\n      value: function _emulateAnimation(callback) {\n        executeAfterTransition(callback, this._getElement(), this._config.isAnimated);\n      }\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$8;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$8;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$9;\n      }\n    }]);\n    return Backdrop;\n  }(Config);\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): util/focustrap.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n  var NAME$8 = 'focustrap';\n  var DATA_KEY$5 = 'bs.focustrap';\n  var EVENT_KEY$5 = \".\".concat(DATA_KEY$5);\n  var EVENT_FOCUSIN$2 = \"focusin\".concat(EVENT_KEY$5);\n  var EVENT_KEYDOWN_TAB = \"keydown.tab\".concat(EVENT_KEY$5);\n  var TAB_KEY = 'Tab';\n  var TAB_NAV_FORWARD = 'forward';\n  var TAB_NAV_BACKWARD = 'backward';\n  var Default$7 = {\n    autofocus: true,\n    trapElement: null // The element to trap focus inside of\n  };\n\n  var DefaultType$7 = {\n    autofocus: 'boolean',\n    trapElement: 'element'\n  };\n  /**\r\n   * Class definition\r\n   */\n  var FocusTrap = /*#__PURE__*/function (_Config4) {\n    _inherits(FocusTrap, _Config4);\n    var _super9 = _createSuper(FocusTrap);\n    function FocusTrap(config) {\n      var _this21;\n      _classCallCheck(this, FocusTrap);\n      _this21 = _super9.call(this);\n      _this21._config = _this21._getConfig(config);\n      _this21._isActive = false;\n      _this21._lastTabNavDirection = null;\n      return _this21;\n    } // Getters\n    _createClass(FocusTrap, [{\n      key: \"activate\",\n      value:\n      // Public\n\n      function activate() {\n        var _this22 = this;\n        if (this._isActive) {\n          return;\n        }\n        if (this._config.autofocus) {\n          this._config.trapElement.focus();\n        }\n        EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop\n\n        EventHandler.on(document, EVENT_FOCUSIN$2, function (event) {\n          return _this22._handleFocusin(event);\n        });\n        EventHandler.on(document, EVENT_KEYDOWN_TAB, function (event) {\n          return _this22._handleKeydown(event);\n        });\n        this._isActive = true;\n      }\n    }, {\n      key: \"deactivate\",\n      value: function deactivate() {\n        if (!this._isActive) {\n          return;\n        }\n        this._isActive = false;\n        EventHandler.off(document, EVENT_KEY$5);\n      } // Private\n    }, {\n      key: \"_handleFocusin\",\n      value: function _handleFocusin(event) {\n        var trapElement = this._config.trapElement;\n        if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {\n          return;\n        }\n        var elements = SelectorEngine.focusableChildren(trapElement);\n        if (elements.length === 0) {\n          trapElement.focus();\n        } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {\n          elements[elements.length - 1].focus();\n        } else {\n          elements[0].focus();\n        }\n      }\n    }, {\n      key: \"_handleKeydown\",\n      value: function _handleKeydown(event) {\n        if (event.key !== TAB_KEY) {\n          return;\n        }\n        this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;\n      }\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$7;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$7;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$8;\n      }\n    }]);\n    return FocusTrap;\n  }(Config);\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): modal.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n  var NAME$7 = 'modal';\n  var DATA_KEY$4 = 'bs.modal';\n  var EVENT_KEY$4 = \".\".concat(DATA_KEY$4);\n  var DATA_API_KEY$2 = '.data-api';\n  var ESCAPE_KEY$1 = 'Escape';\n  var EVENT_HIDE$4 = \"hide\".concat(EVENT_KEY$4);\n  var EVENT_HIDE_PREVENTED$1 = \"hidePrevented\".concat(EVENT_KEY$4);\n  var EVENT_HIDDEN$4 = \"hidden\".concat(EVENT_KEY$4);\n  var EVENT_SHOW$4 = \"show\".concat(EVENT_KEY$4);\n  var EVENT_SHOWN$4 = \"shown\".concat(EVENT_KEY$4);\n  var EVENT_RESIZE$1 = \"resize\".concat(EVENT_KEY$4);\n  var EVENT_CLICK_DISMISS = \"click.dismiss\".concat(EVENT_KEY$4);\n  var EVENT_MOUSEDOWN_DISMISS = \"mousedown.dismiss\".concat(EVENT_KEY$4);\n  var EVENT_KEYDOWN_DISMISS$1 = \"keydown.dismiss\".concat(EVENT_KEY$4);\n  var EVENT_CLICK_DATA_API$2 = \"click\".concat(EVENT_KEY$4).concat(DATA_API_KEY$2);\n  var CLASS_NAME_OPEN = 'modal-open';\n  var CLASS_NAME_FADE$3 = 'fade';\n  var CLASS_NAME_SHOW$4 = 'show';\n  var CLASS_NAME_STATIC = 'modal-static';\n  var OPEN_SELECTOR$1 = '.modal.show';\n  var SELECTOR_DIALOG = '.modal-dialog';\n  var SELECTOR_MODAL_BODY = '.modal-body';\n  var SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\"modal\"]';\n  var Default$6 = {\n    backdrop: true,\n    focus: true,\n    keyboard: true\n  };\n  var DefaultType$6 = {\n    backdrop: '(boolean|string)',\n    focus: 'boolean',\n    keyboard: 'boolean'\n  };\n  /**\r\n   * Class definition\r\n   */\n  var Modal = /*#__PURE__*/function (_BaseComponent6) {\n    _inherits(Modal, _BaseComponent6);\n    var _super10 = _createSuper(Modal);\n    function Modal(element, config) {\n      var _this23;\n      _classCallCheck(this, Modal);\n      _this23 = _super10.call(this, element, config);\n      _this23._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, _this23._element);\n      _this23._backdrop = _this23._initializeBackDrop();\n      _this23._focustrap = _this23._initializeFocusTrap();\n      _this23._isShown = false;\n      _this23._isTransitioning = false;\n      _this23._scrollBar = new ScrollBarHelper();\n      _this23._addEventListeners();\n      return _this23;\n    } // Getters\n    _createClass(Modal, [{\n      key: \"toggle\",\n      value:\n      // Public\n\n      function toggle(relatedTarget) {\n        return this._isShown ? this.hide() : this.show(relatedTarget);\n      }\n    }, {\n      key: \"show\",\n      value: function show(relatedTarget) {\n        var _this24 = this;\n        if (this._isShown || this._isTransitioning) {\n          return;\n        }\n        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {\n          relatedTarget: relatedTarget\n        });\n        if (showEvent.defaultPrevented) {\n          return;\n        }\n        this._isShown = true;\n        this._isTransitioning = true;\n        this._scrollBar.hide();\n        document.body.classList.add(CLASS_NAME_OPEN);\n        this._adjustDialog();\n        this._backdrop.show(function () {\n          return _this24._showElement(relatedTarget);\n        });\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var _this25 = this;\n        if (!this._isShown || this._isTransitioning) {\n          return;\n        }\n        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);\n        if (hideEvent.defaultPrevented) {\n          return;\n        }\n        this._isShown = false;\n        this._isTransitioning = true;\n        this._focustrap.deactivate();\n        this._element.classList.remove(CLASS_NAME_SHOW$4);\n        this._queueCallback(function () {\n          return _this25._hideModal();\n        }, this._element, this._isAnimated());\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        for (var _i7 = 0, _arr2 = [window, this._dialog]; _i7 < _arr2.length; _i7++) {\n          var htmlElement = _arr2[_i7];\n          EventHandler.off(htmlElement, EVENT_KEY$4);\n        }\n        this._backdrop.dispose();\n        this._focustrap.deactivate();\n        _get(_getPrototypeOf(Modal.prototype), \"dispose\", this).call(this);\n      }\n    }, {\n      key: \"handleUpdate\",\n      value: function handleUpdate() {\n        this._adjustDialog();\n      } // Private\n    }, {\n      key: \"_initializeBackDrop\",\n      value: function _initializeBackDrop() {\n        return new Backdrop({\n          isVisible: Boolean(this._config.backdrop),\n          // 'static' option will be translated to true, and booleans will keep their value,\n          isAnimated: this._isAnimated()\n        });\n      }\n    }, {\n      key: \"_initializeFocusTrap\",\n      value: function _initializeFocusTrap() {\n        return new FocusTrap({\n          trapElement: this._element\n        });\n      }\n    }, {\n      key: \"_showElement\",\n      value: function _showElement(relatedTarget) {\n        var _this26 = this;\n        // try to append dynamic modal\n        if (!document.body.contains(this._element)) {\n          document.body.append(this._element);\n        }\n        this._element.style.display = 'block';\n        this._element.removeAttribute('aria-hidden');\n        this._element.setAttribute('aria-modal', true);\n        this._element.setAttribute('role', 'dialog');\n        this._element.scrollTop = 0;\n        var modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\n        if (modalBody) {\n          modalBody.scrollTop = 0;\n        }\n        reflow(this._element);\n        this._element.classList.add(CLASS_NAME_SHOW$4);\n        var transitionComplete = function transitionComplete() {\n          if (_this26._config.focus) {\n            _this26._focustrap.activate();\n          }\n          _this26._isTransitioning = false;\n          EventHandler.trigger(_this26._element, EVENT_SHOWN$4, {\n            relatedTarget: relatedTarget\n          });\n        };\n        this._queueCallback(transitionComplete, this._dialog, this._isAnimated());\n      }\n    }, {\n      key: \"_addEventListeners\",\n      value: function _addEventListeners() {\n        var _this27 = this;\n        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, function (event) {\n          if (event.key !== ESCAPE_KEY$1) {\n            return;\n          }\n          if (_this27._config.keyboard) {\n            event.preventDefault();\n            _this27.hide();\n            return;\n          }\n          _this27._triggerBackdropTransition();\n        });\n        EventHandler.on(window, EVENT_RESIZE$1, function () {\n          if (_this27._isShown && !_this27._isTransitioning) {\n            _this27._adjustDialog();\n          }\n        });\n        EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, function (event) {\n          // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks\n          EventHandler.one(_this27._element, EVENT_CLICK_DISMISS, function (event2) {\n            if (_this27._element !== event.target || _this27._element !== event2.target) {\n              return;\n            }\n            if (_this27._config.backdrop === 'static') {\n              _this27._triggerBackdropTransition();\n              return;\n            }\n            if (_this27._config.backdrop) {\n              _this27.hide();\n            }\n          });\n        });\n      }\n    }, {\n      key: \"_hideModal\",\n      value: function _hideModal() {\n        var _this28 = this;\n        this._element.style.display = 'none';\n        this._element.setAttribute('aria-hidden', true);\n        this._element.removeAttribute('aria-modal');\n        this._element.removeAttribute('role');\n        this._isTransitioning = false;\n        this._backdrop.hide(function () {\n          document.body.classList.remove(CLASS_NAME_OPEN);\n          _this28._resetAdjustments();\n          _this28._scrollBar.reset();\n          EventHandler.trigger(_this28._element, EVENT_HIDDEN$4);\n        });\n      }\n    }, {\n      key: \"_isAnimated\",\n      value: function _isAnimated() {\n        return this._element.classList.contains(CLASS_NAME_FADE$3);\n      }\n    }, {\n      key: \"_triggerBackdropTransition\",\n      value: function _triggerBackdropTransition() {\n        var _this29 = this;\n        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);\n        if (hideEvent.defaultPrevented) {\n          return;\n        }\n        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n        var initialOverflowY = this._element.style.overflowY; // return if the following background transition hasn't yet completed\n\n        if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {\n          return;\n        }\n        if (!isModalOverflowing) {\n          this._element.style.overflowY = 'hidden';\n        }\n        this._element.classList.add(CLASS_NAME_STATIC);\n        this._queueCallback(function () {\n          _this29._element.classList.remove(CLASS_NAME_STATIC);\n          _this29._queueCallback(function () {\n            _this29._element.style.overflowY = initialOverflowY;\n          }, _this29._dialog);\n        }, this._dialog);\n        this._element.focus();\n      }\n      /**\r\n       * The following methods are used to handle overflowing modals\r\n       */\n    }, {\n      key: \"_adjustDialog\",\n      value: function _adjustDialog() {\n        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n        var scrollbarWidth = this._scrollBar.getWidth();\n        var isBodyOverflowing = scrollbarWidth > 0;\n        if (isBodyOverflowing && !isModalOverflowing) {\n          var property = isRTL() ? 'paddingLeft' : 'paddingRight';\n          this._element.style[property] = \"\".concat(scrollbarWidth, \"px\");\n        }\n        if (!isBodyOverflowing && isModalOverflowing) {\n          var _property = isRTL() ? 'paddingRight' : 'paddingLeft';\n          this._element.style[_property] = \"\".concat(scrollbarWidth, \"px\");\n        }\n      }\n    }, {\n      key: \"_resetAdjustments\",\n      value: function _resetAdjustments() {\n        this._element.style.paddingLeft = '';\n        this._element.style.paddingRight = '';\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$6;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$6;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$7;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config, relatedTarget) {\n        return this.each(function () {\n          var data = Modal.getOrCreateInstance(this, config);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config](relatedTarget);\n        });\n      }\n    }]);\n    return Modal;\n  }(BaseComponent);\n  /**\r\n   * Data API implementation\r\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {\n    var _this30 = this;\n    var target = getElementFromSelector(this);\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n    EventHandler.one(target, EVENT_SHOW$4, function (showEvent) {\n      if (showEvent.defaultPrevented) {\n        // only register focus restorer if modal will actually get shown\n        return;\n      }\n      EventHandler.one(target, EVENT_HIDDEN$4, function () {\n        if (isVisible(_this30)) {\n          _this30.focus();\n        }\n      });\n    }); // avoid conflict when clicking modal toggler while another one is open\n\n    var alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);\n    if (alreadyOpen) {\n      Modal.getInstance(alreadyOpen).hide();\n    }\n    var data = Modal.getOrCreateInstance(target);\n    data.toggle(this);\n  });\n  enableDismissTrigger(Modal);\n  /**\r\n   * jQuery\r\n   */\n\n  defineJQueryPlugin(Modal);\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): offcanvas.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n\n  var NAME$6 = 'offcanvas';\n  var DATA_KEY$3 = 'bs.offcanvas';\n  var EVENT_KEY$3 = \".\".concat(DATA_KEY$3);\n  var DATA_API_KEY$1 = '.data-api';\n  var EVENT_LOAD_DATA_API$2 = \"load\".concat(EVENT_KEY$3).concat(DATA_API_KEY$1);\n  var ESCAPE_KEY = 'Escape';\n  var CLASS_NAME_SHOW$3 = 'show';\n  var CLASS_NAME_SHOWING$1 = 'showing';\n  var CLASS_NAME_HIDING = 'hiding';\n  var CLASS_NAME_BACKDROP = 'offcanvas-backdrop';\n  var OPEN_SELECTOR = '.offcanvas.show';\n  var EVENT_SHOW$3 = \"show\".concat(EVENT_KEY$3);\n  var EVENT_SHOWN$3 = \"shown\".concat(EVENT_KEY$3);\n  var EVENT_HIDE$3 = \"hide\".concat(EVENT_KEY$3);\n  var EVENT_HIDE_PREVENTED = \"hidePrevented\".concat(EVENT_KEY$3);\n  var EVENT_HIDDEN$3 = \"hidden\".concat(EVENT_KEY$3);\n  var EVENT_RESIZE = \"resize\".concat(EVENT_KEY$3);\n  var EVENT_CLICK_DATA_API$1 = \"click\".concat(EVENT_KEY$3).concat(DATA_API_KEY$1);\n  var EVENT_KEYDOWN_DISMISS = \"keydown.dismiss\".concat(EVENT_KEY$3);\n  var SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\"offcanvas\"]';\n  var Default$5 = {\n    backdrop: true,\n    keyboard: true,\n    scroll: false\n  };\n  var DefaultType$5 = {\n    backdrop: '(boolean|string)',\n    keyboard: 'boolean',\n    scroll: 'boolean'\n  };\n  /**\r\n   * Class definition\r\n   */\n  var Offcanvas = /*#__PURE__*/function (_BaseComponent7) {\n    _inherits(Offcanvas, _BaseComponent7);\n    var _super11 = _createSuper(Offcanvas);\n    function Offcanvas(element, config) {\n      var _this31;\n      _classCallCheck(this, Offcanvas);\n      _this31 = _super11.call(this, element, config);\n      _this31._isShown = false;\n      _this31._backdrop = _this31._initializeBackDrop();\n      _this31._focustrap = _this31._initializeFocusTrap();\n      _this31._addEventListeners();\n      return _this31;\n    } // Getters\n    _createClass(Offcanvas, [{\n      key: \"toggle\",\n      value:\n      // Public\n\n      function toggle(relatedTarget) {\n        return this._isShown ? this.hide() : this.show(relatedTarget);\n      }\n    }, {\n      key: \"show\",\n      value: function show(relatedTarget) {\n        var _this32 = this;\n        if (this._isShown) {\n          return;\n        }\n        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\n          relatedTarget: relatedTarget\n        });\n        if (showEvent.defaultPrevented) {\n          return;\n        }\n        this._isShown = true;\n        this._backdrop.show();\n        if (!this._config.scroll) {\n          new ScrollBarHelper().hide();\n        }\n        this._element.setAttribute('aria-modal', true);\n        this._element.setAttribute('role', 'dialog');\n        this._element.classList.add(CLASS_NAME_SHOWING$1);\n        var completeCallBack = function completeCallBack() {\n          if (!_this32._config.scroll || _this32._config.backdrop) {\n            _this32._focustrap.activate();\n          }\n          _this32._element.classList.add(CLASS_NAME_SHOW$3);\n          _this32._element.classList.remove(CLASS_NAME_SHOWING$1);\n          EventHandler.trigger(_this32._element, EVENT_SHOWN$3, {\n            relatedTarget: relatedTarget\n          });\n        };\n        this._queueCallback(completeCallBack, this._element, true);\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var _this33 = this;\n        if (!this._isShown) {\n          return;\n        }\n        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\n        if (hideEvent.defaultPrevented) {\n          return;\n        }\n        this._focustrap.deactivate();\n        this._element.blur();\n        this._isShown = false;\n        this._element.classList.add(CLASS_NAME_HIDING);\n        this._backdrop.hide();\n        var completeCallback = function completeCallback() {\n          _this33._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);\n          _this33._element.removeAttribute('aria-modal');\n          _this33._element.removeAttribute('role');\n          if (!_this33._config.scroll) {\n            new ScrollBarHelper().reset();\n          }\n          EventHandler.trigger(_this33._element, EVENT_HIDDEN$3);\n        };\n        this._queueCallback(completeCallback, this._element, true);\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        this._backdrop.dispose();\n        this._focustrap.deactivate();\n        _get(_getPrototypeOf(Offcanvas.prototype), \"dispose\", this).call(this);\n      } // Private\n    }, {\n      key: \"_initializeBackDrop\",\n      value: function _initializeBackDrop() {\n        var _this34 = this;\n        var clickCallback = function clickCallback() {\n          if (_this34._config.backdrop === 'static') {\n            EventHandler.trigger(_this34._element, EVENT_HIDE_PREVENTED);\n            return;\n          }\n          _this34.hide();\n        }; // 'static' option will be translated to true, and booleans will keep their value\n\n        var isVisible = Boolean(this._config.backdrop);\n        return new Backdrop({\n          className: CLASS_NAME_BACKDROP,\n          isVisible: isVisible,\n          isAnimated: true,\n          rootElement: this._element.parentNode,\n          clickCallback: isVisible ? clickCallback : null\n        });\n      }\n    }, {\n      key: \"_initializeFocusTrap\",\n      value: function _initializeFocusTrap() {\n        return new FocusTrap({\n          trapElement: this._element\n        });\n      }\n    }, {\n      key: \"_addEventListeners\",\n      value: function _addEventListeners() {\n        var _this35 = this;\n        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, function (event) {\n          if (event.key !== ESCAPE_KEY) {\n            return;\n          }\n          if (!_this35._config.keyboard) {\n            EventHandler.trigger(_this35._element, EVENT_HIDE_PREVENTED);\n            return;\n          }\n          _this35.hide();\n        });\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$5;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$5;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$6;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Offcanvas.getOrCreateInstance(this, config);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config](this);\n        });\n      }\n    }]);\n    return Offcanvas;\n  }(BaseComponent);\n  /**\r\n   * Data API implementation\r\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {\n    var _this36 = this;\n    var target = getElementFromSelector(this);\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n    if (isDisabled(this)) {\n      return;\n    }\n    EventHandler.one(target, EVENT_HIDDEN$3, function () {\n      // focus on trigger when it is closed\n      if (isVisible(_this36)) {\n        _this36.focus();\n      }\n    }); // avoid conflict when clicking a toggler of an offcanvas, while another is open\n\n    var alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);\n    if (alreadyOpen && alreadyOpen !== target) {\n      Offcanvas.getInstance(alreadyOpen).hide();\n    }\n    var data = Offcanvas.getOrCreateInstance(target);\n    data.toggle(this);\n  });\n  EventHandler.on(window, EVENT_LOAD_DATA_API$2, function () {\n    var _iterator17 = _createForOfIteratorHelper(SelectorEngine.find(OPEN_SELECTOR)),\n      _step17;\n    try {\n      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n        var selector = _step17.value;\n        Offcanvas.getOrCreateInstance(selector).show();\n      }\n    } catch (err) {\n      _iterator17.e(err);\n    } finally {\n      _iterator17.f();\n    }\n  });\n  EventHandler.on(window, EVENT_RESIZE, function () {\n    var _iterator18 = _createForOfIteratorHelper(SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')),\n      _step18;\n    try {\n      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n        var element = _step18.value;\n        if (getComputedStyle(element).position !== 'fixed') {\n          Offcanvas.getOrCreateInstance(element).hide();\n        }\n      }\n    } catch (err) {\n      _iterator18.e(err);\n    } finally {\n      _iterator18.f();\n    }\n  });\n  enableDismissTrigger(Offcanvas);\n  /**\r\n   * jQuery\r\n   */\n\n  defineJQueryPlugin(Offcanvas);\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): util/sanitizer.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  var uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);\n  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n  /**\r\n   * A pattern that recognizes a commonly useful subset of URLs that are safe.\r\n   *\r\n   * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\r\n   */\n\n  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;\n  /**\r\n   * A pattern that matches safe data URLs. Only matches image, video and audio types.\r\n   *\r\n   * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\r\n   */\n\n  var DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i;\n  var allowedAttribute = function allowedAttribute(attribute, allowedAttributeList) {\n    var attributeName = attribute.nodeName.toLowerCase();\n    if (allowedAttributeList.includes(attributeName)) {\n      if (uriAttributes.has(attributeName)) {\n        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));\n      }\n      return true;\n    } // Check if a regular expression validates the attribute.\n\n    return allowedAttributeList.filter(function (attributeRegex) {\n      return attributeRegex instanceof RegExp;\n    }).some(function (regex) {\n      return regex.test(attributeName);\n    });\n  };\n  var DefaultAllowlist = {\n    // Global attributes allowed on any supplied element below.\n    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n    a: ['target', 'href', 'title', 'rel'],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    div: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n  };\n  function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {\n    var _ref12;\n    if (!unsafeHtml.length) {\n      return unsafeHtml;\n    }\n    if (sanitizeFunction && typeof sanitizeFunction === 'function') {\n      return sanitizeFunction(unsafeHtml);\n    }\n    var domParser = new window.DOMParser();\n    var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\n    var elements = (_ref12 = []).concat.apply(_ref12, _toConsumableArray(createdDocument.body.querySelectorAll('*')));\n    var _iterator19 = _createForOfIteratorHelper(elements),\n      _step19;\n    try {\n      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n        var _ref13;\n        var element = _step19.value;\n        var elementName = element.nodeName.toLowerCase();\n        if (!Object.keys(allowList).includes(elementName)) {\n          element.remove();\n          continue;\n        }\n        var attributeList = (_ref13 = []).concat.apply(_ref13, _toConsumableArray(element.attributes));\n        var allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);\n        var _iterator20 = _createForOfIteratorHelper(attributeList),\n          _step20;\n        try {\n          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n            var attribute = _step20.value;\n            if (!allowedAttribute(attribute, allowedAttributes)) {\n              element.removeAttribute(attribute.nodeName);\n            }\n          }\n        } catch (err) {\n          _iterator20.e(err);\n        } finally {\n          _iterator20.f();\n        }\n      }\n    } catch (err) {\n      _iterator19.e(err);\n    } finally {\n      _iterator19.f();\n    }\n    return createdDocument.body.innerHTML;\n  }\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): util/template-factory.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n\n  var NAME$5 = 'TemplateFactory';\n  var Default$4 = {\n    allowList: DefaultAllowlist,\n    content: {},\n    // { selector : text ,  selector2 : text2 , }\n    extraClass: '',\n    html: false,\n    sanitize: true,\n    sanitizeFn: null,\n    template: '<div></div>'\n  };\n  var DefaultType$4 = {\n    allowList: 'object',\n    content: 'object',\n    extraClass: '(string|function)',\n    html: 'boolean',\n    sanitize: 'boolean',\n    sanitizeFn: '(null|function)',\n    template: 'string'\n  };\n  var DefaultContentType = {\n    entry: '(string|element|function|null)',\n    selector: '(string|element)'\n  };\n  /**\r\n   * Class definition\r\n   */\n  var TemplateFactory = /*#__PURE__*/function (_Config5) {\n    _inherits(TemplateFactory, _Config5);\n    var _super12 = _createSuper(TemplateFactory);\n    function TemplateFactory(config) {\n      var _this37;\n      _classCallCheck(this, TemplateFactory);\n      _this37 = _super12.call(this);\n      _this37._config = _this37._getConfig(config);\n      return _this37;\n    } // Getters\n    _createClass(TemplateFactory, [{\n      key: \"getContent\",\n      value:\n      // Public\n\n      function getContent() {\n        var _this38 = this;\n        return Object.values(this._config.content).map(function (config) {\n          return _this38._resolvePossibleFunction(config);\n        }).filter(Boolean);\n      }\n    }, {\n      key: \"hasContent\",\n      value: function hasContent() {\n        return this.getContent().length > 0;\n      }\n    }, {\n      key: \"changeContent\",\n      value: function changeContent(content) {\n        this._checkContent(content);\n        this._config.content = _objectSpread(_objectSpread({}, this._config.content), content);\n        return this;\n      }\n    }, {\n      key: \"toHtml\",\n      value: function toHtml() {\n        var templateWrapper = document.createElement('div');\n        templateWrapper.innerHTML = this._maybeSanitize(this._config.template);\n        for (var _i8 = 0, _Object$entries2 = Object.entries(this._config.content); _i8 < _Object$entries2.length; _i8++) {\n          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i8], 2),\n            selector = _Object$entries2$_i[0],\n            text = _Object$entries2$_i[1];\n          this._setContent(templateWrapper, text, selector);\n        }\n        var template = templateWrapper.children[0];\n        var extraClass = this._resolvePossibleFunction(this._config.extraClass);\n        if (extraClass) {\n          var _template$classList;\n          (_template$classList = template.classList).add.apply(_template$classList, _toConsumableArray(extraClass.split(' ')));\n        }\n        return template;\n      } // Private\n    }, {\n      key: \"_typeCheckConfig\",\n      value: function _typeCheckConfig(config) {\n        _get(_getPrototypeOf(TemplateFactory.prototype), \"_typeCheckConfig\", this).call(this, config);\n        this._checkContent(config.content);\n      }\n    }, {\n      key: \"_checkContent\",\n      value: function _checkContent(arg) {\n        for (var _i9 = 0, _Object$entries3 = Object.entries(arg); _i9 < _Object$entries3.length; _i9++) {\n          var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i9], 2),\n            selector = _Object$entries3$_i[0],\n            content = _Object$entries3$_i[1];\n          _get(_getPrototypeOf(TemplateFactory.prototype), \"_typeCheckConfig\", this).call(this, {\n            selector: selector,\n            entry: content\n          }, DefaultContentType);\n        }\n      }\n    }, {\n      key: \"_setContent\",\n      value: function _setContent(template, content, selector) {\n        var templateElement = SelectorEngine.findOne(selector, template);\n        if (!templateElement) {\n          return;\n        }\n        content = this._resolvePossibleFunction(content);\n        if (!content) {\n          templateElement.remove();\n          return;\n        }\n        if (isElement$1(content)) {\n          this._putElementInTemplate(getElement(content), templateElement);\n          return;\n        }\n        if (this._config.html) {\n          templateElement.innerHTML = this._maybeSanitize(content);\n          return;\n        }\n        templateElement.textContent = content;\n      }\n    }, {\n      key: \"_maybeSanitize\",\n      value: function _maybeSanitize(arg) {\n        return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;\n      }\n    }, {\n      key: \"_resolvePossibleFunction\",\n      value: function _resolvePossibleFunction(arg) {\n        return typeof arg === 'function' ? arg(this) : arg;\n      }\n    }, {\n      key: \"_putElementInTemplate\",\n      value: function _putElementInTemplate(element, templateElement) {\n        if (this._config.html) {\n          templateElement.innerHTML = '';\n          templateElement.append(element);\n          return;\n        }\n        templateElement.textContent = element.textContent;\n      }\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$4;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$4;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$5;\n      }\n    }]);\n    return TemplateFactory;\n  }(Config);\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): tooltip.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n  var NAME$4 = 'tooltip';\n  var DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);\n  var CLASS_NAME_FADE$2 = 'fade';\n  var CLASS_NAME_MODAL = 'modal';\n  var CLASS_NAME_SHOW$2 = 'show';\n  var SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\n  var SELECTOR_MODAL = \".\".concat(CLASS_NAME_MODAL);\n  var EVENT_MODAL_HIDE = 'hide.bs.modal';\n  var TRIGGER_HOVER = 'hover';\n  var TRIGGER_FOCUS = 'focus';\n  var TRIGGER_CLICK = 'click';\n  var TRIGGER_MANUAL = 'manual';\n  var EVENT_HIDE$2 = 'hide';\n  var EVENT_HIDDEN$2 = 'hidden';\n  var EVENT_SHOW$2 = 'show';\n  var EVENT_SHOWN$2 = 'shown';\n  var EVENT_INSERTED = 'inserted';\n  var EVENT_CLICK$1 = 'click';\n  var EVENT_FOCUSIN$1 = 'focusin';\n  var EVENT_FOCUSOUT$1 = 'focusout';\n  var EVENT_MOUSEENTER = 'mouseenter';\n  var EVENT_MOUSELEAVE = 'mouseleave';\n  var AttachmentMap = {\n    AUTO: 'auto',\n    TOP: 'top',\n    RIGHT: isRTL() ? 'left' : 'right',\n    BOTTOM: 'bottom',\n    LEFT: isRTL() ? 'right' : 'left'\n  };\n  var Default$3 = {\n    allowList: DefaultAllowlist,\n    animation: true,\n    boundary: 'clippingParents',\n    container: false,\n    customClass: '',\n    delay: 0,\n    fallbackPlacements: ['top', 'right', 'bottom', 'left'],\n    html: false,\n    offset: [0, 0],\n    placement: 'top',\n    popperConfig: null,\n    sanitize: true,\n    sanitizeFn: null,\n    selector: false,\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-arrow\"></div>' + '<div class=\"tooltip-inner\"></div>' + '</div>',\n    title: '',\n    trigger: 'hover focus'\n  };\n  var DefaultType$3 = {\n    allowList: 'object',\n    animation: 'boolean',\n    boundary: '(string|element)',\n    container: '(string|element|boolean)',\n    customClass: '(string|function)',\n    delay: '(number|object)',\n    fallbackPlacements: 'array',\n    html: 'boolean',\n    offset: '(array|string|function)',\n    placement: '(string|function)',\n    popperConfig: '(null|object|function)',\n    sanitize: 'boolean',\n    sanitizeFn: '(null|function)',\n    selector: '(string|boolean)',\n    template: 'string',\n    title: '(string|element|function)',\n    trigger: 'string'\n  };\n  /**\r\n   * Class definition\r\n   */\n  var Tooltip = /*#__PURE__*/function (_BaseComponent8) {\n    _inherits(Tooltip, _BaseComponent8);\n    var _super13 = _createSuper(Tooltip);\n    function Tooltip(element, config) {\n      var _this39;\n      _classCallCheck(this, Tooltip);\n      if (typeof Popper === 'undefined') {\n        throw new TypeError('Bootstrap\\'s tooltips require Popper (https://popper.js.org)');\n      }\n      _this39 = _super13.call(this, element, config); // Private\n\n      _this39._isEnabled = true;\n      _this39._timeout = 0;\n      _this39._isHovered = null;\n      _this39._activeTrigger = {};\n      _this39._popper = null;\n      _this39._templateFactory = null;\n      _this39._newContent = null; // Protected\n\n      _this39.tip = null;\n      _this39._setListeners();\n      if (!_this39._config.selector) {\n        _this39._fixTitle();\n      }\n      return _this39;\n    } // Getters\n    _createClass(Tooltip, [{\n      key: \"enable\",\n      value:\n      // Public\n\n      function enable() {\n        this._isEnabled = true;\n      }\n    }, {\n      key: \"disable\",\n      value: function disable() {\n        this._isEnabled = false;\n      }\n    }, {\n      key: \"toggleEnabled\",\n      value: function toggleEnabled() {\n        this._isEnabled = !this._isEnabled;\n      }\n    }, {\n      key: \"toggle\",\n      value: function toggle() {\n        if (!this._isEnabled) {\n          return;\n        }\n        this._activeTrigger.click = !this._activeTrigger.click;\n        if (this._isShown()) {\n          this._leave();\n          return;\n        }\n        this._enter();\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        clearTimeout(this._timeout);\n        EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n        if (this._element.getAttribute('data-bs-original-title')) {\n          this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title'));\n        }\n        this._disposePopper();\n        _get(_getPrototypeOf(Tooltip.prototype), \"dispose\", this).call(this);\n      }\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this40 = this;\n        if (this._element.style.display === 'none') {\n          throw new Error('Please use show on visible elements');\n        }\n        if (!(this._isWithContent() && this._isEnabled)) {\n          return;\n        }\n        var showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));\n        var shadowRoot = findShadowRoot(this._element);\n        var isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);\n        if (showEvent.defaultPrevented || !isInTheDom) {\n          return;\n        } // todo v6 remove this OR make it optional\n\n        this._disposePopper();\n        var tip = this._getTipElement();\n        this._element.setAttribute('aria-describedby', tip.getAttribute('id'));\n        var container = this._config.container;\n        if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\n          container.append(tip);\n          EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));\n        }\n        this._popper = this._createPopper(tip);\n        tip.classList.add(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n        if ('ontouchstart' in document.documentElement) {\n          var _ref14;\n          var _iterator21 = _createForOfIteratorHelper((_ref14 = []).concat.apply(_ref14, _toConsumableArray(document.body.children))),\n            _step21;\n          try {\n            for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n              var element = _step21.value;\n              EventHandler.on(element, 'mouseover', noop);\n            }\n          } catch (err) {\n            _iterator21.e(err);\n          } finally {\n            _iterator21.f();\n          }\n        }\n        var complete = function complete() {\n          EventHandler.trigger(_this40._element, _this40.constructor.eventName(EVENT_SHOWN$2));\n          if (_this40._isHovered === false) {\n            _this40._leave();\n          }\n          _this40._isHovered = false;\n        };\n        this._queueCallback(complete, this.tip, this._isAnimated());\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var _this41 = this;\n        if (!this._isShown()) {\n          return;\n        }\n        var hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));\n        if (hideEvent.defaultPrevented) {\n          return;\n        }\n        var tip = this._getTipElement();\n        tip.classList.remove(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n\n        if ('ontouchstart' in document.documentElement) {\n          var _ref15;\n          var _iterator22 = _createForOfIteratorHelper((_ref15 = []).concat.apply(_ref15, _toConsumableArray(document.body.children))),\n            _step22;\n          try {\n            for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n              var element = _step22.value;\n              EventHandler.off(element, 'mouseover', noop);\n            }\n          } catch (err) {\n            _iterator22.e(err);\n          } finally {\n            _iterator22.f();\n          }\n        }\n        this._activeTrigger[TRIGGER_CLICK] = false;\n        this._activeTrigger[TRIGGER_FOCUS] = false;\n        this._activeTrigger[TRIGGER_HOVER] = false;\n        this._isHovered = null; // it is a trick to support manual triggering\n\n        var complete = function complete() {\n          if (_this41._isWithActiveTrigger()) {\n            return;\n          }\n          if (!_this41._isHovered) {\n            _this41._disposePopper();\n          }\n          _this41._element.removeAttribute('aria-describedby');\n          EventHandler.trigger(_this41._element, _this41.constructor.eventName(EVENT_HIDDEN$2));\n        };\n        this._queueCallback(complete, this.tip, this._isAnimated());\n      }\n    }, {\n      key: \"update\",\n      value: function update() {\n        if (this._popper) {\n          this._popper.update();\n        }\n      } // Protected\n    }, {\n      key: \"_isWithContent\",\n      value: function _isWithContent() {\n        return Boolean(this._getTitle());\n      }\n    }, {\n      key: \"_getTipElement\",\n      value: function _getTipElement() {\n        if (!this.tip) {\n          this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());\n        }\n        return this.tip;\n      }\n    }, {\n      key: \"_createTipElement\",\n      value: function _createTipElement(content) {\n        var tip = this._getTemplateFactory(content).toHtml(); // todo: remove this check on v6\n\n        if (!tip) {\n          return null;\n        }\n        tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2); // todo: on v6 the following can be achieved with CSS only\n\n        tip.classList.add(\"bs-\".concat(this.constructor.NAME, \"-auto\"));\n        var tipId = getUID(this.constructor.NAME).toString();\n        tip.setAttribute('id', tipId);\n        if (this._isAnimated()) {\n          tip.classList.add(CLASS_NAME_FADE$2);\n        }\n        return tip;\n      }\n    }, {\n      key: \"setContent\",\n      value: function setContent(content) {\n        this._newContent = content;\n        if (this._isShown()) {\n          this._disposePopper();\n          this.show();\n        }\n      }\n    }, {\n      key: \"_getTemplateFactory\",\n      value: function _getTemplateFactory(content) {\n        if (this._templateFactory) {\n          this._templateFactory.changeContent(content);\n        } else {\n          this._templateFactory = new TemplateFactory(_objectSpread(_objectSpread({}, this._config), {}, {\n            // the `content` var has to be after `this._config`\n            // to override config.content in case of popover\n            content: content,\n            extraClass: this._resolvePossibleFunction(this._config.customClass)\n          }));\n        }\n        return this._templateFactory;\n      }\n    }, {\n      key: \"_getContentForTemplate\",\n      value: function _getContentForTemplate() {\n        return _defineProperty({}, SELECTOR_TOOLTIP_INNER, this._getTitle());\n      }\n    }, {\n      key: \"_getTitle\",\n      value: function _getTitle() {\n        return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title');\n      } // Private\n    }, {\n      key: \"_initializeOnDelegatedTarget\",\n      value: function _initializeOnDelegatedTarget(event) {\n        return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());\n      }\n    }, {\n      key: \"_isAnimated\",\n      value: function _isAnimated() {\n        return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);\n      }\n    }, {\n      key: \"_isShown\",\n      value: function _isShown() {\n        return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);\n      }\n    }, {\n      key: \"_createPopper\",\n      value: function _createPopper(tip) {\n        var placement = typeof this._config.placement === 'function' ? this._config.placement.call(this, tip, this._element) : this._config.placement;\n        var attachment = AttachmentMap[placement.toUpperCase()];\n        return createPopper(this._element, tip, this._getPopperConfig(attachment));\n      }\n    }, {\n      key: \"_getOffset\",\n      value: function _getOffset() {\n        var _this42 = this;\n        var offset = this._config.offset;\n        if (typeof offset === 'string') {\n          return offset.split(',').map(function (value) {\n            return Number.parseInt(value, 10);\n          });\n        }\n        if (typeof offset === 'function') {\n          return function (popperData) {\n            return offset(popperData, _this42._element);\n          };\n        }\n        return offset;\n      }\n    }, {\n      key: \"_resolvePossibleFunction\",\n      value: function _resolvePossibleFunction(arg) {\n        return typeof arg === 'function' ? arg.call(this._element) : arg;\n      }\n    }, {\n      key: \"_getPopperConfig\",\n      value: function _getPopperConfig(attachment) {\n        var _this43 = this;\n        var defaultBsPopperConfig = {\n          placement: attachment,\n          modifiers: [{\n            name: 'flip',\n            options: {\n              fallbackPlacements: this._config.fallbackPlacements\n            }\n          }, {\n            name: 'offset',\n            options: {\n              offset: this._getOffset()\n            }\n          }, {\n            name: 'preventOverflow',\n            options: {\n              boundary: this._config.boundary\n            }\n          }, {\n            name: 'arrow',\n            options: {\n              element: \".\".concat(this.constructor.NAME, \"-arrow\")\n            }\n          }, {\n            name: 'preSetPlacement',\n            enabled: true,\n            phase: 'beforeMain',\n            fn: function fn(data) {\n              // Pre-set Popper's placement attribute in order to read the arrow sizes properly.\n              // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement\n              _this43._getTipElement().setAttribute('data-popper-placement', data.state.placement);\n            }\n          }]\n        };\n        return _objectSpread(_objectSpread({}, defaultBsPopperConfig), typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig);\n      }\n    }, {\n      key: \"_setListeners\",\n      value: function _setListeners() {\n        var _this44 = this;\n        var triggers = this._config.trigger.split(' ');\n        var _iterator23 = _createForOfIteratorHelper(triggers),\n          _step23;\n        try {\n          for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n            var trigger = _step23.value;\n            if (trigger === 'click') {\n              EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, function (event) {\n                var context = _this44._initializeOnDelegatedTarget(event);\n                context.toggle();\n              });\n            } else if (trigger !== TRIGGER_MANUAL) {\n              var eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);\n              var eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);\n              EventHandler.on(this._element, eventIn, this._config.selector, function (event) {\n                var context = _this44._initializeOnDelegatedTarget(event);\n                context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n                context._enter();\n              });\n              EventHandler.on(this._element, eventOut, this._config.selector, function (event) {\n                var context = _this44._initializeOnDelegatedTarget(event);\n                context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\n                context._leave();\n              });\n            }\n          }\n        } catch (err) {\n          _iterator23.e(err);\n        } finally {\n          _iterator23.f();\n        }\n        this._hideModalHandler = function () {\n          if (_this44._element) {\n            _this44.hide();\n          }\n        };\n        EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n      }\n    }, {\n      key: \"_fixTitle\",\n      value: function _fixTitle() {\n        var title = this._element.getAttribute('title');\n        if (!title) {\n          return;\n        }\n        if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {\n          this._element.setAttribute('aria-label', title);\n        }\n        this._element.setAttribute('data-bs-original-title', title); // DO NOT USE IT. Is only for backwards compatibility\n\n        this._element.removeAttribute('title');\n      }\n    }, {\n      key: \"_enter\",\n      value: function _enter() {\n        var _this45 = this;\n        if (this._isShown() || this._isHovered) {\n          this._isHovered = true;\n          return;\n        }\n        this._isHovered = true;\n        this._setTimeout(function () {\n          if (_this45._isHovered) {\n            _this45.show();\n          }\n        }, this._config.delay.show);\n      }\n    }, {\n      key: \"_leave\",\n      value: function _leave() {\n        var _this46 = this;\n        if (this._isWithActiveTrigger()) {\n          return;\n        }\n        this._isHovered = false;\n        this._setTimeout(function () {\n          if (!_this46._isHovered) {\n            _this46.hide();\n          }\n        }, this._config.delay.hide);\n      }\n    }, {\n      key: \"_setTimeout\",\n      value: function _setTimeout(handler, timeout) {\n        clearTimeout(this._timeout);\n        this._timeout = setTimeout(handler, timeout);\n      }\n    }, {\n      key: \"_isWithActiveTrigger\",\n      value: function _isWithActiveTrigger() {\n        return Object.values(this._activeTrigger).includes(true);\n      }\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        var dataAttributes = Manipulator.getDataAttributes(this._element);\n        for (var _i10 = 0, _Object$keys5 = Object.keys(dataAttributes); _i10 < _Object$keys5.length; _i10++) {\n          var dataAttribute = _Object$keys5[_i10];\n          if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {\n            delete dataAttributes[dataAttribute];\n          }\n        }\n        config = _objectSpread(_objectSpread({}, dataAttributes), _typeof(config) === 'object' && config ? config : {});\n        config = this._mergeConfigObj(config);\n        config = this._configAfterMerge(config);\n        this._typeCheckConfig(config);\n        return config;\n      }\n    }, {\n      key: \"_configAfterMerge\",\n      value: function _configAfterMerge(config) {\n        config.container = config.container === false ? document.body : getElement(config.container);\n        if (typeof config.delay === 'number') {\n          config.delay = {\n            show: config.delay,\n            hide: config.delay\n          };\n        }\n        if (typeof config.title === 'number') {\n          config.title = config.title.toString();\n        }\n        if (typeof config.content === 'number') {\n          config.content = config.content.toString();\n        }\n        return config;\n      }\n    }, {\n      key: \"_getDelegateConfig\",\n      value: function _getDelegateConfig() {\n        var config = {};\n        for (var key in this._config) {\n          if (this.constructor.Default[key] !== this._config[key]) {\n            config[key] = this._config[key];\n          }\n        }\n        config.selector = false;\n        config.trigger = 'manual'; // In the future can be replaced with:\n        // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])\n        // `Object.fromEntries(keysWithDifferentValues)`\n\n        return config;\n      }\n    }, {\n      key: \"_disposePopper\",\n      value: function _disposePopper() {\n        if (this._popper) {\n          this._popper.destroy();\n          this._popper = null;\n        }\n        if (this.tip) {\n          this.tip.remove();\n          this.tip = null;\n        }\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$3;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$3;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$4;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Tooltip.getOrCreateInstance(this, config);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        });\n      }\n    }]);\n    return Tooltip;\n  }(BaseComponent);\n  /**\r\n   * jQuery\r\n   */\n  defineJQueryPlugin(Tooltip);\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): popover.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n\n  var NAME$3 = 'popover';\n  var SELECTOR_TITLE = '.popover-header';\n  var SELECTOR_CONTENT = '.popover-body';\n  var Default$2 = _objectSpread(_objectSpread({}, Tooltip.Default), {}, {\n    content: '',\n    offset: [0, 8],\n    placement: 'right',\n    template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"popover-arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div>' + '</div>',\n    trigger: 'click'\n  });\n  var DefaultType$2 = _objectSpread(_objectSpread({}, Tooltip.DefaultType), {}, {\n    content: '(null|string|element|function)'\n  });\n  /**\r\n   * Class definition\r\n   */\n  var Popover = /*#__PURE__*/function (_Tooltip) {\n    _inherits(Popover, _Tooltip);\n    var _super14 = _createSuper(Popover);\n    function Popover() {\n      _classCallCheck(this, Popover);\n      return _super14.apply(this, arguments);\n    }\n    _createClass(Popover, [{\n      key: \"_isWithContent\",\n      value:\n      // Overrides\n\n      function _isWithContent() {\n        return this._getTitle() || this._getContent();\n      } // Private\n    }, {\n      key: \"_getContentForTemplate\",\n      value: function _getContentForTemplate() {\n        var _ref17;\n        return _ref17 = {}, _defineProperty(_ref17, SELECTOR_TITLE, this._getTitle()), _defineProperty(_ref17, SELECTOR_CONTENT, this._getContent()), _ref17;\n      }\n    }, {\n      key: \"_getContent\",\n      value: function _getContent() {\n        return this._resolvePossibleFunction(this._config.content);\n      } // Static\n    }], [{\n      key: \"Default\",\n      get:\n      // Getters\n      function get() {\n        return Default$2;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$2;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$3;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Popover.getOrCreateInstance(this, config);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        });\n      }\n    }]);\n    return Popover;\n  }(Tooltip);\n  /**\r\n   * jQuery\r\n   */\n  defineJQueryPlugin(Popover);\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): scrollspy.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n\n  var NAME$2 = 'scrollspy';\n  var DATA_KEY$2 = 'bs.scrollspy';\n  var EVENT_KEY$2 = \".\".concat(DATA_KEY$2);\n  var DATA_API_KEY = '.data-api';\n  var EVENT_ACTIVATE = \"activate\".concat(EVENT_KEY$2);\n  var EVENT_CLICK = \"click\".concat(EVENT_KEY$2);\n  var EVENT_LOAD_DATA_API$1 = \"load\".concat(EVENT_KEY$2).concat(DATA_API_KEY);\n  var CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';\n  var CLASS_NAME_ACTIVE$1 = 'active';\n  var SELECTOR_DATA_SPY = '[data-bs-spy=\"scroll\"]';\n  var SELECTOR_TARGET_LINKS = '[href]';\n  var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\n  var SELECTOR_NAV_LINKS = '.nav-link';\n  var SELECTOR_NAV_ITEMS = '.nav-item';\n  var SELECTOR_LIST_ITEMS = '.list-group-item';\n  var SELECTOR_LINK_ITEMS = \"\".concat(SELECTOR_NAV_LINKS, \", \").concat(SELECTOR_NAV_ITEMS, \" > \").concat(SELECTOR_NAV_LINKS, \", \").concat(SELECTOR_LIST_ITEMS);\n  var SELECTOR_DROPDOWN = '.dropdown';\n  var SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';\n  var Default$1 = {\n    offset: null,\n    // TODO: v6 @deprecated, keep it for backwards compatibility reasons\n    rootMargin: '0px 0px -25%',\n    smoothScroll: false,\n    target: null,\n    threshold: [0.1, 0.5, 1]\n  };\n  var DefaultType$1 = {\n    offset: '(number|null)',\n    // TODO v6 @deprecated, keep it for backwards compatibility reasons\n    rootMargin: 'string',\n    smoothScroll: 'boolean',\n    target: 'element',\n    threshold: 'array'\n  };\n  /**\r\n   * Class definition\r\n   */\n  var ScrollSpy = /*#__PURE__*/function (_BaseComponent9) {\n    _inherits(ScrollSpy, _BaseComponent9);\n    var _super15 = _createSuper(ScrollSpy);\n    function ScrollSpy(element, config) {\n      var _this47;\n      _classCallCheck(this, ScrollSpy);\n      _this47 = _super15.call(this, element, config); // this._element is the observablesContainer and config.target the menu links wrapper\n\n      _this47._targetLinks = new Map();\n      _this47._observableSections = new Map();\n      _this47._rootElement = getComputedStyle(_this47._element).overflowY === 'visible' ? null : _this47._element;\n      _this47._activeTarget = null;\n      _this47._observer = null;\n      _this47._previousScrollData = {\n        visibleEntryTop: 0,\n        parentScrollTop: 0\n      };\n      _this47.refresh(); // initialize\n      return _this47;\n    } // Getters\n    _createClass(ScrollSpy, [{\n      key: \"refresh\",\n      value:\n      // Public\n\n      function refresh() {\n        this._initializeTargetsAndObservables();\n        this._maybeEnableSmoothScroll();\n        if (this._observer) {\n          this._observer.disconnect();\n        } else {\n          this._observer = this._getNewObserver();\n        }\n        var _iterator24 = _createForOfIteratorHelper(this._observableSections.values()),\n          _step24;\n        try {\n          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n            var section = _step24.value;\n            this._observer.observe(section);\n          }\n        } catch (err) {\n          _iterator24.e(err);\n        } finally {\n          _iterator24.f();\n        }\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        this._observer.disconnect();\n        _get(_getPrototypeOf(ScrollSpy.prototype), \"dispose\", this).call(this);\n      } // Private\n    }, {\n      key: \"_configAfterMerge\",\n      value: function _configAfterMerge(config) {\n        // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case\n        config.target = getElement(config.target) || document.body; // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only\n\n        config.rootMargin = config.offset ? \"\".concat(config.offset, \"px 0px -30%\") : config.rootMargin;\n        if (typeof config.threshold === 'string') {\n          config.threshold = config.threshold.split(',').map(function (value) {\n            return Number.parseFloat(value);\n          });\n        }\n        return config;\n      }\n    }, {\n      key: \"_maybeEnableSmoothScroll\",\n      value: function _maybeEnableSmoothScroll() {\n        var _this48 = this;\n        if (!this._config.smoothScroll) {\n          return;\n        } // unregister any previous listeners\n\n        EventHandler.off(this._config.target, EVENT_CLICK);\n        EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, function (event) {\n          var observableSection = _this48._observableSections.get(event.target.hash);\n          if (observableSection) {\n            event.preventDefault();\n            var root = _this48._rootElement || window;\n            var height = observableSection.offsetTop - _this48._element.offsetTop;\n            if (root.scrollTo) {\n              root.scrollTo({\n                top: height,\n                behavior: 'smooth'\n              });\n              return;\n            } // Chrome 60 doesn't support `scrollTo`\n\n            root.scrollTop = height;\n          }\n        });\n      }\n    }, {\n      key: \"_getNewObserver\",\n      value: function _getNewObserver() {\n        var _this49 = this;\n        var options = {\n          root: this._rootElement,\n          threshold: this._config.threshold,\n          rootMargin: this._config.rootMargin\n        };\n        return new IntersectionObserver(function (entries) {\n          return _this49._observerCallback(entries);\n        }, options);\n      } // The logic of selection\n    }, {\n      key: \"_observerCallback\",\n      value: function _observerCallback(entries) {\n        var _this50 = this;\n        var targetElement = function targetElement(entry) {\n          return _this50._targetLinks.get(\"#\".concat(entry.target.id));\n        };\n        var activate = function activate(entry) {\n          _this50._previousScrollData.visibleEntryTop = entry.target.offsetTop;\n          _this50._process(targetElement(entry));\n        };\n        var parentScrollTop = (this._rootElement || document.documentElement).scrollTop;\n        var userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;\n        this._previousScrollData.parentScrollTop = parentScrollTop;\n        var _iterator25 = _createForOfIteratorHelper(entries),\n          _step25;\n        try {\n          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n            var entry = _step25.value;\n            if (!entry.isIntersecting) {\n              this._activeTarget = null;\n              this._clearActiveClass(targetElement(entry));\n              continue;\n            }\n            var entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop; // if we are scrolling down, pick the bigger offsetTop\n\n            if (userScrollsDown && entryIsLowerThanPrevious) {\n              activate(entry); // if parent isn't scrolled, let's keep the first visible item, breaking the iteration\n\n              if (!parentScrollTop) {\n                return;\n              }\n              continue;\n            } // if we are scrolling up, pick the smallest offsetTop\n\n            if (!userScrollsDown && !entryIsLowerThanPrevious) {\n              activate(entry);\n            }\n          }\n        } catch (err) {\n          _iterator25.e(err);\n        } finally {\n          _iterator25.f();\n        }\n      }\n    }, {\n      key: \"_initializeTargetsAndObservables\",\n      value: function _initializeTargetsAndObservables() {\n        this._targetLinks = new Map();\n        this._observableSections = new Map();\n        var targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);\n        var _iterator26 = _createForOfIteratorHelper(targetLinks),\n          _step26;\n        try {\n          for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n            var anchor = _step26.value;\n            // ensure that the anchor has an id and is not disabled\n            if (!anchor.hash || isDisabled(anchor)) {\n              continue;\n            }\n            var observableSection = SelectorEngine.findOne(anchor.hash, this._element); // ensure that the observableSection exists & is visible\n\n            if (isVisible(observableSection)) {\n              this._targetLinks.set(anchor.hash, anchor);\n              this._observableSections.set(anchor.hash, observableSection);\n            }\n          }\n        } catch (err) {\n          _iterator26.e(err);\n        } finally {\n          _iterator26.f();\n        }\n      }\n    }, {\n      key: \"_process\",\n      value: function _process(target) {\n        if (this._activeTarget === target) {\n          return;\n        }\n        this._clearActiveClass(this._config.target);\n        this._activeTarget = target;\n        target.classList.add(CLASS_NAME_ACTIVE$1);\n        this._activateParents(target);\n        EventHandler.trigger(this._element, EVENT_ACTIVATE, {\n          relatedTarget: target\n        });\n      }\n    }, {\n      key: \"_activateParents\",\n      value: function _activateParents(target) {\n        // Activate dropdown parents\n        if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\n          SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);\n          return;\n        }\n        var _iterator27 = _createForOfIteratorHelper(SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)),\n          _step27;\n        try {\n          for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n            var listGroup = _step27.value;\n            // Set triggered links parents as active\n            // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n            var _iterator28 = _createForOfIteratorHelper(SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)),\n              _step28;\n            try {\n              for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n                var item = _step28.value;\n                item.classList.add(CLASS_NAME_ACTIVE$1);\n              }\n            } catch (err) {\n              _iterator28.e(err);\n            } finally {\n              _iterator28.f();\n            }\n          }\n        } catch (err) {\n          _iterator27.e(err);\n        } finally {\n          _iterator27.f();\n        }\n      }\n    }, {\n      key: \"_clearActiveClass\",\n      value: function _clearActiveClass(parent) {\n        parent.classList.remove(CLASS_NAME_ACTIVE$1);\n        var activeNodes = SelectorEngine.find(\"\".concat(SELECTOR_TARGET_LINKS, \".\").concat(CLASS_NAME_ACTIVE$1), parent);\n        var _iterator29 = _createForOfIteratorHelper(activeNodes),\n          _step29;\n        try {\n          for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n            var node = _step29.value;\n            node.classList.remove(CLASS_NAME_ACTIVE$1);\n          }\n        } catch (err) {\n          _iterator29.e(err);\n        } finally {\n          _iterator29.f();\n        }\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$1;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$1;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$2;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = ScrollSpy.getOrCreateInstance(this, config);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        });\n      }\n    }]);\n    return ScrollSpy;\n  }(BaseComponent);\n  /**\r\n   * Data API implementation\r\n   */\n  EventHandler.on(window, EVENT_LOAD_DATA_API$1, function () {\n    var _iterator30 = _createForOfIteratorHelper(SelectorEngine.find(SELECTOR_DATA_SPY)),\n      _step30;\n    try {\n      for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n        var spy = _step30.value;\n        ScrollSpy.getOrCreateInstance(spy);\n      }\n    } catch (err) {\n      _iterator30.e(err);\n    } finally {\n      _iterator30.f();\n    }\n  });\n  /**\r\n   * jQuery\r\n   */\n\n  defineJQueryPlugin(ScrollSpy);\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): tab.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n\n  var NAME$1 = 'tab';\n  var DATA_KEY$1 = 'bs.tab';\n  var EVENT_KEY$1 = \".\".concat(DATA_KEY$1);\n  var EVENT_HIDE$1 = \"hide\".concat(EVENT_KEY$1);\n  var EVENT_HIDDEN$1 = \"hidden\".concat(EVENT_KEY$1);\n  var EVENT_SHOW$1 = \"show\".concat(EVENT_KEY$1);\n  var EVENT_SHOWN$1 = \"shown\".concat(EVENT_KEY$1);\n  var EVENT_CLICK_DATA_API = \"click\".concat(EVENT_KEY$1);\n  var EVENT_KEYDOWN = \"keydown\".concat(EVENT_KEY$1);\n  var EVENT_LOAD_DATA_API = \"load\".concat(EVENT_KEY$1);\n  var ARROW_LEFT_KEY = 'ArrowLeft';\n  var ARROW_RIGHT_KEY = 'ArrowRight';\n  var ARROW_UP_KEY = 'ArrowUp';\n  var ARROW_DOWN_KEY = 'ArrowDown';\n  var CLASS_NAME_ACTIVE = 'active';\n  var CLASS_NAME_FADE$1 = 'fade';\n  var CLASS_NAME_SHOW$1 = 'show';\n  var CLASS_DROPDOWN = 'dropdown';\n  var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\n  var SELECTOR_DROPDOWN_MENU = '.dropdown-menu';\n  var NOT_SELECTOR_DROPDOWN_TOGGLE = ':not(.dropdown-toggle)';\n  var SELECTOR_TAB_PANEL = '.list-group, .nav, [role=\"tablist\"]';\n  var SELECTOR_OUTER = '.nav-item, .list-group-item';\n  var SELECTOR_INNER = \".nav-link\".concat(NOT_SELECTOR_DROPDOWN_TOGGLE, \", .list-group-item\").concat(NOT_SELECTOR_DROPDOWN_TOGGLE, \", [role=\\\"tab\\\"]\").concat(NOT_SELECTOR_DROPDOWN_TOGGLE);\n  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]'; // todo:v6: could be only `tab`\n\n  var SELECTOR_INNER_ELEM = \"\".concat(SELECTOR_INNER, \", \").concat(SELECTOR_DATA_TOGGLE);\n  var SELECTOR_DATA_TOGGLE_ACTIVE = \".\".concat(CLASS_NAME_ACTIVE, \"[data-bs-toggle=\\\"tab\\\"], .\").concat(CLASS_NAME_ACTIVE, \"[data-bs-toggle=\\\"pill\\\"], .\").concat(CLASS_NAME_ACTIVE, \"[data-bs-toggle=\\\"list\\\"]\");\n  /**\r\n   * Class definition\r\n   */\n  var Tab = /*#__PURE__*/function (_BaseComponent10) {\n    _inherits(Tab, _BaseComponent10);\n    var _super16 = _createSuper(Tab);\n    function Tab(element) {\n      var _this51;\n      _classCallCheck(this, Tab);\n      _this51 = _super16.call(this, element);\n      _this51._parent = _this51._element.closest(SELECTOR_TAB_PANEL);\n      if (!_this51._parent) {\n        return _possibleConstructorReturn(_this51); // todo: should Throw exception on v6\n        // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)\n      } // Set up initial aria attributes\n\n      _this51._setInitialAttributes(_this51._parent, _this51._getChildren());\n      EventHandler.on(_this51._element, EVENT_KEYDOWN, function (event) {\n        return _this51._keydown(event);\n      });\n      return _this51;\n    } // Getters\n    _createClass(Tab, [{\n      key: \"show\",\n      value:\n      // Public\n\n      function show() {\n        // Shows this elem and deactivate the active sibling if exists\n        var innerElem = this._element;\n        if (this._elemIsActive(innerElem)) {\n          return;\n        } // Search for active tab on same parent to deactivate it\n\n        var active = this._getActiveElem();\n        var hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {\n          relatedTarget: innerElem\n        }) : null;\n        var showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {\n          relatedTarget: active\n        });\n        if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {\n          return;\n        }\n        this._deactivate(active, innerElem);\n        this._activate(innerElem, active);\n      } // Private\n    }, {\n      key: \"_activate\",\n      value: function _activate(element, relatedElem) {\n        var _this52 = this;\n        if (!element) {\n          return;\n        }\n        element.classList.add(CLASS_NAME_ACTIVE);\n        this._activate(getElementFromSelector(element)); // Search and activate/show the proper section\n\n        var complete = function complete() {\n          if (element.getAttribute('role') !== 'tab') {\n            element.classList.add(CLASS_NAME_SHOW$1);\n            return;\n          }\n          element.removeAttribute('tabindex');\n          element.setAttribute('aria-selected', true);\n          _this52._toggleDropDown(element, true);\n          EventHandler.trigger(element, EVENT_SHOWN$1, {\n            relatedTarget: relatedElem\n          });\n        };\n        this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n      }\n    }, {\n      key: \"_deactivate\",\n      value: function _deactivate(element, relatedElem) {\n        var _this53 = this;\n        if (!element) {\n          return;\n        }\n        element.classList.remove(CLASS_NAME_ACTIVE);\n        element.blur();\n        this._deactivate(getElementFromSelector(element)); // Search and deactivate the shown section too\n\n        var complete = function complete() {\n          if (element.getAttribute('role') !== 'tab') {\n            element.classList.remove(CLASS_NAME_SHOW$1);\n            return;\n          }\n          element.setAttribute('aria-selected', false);\n          element.setAttribute('tabindex', '-1');\n          _this53._toggleDropDown(element, false);\n          EventHandler.trigger(element, EVENT_HIDDEN$1, {\n            relatedTarget: relatedElem\n          });\n        };\n        this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n      }\n    }, {\n      key: \"_keydown\",\n      value: function _keydown(event) {\n        if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY].includes(event.key)) {\n          return;\n        }\n        event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page\n\n        event.preventDefault();\n        var isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);\n        var nextActiveElement = getNextActiveElement(this._getChildren().filter(function (element) {\n          return !isDisabled(element);\n        }), event.target, isNext, true);\n        if (nextActiveElement) {\n          nextActiveElement.focus({\n            preventScroll: true\n          });\n          Tab.getOrCreateInstance(nextActiveElement).show();\n        }\n      }\n    }, {\n      key: \"_getChildren\",\n      value: function _getChildren() {\n        // collection of inner elements\n        return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);\n      }\n    }, {\n      key: \"_getActiveElem\",\n      value: function _getActiveElem() {\n        var _this54 = this;\n        return this._getChildren().find(function (child) {\n          return _this54._elemIsActive(child);\n        }) || null;\n      }\n    }, {\n      key: \"_setInitialAttributes\",\n      value: function _setInitialAttributes(parent, children) {\n        this._setAttributeIfNotExists(parent, 'role', 'tablist');\n        var _iterator31 = _createForOfIteratorHelper(children),\n          _step31;\n        try {\n          for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n            var child = _step31.value;\n            this._setInitialAttributesOnChild(child);\n          }\n        } catch (err) {\n          _iterator31.e(err);\n        } finally {\n          _iterator31.f();\n        }\n      }\n    }, {\n      key: \"_setInitialAttributesOnChild\",\n      value: function _setInitialAttributesOnChild(child) {\n        child = this._getInnerElement(child);\n        var isActive = this._elemIsActive(child);\n        var outerElem = this._getOuterElement(child);\n        child.setAttribute('aria-selected', isActive);\n        if (outerElem !== child) {\n          this._setAttributeIfNotExists(outerElem, 'role', 'presentation');\n        }\n        if (!isActive) {\n          child.setAttribute('tabindex', '-1');\n        }\n        this._setAttributeIfNotExists(child, 'role', 'tab'); // set attributes to the related panel too\n\n        this._setInitialAttributesOnTargetPanel(child);\n      }\n    }, {\n      key: \"_setInitialAttributesOnTargetPanel\",\n      value: function _setInitialAttributesOnTargetPanel(child) {\n        var target = getElementFromSelector(child);\n        if (!target) {\n          return;\n        }\n        this._setAttributeIfNotExists(target, 'role', 'tabpanel');\n        if (child.id) {\n          this._setAttributeIfNotExists(target, 'aria-labelledby', \"#\".concat(child.id));\n        }\n      }\n    }, {\n      key: \"_toggleDropDown\",\n      value: function _toggleDropDown(element, open) {\n        var outerElem = this._getOuterElement(element);\n        if (!outerElem.classList.contains(CLASS_DROPDOWN)) {\n          return;\n        }\n        var toggle = function toggle(selector, className) {\n          var element = SelectorEngine.findOne(selector, outerElem);\n          if (element) {\n            element.classList.toggle(className, open);\n          }\n        };\n        toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);\n        toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);\n        outerElem.setAttribute('aria-expanded', open);\n      }\n    }, {\n      key: \"_setAttributeIfNotExists\",\n      value: function _setAttributeIfNotExists(element, attribute, value) {\n        if (!element.hasAttribute(attribute)) {\n          element.setAttribute(attribute, value);\n        }\n      }\n    }, {\n      key: \"_elemIsActive\",\n      value: function _elemIsActive(elem) {\n        return elem.classList.contains(CLASS_NAME_ACTIVE);\n      } // Try to get the inner element (usually the .nav-link)\n    }, {\n      key: \"_getInnerElement\",\n      value: function _getInnerElement(elem) {\n        return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);\n      } // Try to get the outer element (usually the .nav-item)\n    }, {\n      key: \"_getOuterElement\",\n      value: function _getOuterElement(elem) {\n        return elem.closest(SELECTOR_OUTER) || elem;\n      } // Static\n    }], [{\n      key: \"NAME\",\n      get: function get() {\n        return NAME$1;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Tab.getOrCreateInstance(this);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        });\n      }\n    }]);\n    return Tab;\n  }(BaseComponent);\n  /**\r\n   * Data API implementation\r\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n    if (isDisabled(this)) {\n      return;\n    }\n    Tab.getOrCreateInstance(this).show();\n  });\n  /**\r\n   * Initialize on focus\r\n   */\n\n  EventHandler.on(window, EVENT_LOAD_DATA_API, function () {\n    var _iterator32 = _createForOfIteratorHelper(SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)),\n      _step32;\n    try {\n      for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n        var element = _step32.value;\n        Tab.getOrCreateInstance(element);\n      }\n    } catch (err) {\n      _iterator32.e(err);\n    } finally {\n      _iterator32.f();\n    }\n  });\n  /**\r\n   * jQuery\r\n   */\n\n  defineJQueryPlugin(Tab);\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): toast.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  /**\r\n   * Constants\r\n   */\n\n  var NAME = 'toast';\n  var DATA_KEY = 'bs.toast';\n  var EVENT_KEY = \".\".concat(DATA_KEY);\n  var EVENT_MOUSEOVER = \"mouseover\".concat(EVENT_KEY);\n  var EVENT_MOUSEOUT = \"mouseout\".concat(EVENT_KEY);\n  var EVENT_FOCUSIN = \"focusin\".concat(EVENT_KEY);\n  var EVENT_FOCUSOUT = \"focusout\".concat(EVENT_KEY);\n  var EVENT_HIDE = \"hide\".concat(EVENT_KEY);\n  var EVENT_HIDDEN = \"hidden\".concat(EVENT_KEY);\n  var EVENT_SHOW = \"show\".concat(EVENT_KEY);\n  var EVENT_SHOWN = \"shown\".concat(EVENT_KEY);\n  var CLASS_NAME_FADE = 'fade';\n  var CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility\n\n  var CLASS_NAME_SHOW = 'show';\n  var CLASS_NAME_SHOWING = 'showing';\n  var DefaultType = {\n    animation: 'boolean',\n    autohide: 'boolean',\n    delay: 'number'\n  };\n  var Default = {\n    animation: true,\n    autohide: true,\n    delay: 5000\n  };\n  /**\r\n   * Class definition\r\n   */\n  var Toast = /*#__PURE__*/function (_BaseComponent11) {\n    _inherits(Toast, _BaseComponent11);\n    var _super17 = _createSuper(Toast);\n    function Toast(element, config) {\n      var _this55;\n      _classCallCheck(this, Toast);\n      _this55 = _super17.call(this, element, config);\n      _this55._timeout = null;\n      _this55._hasMouseInteraction = false;\n      _this55._hasKeyboardInteraction = false;\n      _this55._setListeners();\n      return _this55;\n    } // Getters\n    _createClass(Toast, [{\n      key: \"show\",\n      value:\n      // Public\n\n      function show() {\n        var _this56 = this;\n        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\n        if (showEvent.defaultPrevented) {\n          return;\n        }\n        this._clearTimeout();\n        if (this._config.animation) {\n          this._element.classList.add(CLASS_NAME_FADE);\n        }\n        var complete = function complete() {\n          _this56._element.classList.remove(CLASS_NAME_SHOWING);\n          EventHandler.trigger(_this56._element, EVENT_SHOWN);\n          _this56._maybeScheduleHide();\n        };\n        this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated\n\n        reflow(this._element);\n        this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);\n        this._queueCallback(complete, this._element, this._config.animation);\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var _this57 = this;\n        if (!this.isShown()) {\n          return;\n        }\n        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\n        if (hideEvent.defaultPrevented) {\n          return;\n        }\n        var complete = function complete() {\n          _this57._element.classList.add(CLASS_NAME_HIDE); // @deprecated\n\n          _this57._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);\n          EventHandler.trigger(_this57._element, EVENT_HIDDEN);\n        };\n        this._element.classList.add(CLASS_NAME_SHOWING);\n        this._queueCallback(complete, this._element, this._config.animation);\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        this._clearTimeout();\n        if (this.isShown()) {\n          this._element.classList.remove(CLASS_NAME_SHOW);\n        }\n        _get(_getPrototypeOf(Toast.prototype), \"dispose\", this).call(this);\n      }\n    }, {\n      key: \"isShown\",\n      value: function isShown() {\n        return this._element.classList.contains(CLASS_NAME_SHOW);\n      } // Private\n    }, {\n      key: \"_maybeScheduleHide\",\n      value: function _maybeScheduleHide() {\n        var _this58 = this;\n        if (!this._config.autohide) {\n          return;\n        }\n        if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\n          return;\n        }\n        this._timeout = setTimeout(function () {\n          _this58.hide();\n        }, this._config.delay);\n      }\n    }, {\n      key: \"_onInteraction\",\n      value: function _onInteraction(event, isInteracting) {\n        switch (event.type) {\n          case 'mouseover':\n          case 'mouseout':\n            {\n              this._hasMouseInteraction = isInteracting;\n              break;\n            }\n          case 'focusin':\n          case 'focusout':\n            {\n              this._hasKeyboardInteraction = isInteracting;\n              break;\n            }\n        }\n        if (isInteracting) {\n          this._clearTimeout();\n          return;\n        }\n        var nextElement = event.relatedTarget;\n        if (this._element === nextElement || this._element.contains(nextElement)) {\n          return;\n        }\n        this._maybeScheduleHide();\n      }\n    }, {\n      key: \"_setListeners\",\n      value: function _setListeners() {\n        var _this59 = this;\n        EventHandler.on(this._element, EVENT_MOUSEOVER, function (event) {\n          return _this59._onInteraction(event, true);\n        });\n        EventHandler.on(this._element, EVENT_MOUSEOUT, function (event) {\n          return _this59._onInteraction(event, false);\n        });\n        EventHandler.on(this._element, EVENT_FOCUSIN, function (event) {\n          return _this59._onInteraction(event, true);\n        });\n        EventHandler.on(this._element, EVENT_FOCUSOUT, function (event) {\n          return _this59._onInteraction(event, false);\n        });\n      }\n    }, {\n      key: \"_clearTimeout\",\n      value: function _clearTimeout() {\n        clearTimeout(this._timeout);\n        this._timeout = null;\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Toast.getOrCreateInstance(this, config);\n          if (typeof config === 'string') {\n            if (typeof data[config] === 'undefined') {\n              throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n            }\n            data[config](this);\n          }\n        });\n      }\n    }]);\n    return Toast;\n  }(BaseComponent);\n  /**\r\n   * Data API implementation\r\n   */\n  enableDismissTrigger(Toast);\n  /**\r\n   * jQuery\r\n   */\n\n  defineJQueryPlugin(Toast);\n\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap (v5.2.3): index.umd.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\n  var index_umd = {\n    Alert: Alert,\n    Button: Button,\n    Carousel: Carousel,\n    Collapse: Collapse,\n    Dropdown: Dropdown,\n    Modal: Modal,\n    Offcanvas: Offcanvas,\n    Popover: Popover,\n    ScrollSpy: ScrollSpy,\n    Tab: Tab,\n    Toast: Toast,\n    Tooltip: Tooltip\n  };\n  return index_umd;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvdXNlci9ib290c3RyYXAuYnVuZGxlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsVUFBVUEsTUFBTSxFQUFFQyxPQUFPLEVBQUU7RUFDMUIsT0FBYyxlQUFQQyxPQUFPLE9BQUssUUFBUSxJQUFJLFFBQWEsS0FBSyxXQUFXLEdBQUdDLE1BQU0sQ0FBQ0QsT0FBTyxHQUFHRCxPQUFPLEVBQUUsR0FDekYsS0FBMEMsR0FBR0csb0NBQU9ILE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQSxrR0FBQyxJQUMzREQsQ0FBc0csQ0FBQztBQUMxRyxDQUFDLEVBQUUsSUFBSSxFQUFHLFlBQVk7RUFBRSxZQUFZOztFQUVsQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFMRTtFQU1BLElBQU1TLE9BQU8sR0FBRyxPQUFPO0VBQ3ZCLElBQU1DLHVCQUF1QixHQUFHLElBQUk7RUFDcEMsSUFBTUMsY0FBYyxHQUFHLGVBQWUsQ0FBQyxDQUFDOztFQUV4QyxJQUFNQyxNQUFNLEdBQUcsU0FBVEEsTUFBTSxDQUFHQyxNQUFNLEVBQUk7SUFDdkIsSUFBSUEsTUFBTSxLQUFLLElBQUksSUFBSUEsTUFBTSxLQUFLQyxTQUFTLEVBQUU7TUFDM0MsaUJBQVVELE1BQU07SUFDbEI7SUFFQSxPQUFPRSxNQUFNLENBQUNDLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNMLE1BQU0sQ0FBQyxDQUFDTSxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUNDLFdBQVcsRUFBRTtFQUNyRixDQUFDO0VBQ0Q7QUFDRjtBQUNBOztFQUdFLElBQU1DLE1BQU0sR0FBRyxTQUFUQSxNQUFNLENBQUdDLE1BQU0sRUFBSTtJQUN2QixHQUFHO01BQ0RBLE1BQU0sSUFBSUMsSUFBSSxDQUFDQyxLQUFLLENBQUNELElBQUksQ0FBQ0UsTUFBTSxFQUFFLEdB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QUFDLENBQUMsSUFBSSxDQUFDO1VBQ3BCO1FBQ0YsQ0FBQyxDQUFDO01BQ0o7SUFBQztJQUFBO0VBQUEsRUF0S2lCa0IsYUFBYTtFQXlLakM7QUFDRjtBQUNBO0VBR0VVLG9CQUFvQixDQUFDbW1DLEtBQUssQ0FBQztFQUMzQjtBQUNGO0FBQ0E7O0VBRUU5d0Msa0JBQWtCLENBQUM4d0MsS0FBSyxDQUFDOztFQUV6QjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRSxJQUFNUSxTQUFTLEdBQUc7SUFDaEI5bEMsS0FBSyxFQUFMQSxLQUFLO0lBQ0xjLE1BQU0sRUFBTkEsTUFBTTtJQUNOb0csUUFBUSxFQUFSQSxRQUFRO0lBQ1IwRSxRQUFRLEVBQVJBLFFBQVE7SUFDUjZlLFFBQVEsRUFBUkEsUUFBUTtJQUNSaUgsS0FBSyxFQUFMQSxLQUFLO0lBQ0w4QyxTQUFTLEVBQVRBLFNBQVM7SUFDVHNKLE9BQU8sRUFBUEEsT0FBTztJQUNQeUIsU0FBUyxFQUFUQSxTQUFTO0lBQ1Q2RCxHQUFHLEVBQUhBLEdBQUc7SUFDSGtDLEtBQUssRUFBTEEsS0FBSztJQUNMbEssT0FBTyxFQUFQQTtFQUNGLENBQUM7RUFFRCxPQUFPMEssU0FBUztBQUVsQixDQUFDLENBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvdXNlci9ib290c3RyYXAuYnVuZGxlLmpzPzY1N2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXHJcbiAgKiBCb290c3RyYXAgdjUuMi4zIChodHRwczovL2dldGJvb3RzdHJhcC5jb20vKVxyXG4gICogQ29weXJpZ2h0IDIwMTEtMjAyMiBUaGUgQm9vdHN0cmFwIEF1dGhvcnMgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ncmFwaHMvY29udHJpYnV0b3JzKVxyXG4gICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgKi9cclxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XHJcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcclxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuYm9vdHN0cmFwID0gZmFjdG9yeSgpKTtcclxufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogdXRpbC9pbmRleC5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcbiAgY29uc3QgTUFYX1VJRCA9IDEwMDAwMDA7XHJcbiAgY29uc3QgTUlMTElTRUNPTkRTX01VTFRJUExJRVIgPSAxMDAwO1xyXG4gIGNvbnN0IFRSQU5TSVRJT05fRU5EID0gJ3RyYW5zaXRpb25lbmQnOyAvLyBTaG91dC1vdXQgQW5ndXMgQ3JvbGwgKGh0dHBzOi8vZ29vLmdsL3B4d1FHcClcclxuXHJcbiAgY29uc3QgdG9UeXBlID0gb2JqZWN0ID0+IHtcclxuICAgIGlmIChvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIGAke29iamVjdH1gO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKTtcclxuICB9O1xyXG4gIC8qKlxyXG4gICAqIFB1YmxpYyBVdGlsIEFQSVxyXG4gICAqL1xyXG5cclxuXHJcbiAgY29uc3QgZ2V0VUlEID0gcHJlZml4ID0+IHtcclxuICAgIGRvIHtcclxuICAgICAgcHJlZml4ICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1BWF9VSUQpO1xyXG4gICAgfSB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJlZml4KSk7XHJcblxyXG4gICAgcmV0dXJuIHByZWZpeDtcclxuICB9O1xyXG5cclxuICBjb25zdCBnZXRTZWxlY3RvciA9IGVsZW1lbnQgPT4ge1xyXG4gICAgbGV0IHNlbGVjdG9yID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtdGFyZ2V0Jyk7XHJcblxyXG4gICAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gJyMnKSB7XHJcbiAgICAgIGxldCBocmVmQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTsgLy8gVGhlIG9ubHkgdmFsaWQgY29udGVudCB0aGF0IGNvdWxkIGRvdWJsZSBhcyBhIHNlbGVjdG9yIGFyZSBJRHMgb3IgY2xhc3NlcyxcclxuICAgICAgLy8gc28gZXZlcnl0aGluZyBzdGFydGluZyB3aXRoIGAjYCBvciBgLmAuIElmIGEgXCJyZWFsXCIgVVJMIGlzIHVzZWQgYXMgdGhlIHNlbGVjdG9yLFxyXG4gICAgICAvLyBgZG9jdW1lbnQucXVlcnlTZWxlY3RvcmAgd2lsbCByaWdodGZ1bGx5IGNvbXBsYWluIGl0IGlzIGludmFsaWQuXHJcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvaXNzdWVzLzMyMjczXHJcblxyXG4gICAgICBpZiAoIWhyZWZBdHRyaWJ1dGUgfHwgIWhyZWZBdHRyaWJ1dGUuaW5jbHVkZXMoJyMnKSAmJiAhaHJlZkF0dHJpYnV0ZS5zdGFydHNXaXRoKCcuJykpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfSAvLyBKdXN0IGluIGNhc2Ugc29tZSBDTVMgcHV0cyBvdXQgYSBmdWxsIFVSTCB3aXRoIHRoZSBhbmNob3IgYXBwZW5kZWRcclxuXHJcblxyXG4gICAgICBpZiAoaHJlZkF0dHJpYnV0ZS5pbmNsdWRlcygnIycpICYmICFocmVmQXR0cmlidXRlLnN0YXJ0c1dpdGgoJyMnKSkge1xyXG4gICAgICAgIGhyZWZBdHRyaWJ1dGUgPSBgIyR7aHJlZkF0dHJpYnV0ZS5zcGxpdCgnIycpWzFdfWA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGVjdG9yID0gaHJlZkF0dHJpYnV0ZSAmJiBocmVmQXR0cmlidXRlICE9PSAnIycgPyBocmVmQXR0cmlidXRlLnRyaW0oKSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNlbGVjdG9yO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldFNlbGVjdG9yRnJvbUVsZW1lbnQgPSBlbGVtZW50ID0+IHtcclxuICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoZWxlbWVudCk7XHJcblxyXG4gICAgaWYgKHNlbGVjdG9yKSB7XHJcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9O1xyXG5cclxuICBjb25zdCBnZXRFbGVtZW50RnJvbVNlbGVjdG9yID0gZWxlbWVudCA9PiB7XHJcbiAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGVsZW1lbnQpO1xyXG4gICAgcmV0dXJuIHNlbGVjdG9yID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgOiBudWxsO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50ID0gZWxlbWVudCA9PiB7XHJcbiAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9IC8vIEdldCB0cmFuc2l0aW9uLWR1cmF0aW9uIG9mIHRoZSBlbGVtZW50XHJcblxyXG5cclxuICAgIGxldCB7XHJcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbixcclxuICAgICAgdHJhbnNpdGlvbkRlbGF5XHJcbiAgICB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XHJcbiAgICBjb25zdCBmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiA9IE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbik7XHJcbiAgICBjb25zdCBmbG9hdFRyYW5zaXRpb25EZWxheSA9IE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSk7IC8vIFJldHVybiAwIGlmIGVsZW1lbnQgb3IgdHJhbnNpdGlvbiBkdXJhdGlvbiBpcyBub3QgZm91bmRcclxuXHJcbiAgICBpZiAoIWZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uICYmICFmbG9hdFRyYW5zaXRpb25EZWxheSkge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH0gLy8gSWYgbXVsdGlwbGUgZHVyYXRpb25zIGFyZSBkZWZpbmVkLCB0YWtlIHRoZSBmaXJzdFxyXG5cclxuXHJcbiAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb24uc3BsaXQoJywnKVswXTtcclxuICAgIHRyYW5zaXRpb25EZWxheSA9IHRyYW5zaXRpb25EZWxheS5zcGxpdCgnLCcpWzBdO1xyXG4gICAgcmV0dXJuIChOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pICsgTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KSkgKiBNSUxMSVNFQ09ORFNfTVVMVElQTElFUjtcclxuICB9O1xyXG5cclxuICBjb25zdCB0cmlnZ2VyVHJhbnNpdGlvbkVuZCA9IGVsZW1lbnQgPT4ge1xyXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChUUkFOU0lUSU9OX0VORCkpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGlzRWxlbWVudCQxID0gb2JqZWN0ID0+IHtcclxuICAgIGlmICghb2JqZWN0IHx8IHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIG9iamVjdC5qcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIG9iamVjdCA9IG9iamVjdFswXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdC5ub2RlVHlwZSAhPT0gJ3VuZGVmaW5lZCc7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZ2V0RWxlbWVudCA9IG9iamVjdCA9PiB7XHJcbiAgICAvLyBpdCdzIGEgalF1ZXJ5IG9iamVjdCBvciBhIG5vZGUgZWxlbWVudFxyXG4gICAgaWYgKGlzRWxlbWVudCQxKG9iamVjdCkpIHtcclxuICAgICAgcmV0dXJuIG9iamVjdC5qcXVlcnkgPyBvYmplY3RbMF0gOiBvYmplY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9iamVjdCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaXNWaXNpYmxlID0gZWxlbWVudCA9PiB7XHJcbiAgICBpZiAoIWlzRWxlbWVudCQxKGVsZW1lbnQpIHx8IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGVsZW1lbnRJc1Zpc2libGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Zpc2liaWxpdHknKSA9PT0gJ3Zpc2libGUnOyAvLyBIYW5kbGUgYGRldGFpbHNgIGVsZW1lbnQgYXMgaXRzIGNvbnRlbnQgbWF5IGZhbHNpZSBhcHBlYXIgdmlzaWJsZSB3aGVuIGl0IGlzIGNsb3NlZFxyXG5cclxuICAgIGNvbnN0IGNsb3NlZERldGFpbHMgPSBlbGVtZW50LmNsb3Nlc3QoJ2RldGFpbHM6bm90KFtvcGVuXSknKTtcclxuXHJcbiAgICBpZiAoIWNsb3NlZERldGFpbHMpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnRJc1Zpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNsb3NlZERldGFpbHMgIT09IGVsZW1lbnQpIHtcclxuICAgICAgY29uc3Qgc3VtbWFyeSA9IGVsZW1lbnQuY2xvc2VzdCgnc3VtbWFyeScpO1xyXG5cclxuICAgICAgaWYgKHN1bW1hcnkgJiYgc3VtbWFyeS5wYXJlbnROb2RlICE9PSBjbG9zZWREZXRhaWxzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc3VtbWFyeSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbGVtZW50SXNWaXNpYmxlO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGlzRGlzYWJsZWQgPSBlbGVtZW50ID0+IHtcclxuICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50Lm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2Rpc2FibGVkJykpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4gZWxlbWVudC5kaXNhYmxlZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgIT09ICdmYWxzZSc7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZmluZFNoYWRvd1Jvb3QgPSBlbGVtZW50ID0+IHtcclxuICAgIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaFNoYWRvdykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0gLy8gQ2FuIGZpbmQgdGhlIHNoYWRvdyByb290IG90aGVyd2lzZSBpdCdsbCByZXR1cm4gdGhlIGRvY3VtZW50XHJcblxyXG5cclxuICAgIGlmICh0eXBlb2YgZWxlbWVudC5nZXRSb290Tm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjb25zdCByb290ID0gZWxlbWVudC5nZXRSb290Tm9kZSgpO1xyXG4gICAgICByZXR1cm4gcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyByb290IDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICB9IC8vIHdoZW4gd2UgZG9uJ3QgZmluZCBhIHNoYWRvdyByb290XHJcblxyXG5cclxuICAgIGlmICghZWxlbWVudC5wYXJlbnROb2RlKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmaW5kU2hhZG93Um9vdChlbGVtZW50LnBhcmVudE5vZGUpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcclxuICAvKipcclxuICAgKiBUcmljayB0byByZXN0YXJ0IGFuIGVsZW1lbnQncyBhbmltYXRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICAgKiBAcmV0dXJuIHZvaWRcclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuY2hhcmlzdGhlby5pby9ibG9nLzIwMjEvMDIvcmVzdGFydC1hLWNzcy1hbmltYXRpb24td2l0aC1qYXZhc2NyaXB0LyNyZXN0YXJ0aW5nLWEtY3NzLWFuaW1hdGlvblxyXG4gICAqL1xyXG5cclxuXHJcbiAgY29uc3QgcmVmbG93ID0gZWxlbWVudCA9PiB7XHJcbiAgICBlbGVtZW50Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcclxuICB9O1xyXG5cclxuICBjb25zdCBnZXRqUXVlcnkgPSAoKSA9PiB7XHJcbiAgICBpZiAod2luZG93LmpRdWVyeSAmJiAhZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoJ2RhdGEtYnMtbm8tanF1ZXJ5JykpIHtcclxuICAgICAgcmV0dXJuIHdpbmRvdy5qUXVlcnk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcyA9IFtdO1xyXG5cclxuICBjb25zdCBvbkRPTUNvbnRlbnRMb2FkZWQgPSBjYWxsYmFjayA9PiB7XHJcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XHJcbiAgICAgIC8vIGFkZCBsaXN0ZW5lciBvbiB0aGUgZmlyc3QgY2FsbCB3aGVuIHRoZSBkb2N1bWVudCBpcyBpbiBsb2FkaW5nIHN0YXRlXHJcbiAgICAgIGlmICghRE9NQ29udGVudExvYWRlZENhbGxiYWNrcy5sZW5ndGgpIHtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIERPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjYWxsYmFjaygpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGlzUlRMID0gKCkgPT4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRpciA9PT0gJ3J0bCc7XHJcblxyXG4gIGNvbnN0IGRlZmluZUpRdWVyeVBsdWdpbiA9IHBsdWdpbiA9PiB7XHJcbiAgICBvbkRPTUNvbnRlbnRMb2FkZWQoKCkgPT4ge1xyXG4gICAgICBjb25zdCAkID0gZ2V0alF1ZXJ5KCk7XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG5cclxuICAgICAgaWYgKCQpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gcGx1Z2luLk5BTUU7XHJcbiAgICAgICAgY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltuYW1lXTtcclxuICAgICAgICAkLmZuW25hbWVdID0gcGx1Z2luLmpRdWVyeUludGVyZmFjZTtcclxuICAgICAgICAkLmZuW25hbWVdLkNvbnN0cnVjdG9yID0gcGx1Z2luO1xyXG5cclxuICAgICAgICAkLmZuW25hbWVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XHJcbiAgICAgICAgICAkLmZuW25hbWVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xyXG4gICAgICAgICAgcmV0dXJuIHBsdWdpbi5qUXVlcnlJbnRlcmZhY2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZXhlY3V0ZSA9IGNhbGxiYWNrID0+IHtcclxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgY2FsbGJhY2soKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uID0gKGNhbGxiYWNrLCB0cmFuc2l0aW9uRWxlbWVudCwgd2FpdEZvclRyYW5zaXRpb24gPSB0cnVlKSA9PiB7XHJcbiAgICBpZiAoIXdhaXRGb3JUcmFuc2l0aW9uKSB7XHJcbiAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZHVyYXRpb25QYWRkaW5nID0gNTtcclxuICAgIGNvbnN0IGVtdWxhdGVkRHVyYXRpb24gPSBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0cmFuc2l0aW9uRWxlbWVudCkgKyBkdXJhdGlvblBhZGRpbmc7XHJcbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlciA9ICh7XHJcbiAgICAgIHRhcmdldFxyXG4gICAgfSkgPT4ge1xyXG4gICAgICBpZiAodGFyZ2V0ICE9PSB0cmFuc2l0aW9uRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgdHJhbnNpdGlvbkVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgaGFuZGxlcik7XHJcbiAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xyXG4gICAgfTtcclxuXHJcbiAgICB0cmFuc2l0aW9uRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFRSQU5TSVRJT05fRU5ELCBoYW5kbGVyKTtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBpZiAoIWNhbGxlZCkge1xyXG4gICAgICAgIHRyaWdnZXJUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25FbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgfSwgZW11bGF0ZWREdXJhdGlvbik7XHJcbiAgfTtcclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIHByZXZpb3VzL25leHQgZWxlbWVudCBvZiBhIGxpc3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FycmF5fSBsaXN0ICAgIFRoZSBsaXN0IG9mIGVsZW1lbnRzXHJcbiAgICogQHBhcmFtIGFjdGl2ZUVsZW1lbnQgICBUaGUgYWN0aXZlIGVsZW1lbnRcclxuICAgKiBAcGFyYW0gc2hvdWxkR2V0TmV4dCAgIENob29zZSB0byBnZXQgbmV4dCBvciBwcmV2aW91cyBlbGVtZW50XHJcbiAgICogQHBhcmFtIGlzQ3ljbGVBbGxvd2VkXHJcbiAgICogQHJldHVybiB7RWxlbWVudHxlbGVtfSBUaGUgcHJvcGVyIGVsZW1lbnRcclxuICAgKi9cclxuXHJcblxyXG4gIGNvbnN0IGdldE5leHRBY3RpdmVFbGVtZW50ID0gKGxpc3QsIGFjdGl2ZUVsZW1lbnQsIHNob3VsZEdldE5leHQsIGlzQ3ljbGVBbGxvd2VkKSA9PiB7XHJcbiAgICBjb25zdCBsaXN0TGVuZ3RoID0gbGlzdC5sZW5ndGg7XHJcbiAgICBsZXQgaW5kZXggPSBsaXN0LmluZGV4T2YoYWN0aXZlRWxlbWVudCk7IC8vIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0IHJldHVybiBhbiBlbGVtZW50XHJcbiAgICAvLyBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBhbmQgaWYgY3ljbGUgaXMgYWxsb3dlZFxyXG5cclxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgcmV0dXJuICFzaG91bGRHZXROZXh0ICYmIGlzQ3ljbGVBbGxvd2VkID8gbGlzdFtsaXN0TGVuZ3RoIC0gMV0gOiBsaXN0WzBdO1xyXG4gICAgfVxyXG5cclxuICAgIGluZGV4ICs9IHNob3VsZEdldE5leHQgPyAxIDogLTE7XHJcblxyXG4gICAgaWYgKGlzQ3ljbGVBbGxvd2VkKSB7XHJcbiAgICAgIGluZGV4ID0gKGluZGV4ICsgbGlzdExlbmd0aCkgJSBsaXN0TGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsaXN0W01hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCBsaXN0TGVuZ3RoIC0gMSkpXTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogZG9tL2V2ZW50LWhhbmRsZXIuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBuYW1lc3BhY2VSZWdleCA9IC9bXi5dKig/PVxcLi4qKVxcLnwuKi87XHJcbiAgY29uc3Qgc3RyaXBOYW1lUmVnZXggPSAvXFwuLiovO1xyXG4gIGNvbnN0IHN0cmlwVWlkUmVnZXggPSAvOjpcXGQrJC87XHJcbiAgY29uc3QgZXZlbnRSZWdpc3RyeSA9IHt9OyAvLyBFdmVudHMgc3RvcmFnZVxyXG5cclxuICBsZXQgdWlkRXZlbnQgPSAxO1xyXG4gIGNvbnN0IGN1c3RvbUV2ZW50cyA9IHtcclxuICAgIG1vdXNlZW50ZXI6ICdtb3VzZW92ZXInLFxyXG4gICAgbW91c2VsZWF2ZTogJ21vdXNlb3V0J1xyXG4gIH07XHJcbiAgY29uc3QgbmF0aXZlRXZlbnRzID0gbmV3IFNldChbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ2NvbnRleHRtZW51JywgJ21vdXNld2hlZWwnLCAnRE9NTW91c2VTY3JvbGwnLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ21vdXNlbW92ZScsICdzZWxlY3RzdGFydCcsICdzZWxlY3RlbmQnLCAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCcsICdvcmllbnRhdGlvbmNoYW5nZScsICd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICd0b3VjaGVuZCcsICd0b3VjaGNhbmNlbCcsICdwb2ludGVyZG93bicsICdwb2ludGVybW92ZScsICdwb2ludGVydXAnLCAncG9pbnRlcmxlYXZlJywgJ3BvaW50ZXJjYW5jZWwnLCAnZ2VzdHVyZXN0YXJ0JywgJ2dlc3R1cmVjaGFuZ2UnLCAnZ2VzdHVyZWVuZCcsICdmb2N1cycsICdibHVyJywgJ2NoYW5nZScsICdyZXNldCcsICdzZWxlY3QnLCAnc3VibWl0JywgJ2ZvY3VzaW4nLCAnZm9jdXNvdXQnLCAnbG9hZCcsICd1bmxvYWQnLCAnYmVmb3JldW5sb2FkJywgJ3Jlc2l6ZScsICdtb3ZlJywgJ0RPTUNvbnRlbnRMb2FkZWQnLCAncmVhZHlzdGF0ZWNoYW5nZScsICdlcnJvcicsICdhYm9ydCcsICdzY3JvbGwnXSk7XHJcbiAgLyoqXHJcbiAgICogUHJpdmF0ZSBtZXRob2RzXHJcbiAgICovXHJcblxyXG4gIGZ1bmN0aW9uIG1ha2VFdmVudFVpZChlbGVtZW50LCB1aWQpIHtcclxuICAgIHJldHVybiB1aWQgJiYgYCR7dWlkfTo6JHt1aWRFdmVudCsrfWAgfHwgZWxlbWVudC51aWRFdmVudCB8fCB1aWRFdmVudCsrO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0RWxlbWVudEV2ZW50cyhlbGVtZW50KSB7XHJcbiAgICBjb25zdCB1aWQgPSBtYWtlRXZlbnRVaWQoZWxlbWVudCk7XHJcbiAgICBlbGVtZW50LnVpZEV2ZW50ID0gdWlkO1xyXG4gICAgZXZlbnRSZWdpc3RyeVt1aWRdID0gZXZlbnRSZWdpc3RyeVt1aWRdIHx8IHt9O1xyXG4gICAgcmV0dXJuIGV2ZW50UmVnaXN0cnlbdWlkXTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGJvb3RzdHJhcEhhbmRsZXIoZWxlbWVudCwgZm4pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XHJcbiAgICAgIGh5ZHJhdGVPYmooZXZlbnQsIHtcclxuICAgICAgICBkZWxlZ2F0ZVRhcmdldDogZWxlbWVudFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChoYW5kbGVyLm9uZU9mZikge1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgZXZlbnQudHlwZSwgZm4pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZm4uYXBwbHkoZWxlbWVudCwgW2V2ZW50XSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgc2VsZWN0b3IsIGZuKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xyXG4gICAgICBjb25zdCBkb21FbGVtZW50cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XHJcblxyXG4gICAgICBmb3IgKGxldCB7XHJcbiAgICAgICAgdGFyZ2V0XHJcbiAgICAgIH0gPSBldmVudDsgdGFyZ2V0ICYmIHRhcmdldCAhPT0gdGhpczsgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGRvbUVsZW1lbnQgb2YgZG9tRWxlbWVudHMpIHtcclxuICAgICAgICAgIGlmIChkb21FbGVtZW50ICE9PSB0YXJnZXQpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaHlkcmF0ZU9iaihldmVudCwge1xyXG4gICAgICAgICAgICBkZWxlZ2F0ZVRhcmdldDogdGFyZ2V0XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpZiAoaGFuZGxlci5vbmVPZmYpIHtcclxuICAgICAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCBldmVudC50eXBlLCBzZWxlY3RvciwgZm4pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0YXJnZXQsIFtldmVudF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZpbmRIYW5kbGVyKGV2ZW50cywgY2FsbGFibGUsIGRlbGVnYXRpb25TZWxlY3RvciA9IG51bGwpIHtcclxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKGV2ZW50cykuZmluZChldmVudCA9PiBldmVudC5jYWxsYWJsZSA9PT0gY2FsbGFibGUgJiYgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yID09PSBkZWxlZ2F0aW9uU2VsZWN0b3IpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XHJcbiAgICBjb25zdCBpc0RlbGVnYXRlZCA9IHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJzsgLy8gdG9kbzogdG9vbHRpcCBwYXNzZXMgYGZhbHNlYCBpbnN0ZWFkIG9mIHNlbGVjdG9yLCBzbyB3ZSBuZWVkIHRvIGNoZWNrXHJcblxyXG4gICAgY29uc3QgY2FsbGFibGUgPSBpc0RlbGVnYXRlZCA/IGRlbGVnYXRpb25GdW5jdGlvbiA6IGhhbmRsZXIgfHwgZGVsZWdhdGlvbkZ1bmN0aW9uO1xyXG4gICAgbGV0IHR5cGVFdmVudCA9IGdldFR5cGVFdmVudChvcmlnaW5hbFR5cGVFdmVudCk7XHJcblxyXG4gICAgaWYgKCFuYXRpdmVFdmVudHMuaGFzKHR5cGVFdmVudCkpIHtcclxuICAgICAgdHlwZUV2ZW50ID0gb3JpZ2luYWxUeXBlRXZlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtpc0RlbGVnYXRlZCwgY2FsbGFibGUsIHR5cGVFdmVudF07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZGRIYW5kbGVyKGVsZW1lbnQsIG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24sIG9uZU9mZikge1xyXG4gICAgaWYgKHR5cGVvZiBvcmlnaW5hbFR5cGVFdmVudCAhPT0gJ3N0cmluZycgfHwgIWVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdID0gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKTsgLy8gaW4gY2FzZSBvZiBtb3VzZWVudGVyIG9yIG1vdXNlbGVhdmUgd3JhcCB0aGUgaGFuZGxlciB3aXRoaW4gYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBmb3IgaXRzIERPTSBwb3NpdGlvblxyXG4gICAgLy8gdGhpcyBwcmV2ZW50cyB0aGUgaGFuZGxlciBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgdGhlIHNhbWUgd2F5IGFzIG1vdXNlb3ZlciBvciBtb3VzZW91dCBkb2VzXHJcblxyXG4gICAgaWYgKG9yaWdpbmFsVHlwZUV2ZW50IGluIGN1c3RvbUV2ZW50cykge1xyXG4gICAgICBjb25zdCB3cmFwRnVuY3Rpb24gPSBmbiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgaWYgKCFldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQgIT09IGV2ZW50LmRlbGVnYXRlVGFyZ2V0ICYmICFldmVudC5kZWxlZ2F0ZVRhcmdldC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNhbGxhYmxlID0gd3JhcEZ1bmN0aW9uKGNhbGxhYmxlKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBldmVudHMgPSBnZXRFbGVtZW50RXZlbnRzKGVsZW1lbnQpO1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBldmVudHNbdHlwZUV2ZW50XSB8fCAoZXZlbnRzW3R5cGVFdmVudF0gPSB7fSk7XHJcbiAgICBjb25zdCBwcmV2aW91c0Z1bmN0aW9uID0gZmluZEhhbmRsZXIoaGFuZGxlcnMsIGNhbGxhYmxlLCBpc0RlbGVnYXRlZCA/IGhhbmRsZXIgOiBudWxsKTtcclxuXHJcbiAgICBpZiAocHJldmlvdXNGdW5jdGlvbikge1xyXG4gICAgICBwcmV2aW91c0Z1bmN0aW9uLm9uZU9mZiA9IHByZXZpb3VzRnVuY3Rpb24ub25lT2ZmICYmIG9uZU9mZjtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHVpZCA9IG1ha2VFdmVudFVpZChjYWxsYWJsZSwgb3JpZ2luYWxUeXBlRXZlbnQucmVwbGFjZShuYW1lc3BhY2VSZWdleCwgJycpKTtcclxuICAgIGNvbnN0IGZuID0gaXNEZWxlZ2F0ZWQgPyBib290c3RyYXBEZWxlZ2F0aW9uSGFuZGxlcihlbGVtZW50LCBoYW5kbGVyLCBjYWxsYWJsZSkgOiBib290c3RyYXBIYW5kbGVyKGVsZW1lbnQsIGNhbGxhYmxlKTtcclxuICAgIGZuLmRlbGVnYXRpb25TZWxlY3RvciA9IGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGw7XHJcbiAgICBmbi5jYWxsYWJsZSA9IGNhbGxhYmxlO1xyXG4gICAgZm4ub25lT2ZmID0gb25lT2ZmO1xyXG4gICAgZm4udWlkRXZlbnQgPSB1aWQ7XHJcbiAgICBoYW5kbGVyc1t1aWRdID0gZm47XHJcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZUV2ZW50LCBmbiwgaXNEZWxlZ2F0ZWQpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvblNlbGVjdG9yKSB7XHJcbiAgICBjb25zdCBmbiA9IGZpbmRIYW5kbGVyKGV2ZW50c1t0eXBlRXZlbnRdLCBoYW5kbGVyLCBkZWxlZ2F0aW9uU2VsZWN0b3IpO1xyXG5cclxuICAgIGlmICghZm4pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlRXZlbnQsIGZuLCBCb29sZWFuKGRlbGVnYXRpb25TZWxlY3RvcikpO1xyXG4gICAgZGVsZXRlIGV2ZW50c1t0eXBlRXZlbnRdW2ZuLnVpZEV2ZW50XTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZU5hbWVzcGFjZWRIYW5kbGVycyhlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgbmFtZXNwYWNlKSB7XHJcbiAgICBjb25zdCBzdG9yZUVsZW1lbnRFdmVudCA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IHt9O1xyXG5cclxuICAgIGZvciAoY29uc3QgaGFuZGxlcktleSBvZiBPYmplY3Qua2V5cyhzdG9yZUVsZW1lbnRFdmVudCkpIHtcclxuICAgICAgaWYgKGhhbmRsZXJLZXkuaW5jbHVkZXMobmFtZXNwYWNlKSkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gc3RvcmVFbGVtZW50RXZlbnRbaGFuZGxlcktleV07XHJcbiAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgZXZlbnQuY2FsbGFibGUsIGV2ZW50LmRlbGVnYXRpb25TZWxlY3Rvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFR5cGVFdmVudChldmVudCkge1xyXG4gICAgLy8gYWxsb3cgdG8gZ2V0IHRoZSBuYXRpdmUgZXZlbnRzIGZyb20gbmFtZXNwYWNlZCBldmVudHMgKCdjbGljay5icy5idXR0b24nIC0tPiAnY2xpY2snKVxyXG4gICAgZXZlbnQgPSBldmVudC5yZXBsYWNlKHN0cmlwTmFtZVJlZ2V4LCAnJyk7XHJcbiAgICByZXR1cm4gY3VzdG9tRXZlbnRzW2V2ZW50XSB8fCBldmVudDtcclxuICB9XHJcblxyXG4gIGNvbnN0IEV2ZW50SGFuZGxlciA9IHtcclxuICAgIG9uKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcclxuICAgICAgYWRkSGFuZGxlcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCBmYWxzZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9uZShlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XHJcbiAgICAgIGFkZEhhbmRsZXIoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbiwgdHJ1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG9mZihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUeXBlRXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdID0gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKTtcclxuICAgICAgY29uc3QgaW5OYW1lc3BhY2UgPSB0eXBlRXZlbnQgIT09IG9yaWdpbmFsVHlwZUV2ZW50O1xyXG4gICAgICBjb25zdCBldmVudHMgPSBnZXRFbGVtZW50RXZlbnRzKGVsZW1lbnQpO1xyXG4gICAgICBjb25zdCBzdG9yZUVsZW1lbnRFdmVudCA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IHt9O1xyXG4gICAgICBjb25zdCBpc05hbWVzcGFjZSA9IG9yaWdpbmFsVHlwZUV2ZW50LnN0YXJ0c1dpdGgoJy4nKTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgY2FsbGFibGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLy8gU2ltcGxlc3QgY2FzZTogaGFuZGxlciBpcyBwYXNzZWQsIHJlbW92ZSB0aGF0IGxpc3RlbmVyIE9OTFkuXHJcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhzdG9yZUVsZW1lbnRFdmVudCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBjYWxsYWJsZSwgaXNEZWxlZ2F0ZWQgPyBoYW5kbGVyIDogbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNOYW1lc3BhY2UpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnRFdmVudCBvZiBPYmplY3Qua2V5cyhldmVudHMpKSB7XHJcbiAgICAgICAgICByZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMoZWxlbWVudCwgZXZlbnRzLCBlbGVtZW50RXZlbnQsIG9yaWdpbmFsVHlwZUV2ZW50LnNsaWNlKDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoY29uc3Qga2V5SGFuZGxlcnMgb2YgT2JqZWN0LmtleXMoc3RvcmVFbGVtZW50RXZlbnQpKSB7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlcktleSA9IGtleUhhbmRsZXJzLnJlcGxhY2Uoc3RyaXBVaWRSZWdleCwgJycpO1xyXG5cclxuICAgICAgICBpZiAoIWluTmFtZXNwYWNlIHx8IG9yaWdpbmFsVHlwZUV2ZW50LmluY2x1ZGVzKGhhbmRsZXJLZXkpKSB7XHJcbiAgICAgICAgICBjb25zdCBldmVudCA9IHN0b3JlRWxlbWVudEV2ZW50W2tleUhhbmRsZXJzXTtcclxuICAgICAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGV2ZW50LmNhbGxhYmxlLCBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB0cmlnZ2VyKGVsZW1lbnQsIGV2ZW50LCBhcmdzKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0ICQgPSBnZXRqUXVlcnkoKTtcclxuICAgICAgY29uc3QgdHlwZUV2ZW50ID0gZ2V0VHlwZUV2ZW50KGV2ZW50KTtcclxuICAgICAgY29uc3QgaW5OYW1lc3BhY2UgPSBldmVudCAhPT0gdHlwZUV2ZW50O1xyXG4gICAgICBsZXQgalF1ZXJ5RXZlbnQgPSBudWxsO1xyXG4gICAgICBsZXQgYnViYmxlcyA9IHRydWU7XHJcbiAgICAgIGxldCBuYXRpdmVEaXNwYXRjaCA9IHRydWU7XHJcbiAgICAgIGxldCBkZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XHJcblxyXG4gICAgICBpZiAoaW5OYW1lc3BhY2UgJiYgJCkge1xyXG4gICAgICAgIGpRdWVyeUV2ZW50ID0gJC5FdmVudChldmVudCwgYXJncyk7XHJcbiAgICAgICAgJChlbGVtZW50KS50cmlnZ2VyKGpRdWVyeUV2ZW50KTtcclxuICAgICAgICBidWJibGVzID0gIWpRdWVyeUV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7XHJcbiAgICAgICAgbmF0aXZlRGlzcGF0Y2ggPSAhalF1ZXJ5RXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKTtcclxuICAgICAgICBkZWZhdWx0UHJldmVudGVkID0galF1ZXJ5RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBldnQgPSBuZXcgRXZlbnQoZXZlbnQsIHtcclxuICAgICAgICBidWJibGVzLFxyXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIGV2dCA9IGh5ZHJhdGVPYmooZXZ0LCBhcmdzKTtcclxuXHJcbiAgICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChuYXRpdmVEaXNwYXRjaCkge1xyXG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZXZ0LmRlZmF1bHRQcmV2ZW50ZWQgJiYgalF1ZXJ5RXZlbnQpIHtcclxuICAgICAgICBqUXVlcnlFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZXZ0O1xyXG4gICAgfVxyXG5cclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBoeWRyYXRlT2JqKG9iaiwgbWV0YSkge1xyXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWV0YSB8fCB7fSkpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9iajtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwICh2NS4yLjMpOiBkb20vZGF0YS5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG4gIGNvbnN0IGVsZW1lbnRNYXAgPSBuZXcgTWFwKCk7XHJcbiAgY29uc3QgRGF0YSA9IHtcclxuICAgIHNldChlbGVtZW50LCBrZXksIGluc3RhbmNlKSB7XHJcbiAgICAgIGlmICghZWxlbWVudE1hcC5oYXMoZWxlbWVudCkpIHtcclxuICAgICAgICBlbGVtZW50TWFwLnNldChlbGVtZW50LCBuZXcgTWFwKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBpbnN0YW5jZU1hcCA9IGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpOyAvLyBtYWtlIGl0IGNsZWFyIHdlIG9ubHkgd2FudCBvbmUgaW5zdGFuY2UgcGVyIGVsZW1lbnRcclxuICAgICAgLy8gY2FuIGJlIHJlbW92ZWQgbGF0ZXIgd2hlbiBtdWx0aXBsZSBrZXkvaW5zdGFuY2VzIGFyZSBmaW5lIHRvIGJlIHVzZWRcclxuXHJcbiAgICAgIGlmICghaW5zdGFuY2VNYXAuaGFzKGtleSkgJiYgaW5zdGFuY2VNYXAuc2l6ZSAhPT0gMCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgQm9vdHN0cmFwIGRvZXNuJ3QgYWxsb3cgbW9yZSB0aGFuIG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudC4gQm91bmQgaW5zdGFuY2U6ICR7QXJyYXkuZnJvbShpbnN0YW5jZU1hcC5rZXlzKCkpWzBdfS5gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGluc3RhbmNlTWFwLnNldChrZXksIGluc3RhbmNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0KGVsZW1lbnQsIGtleSkge1xyXG4gICAgICBpZiAoZWxlbWVudE1hcC5oYXMoZWxlbWVudCkpIHtcclxuICAgICAgICByZXR1cm4gZWxlbWVudE1hcC5nZXQoZWxlbWVudCkuZ2V0KGtleSkgfHwgbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZShlbGVtZW50LCBrZXkpIHtcclxuICAgICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgaW5zdGFuY2VNYXAgPSBlbGVtZW50TWFwLmdldChlbGVtZW50KTtcclxuICAgICAgaW5zdGFuY2VNYXAuZGVsZXRlKGtleSk7IC8vIGZyZWUgdXAgZWxlbWVudCByZWZlcmVuY2VzIGlmIHRoZXJlIGFyZSBubyBpbnN0YW5jZXMgbGVmdCBmb3IgYW4gZWxlbWVudFxyXG5cclxuICAgICAgaWYgKGluc3RhbmNlTWFwLnNpemUgPT09IDApIHtcclxuICAgICAgICBlbGVtZW50TWFwLmRlbGV0ZShlbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogZG9tL21hbmlwdWxhdG9yLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuICBmdW5jdGlvbiBub3JtYWxpemVEYXRhKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09ICd0cnVlJykge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyKHZhbHVlKS50b1N0cmluZygpKSB7XHJcbiAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09ICdudWxsJykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XHJcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZURhdGFLZXkoa2V5KSB7XHJcbiAgICByZXR1cm4ga2V5LnJlcGxhY2UoL1tBLVpdL2csIGNociA9PiBgLSR7Y2hyLnRvTG93ZXJDYXNlKCl9YCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBNYW5pcHVsYXRvciA9IHtcclxuICAgIHNldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5LCB2YWx1ZSkge1xyXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gLCB2YWx1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5KSB7XHJcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGBkYXRhLWJzLSR7bm9ybWFsaXplRGF0YUtleShrZXkpfWApO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXREYXRhQXR0cmlidXRlcyhlbGVtZW50KSB7XHJcbiAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xyXG4gICAgICBjb25zdCBic0tleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50LmRhdGFzZXQpLmZpbHRlcihrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2JzJykgJiYgIWtleS5zdGFydHNXaXRoKCdic0NvbmZpZycpKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGJzS2V5cykge1xyXG4gICAgICAgIGxldCBwdXJlS2V5ID0ga2V5LnJlcGxhY2UoL15icy8sICcnKTtcclxuICAgICAgICBwdXJlS2V5ID0gcHVyZUtleS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHB1cmVLZXkuc2xpY2UoMSwgcHVyZUtleS5sZW5ndGgpO1xyXG4gICAgICAgIGF0dHJpYnV0ZXNbcHVyZUtleV0gPSBub3JtYWxpemVEYXRhKGVsZW1lbnQuZGF0YXNldFtrZXldKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5KSB7XHJcbiAgICAgIHJldHVybiBub3JtYWxpemVEYXRhKGVsZW1lbnQuZ2V0QXR0cmlidXRlKGBkYXRhLWJzLSR7bm9ybWFsaXplRGF0YUtleShrZXkpfWApKTtcclxuICAgIH1cclxuXHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IHV0aWwvY29uZmlnLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIENvbmZpZyB7XHJcbiAgICAvLyBHZXR0ZXJzXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIHRvIGltcGxlbWVudCB0aGUgc3RhdGljIG1ldGhvZCBcIk5BTUVcIiwgZm9yIGVhY2ggY29tcG9uZW50IScpO1xyXG4gICAgfVxyXG5cclxuICAgIF9nZXRDb25maWcoY29uZmlnKSB7XHJcbiAgICAgIGNvbmZpZyA9IHRoaXMuX21lcmdlQ29uZmlnT2JqKGNvbmZpZyk7XHJcbiAgICAgIGNvbmZpZyA9IHRoaXMuX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKTtcclxuXHJcbiAgICAgIHRoaXMuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xyXG5cclxuICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxuXHJcbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcclxuICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxuXHJcbiAgICBfbWVyZ2VDb25maWdPYmooY29uZmlnLCBlbGVtZW50KSB7XHJcbiAgICAgIGNvbnN0IGpzb25Db25maWcgPSBpc0VsZW1lbnQkMShlbGVtZW50KSA/IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwgJ2NvbmZpZycpIDoge307IC8vIHRyeSB0byBwYXJzZVxyXG5cclxuICAgICAgcmV0dXJuIHsgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxyXG4gICAgICAgIC4uLih0eXBlb2YganNvbkNvbmZpZyA9PT0gJ29iamVjdCcgPyBqc29uQ29uZmlnIDoge30pLFxyXG4gICAgICAgIC4uLihpc0VsZW1lbnQkMShlbGVtZW50KSA/IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKGVsZW1lbnQpIDoge30pLFxyXG4gICAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IHt9KVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIF90eXBlQ2hlY2tDb25maWcoY29uZmlnLCBjb25maWdUeXBlcyA9IHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpIHtcclxuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBPYmplY3Qua2V5cyhjb25maWdUeXBlcykpIHtcclxuICAgICAgICBjb25zdCBleHBlY3RlZFR5cGVzID0gY29uZmlnVHlwZXNbcHJvcGVydHldO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gY29uZmlnW3Byb3BlcnR5XTtcclxuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSBpc0VsZW1lbnQkMSh2YWx1ZSkgPyAnZWxlbWVudCcgOiB0b1R5cGUodmFsdWUpO1xyXG5cclxuICAgICAgICBpZiAoIW5ldyBSZWdFeHAoZXhwZWN0ZWRUeXBlcykudGVzdCh2YWx1ZVR5cGUpKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3RoaXMuY29uc3RydWN0b3IuTkFNRS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwiJHtwcm9wZXJ0eX1cIiBwcm92aWRlZCB0eXBlIFwiJHt2YWx1ZVR5cGV9XCIgYnV0IGV4cGVjdGVkIHR5cGUgXCIke2V4cGVjdGVkVHlwZXN9XCIuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IGJhc2UtY29tcG9uZW50LmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgVkVSU0lPTiA9ICc1LjIuMyc7XHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBCYXNlQ29tcG9uZW50IGV4dGVuZHMgQ29uZmlnIHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICBlbGVtZW50ID0gZ2V0RWxlbWVudChlbGVtZW50KTtcclxuXHJcbiAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xyXG4gICAgICBEYXRhLnNldCh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKTtcclxuICAgIH0gLy8gUHVibGljXHJcblxyXG5cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIERhdGEucmVtb3ZlKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVkpO1xyXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRVZFTlRfS0VZKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XHJcbiAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9xdWV1ZUNhbGxiYWNrKGNhbGxiYWNrLCBlbGVtZW50LCBpc0FuaW1hdGVkID0gdHJ1ZSkge1xyXG4gICAgICBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uKGNhbGxiYWNrLCBlbGVtZW50LCBpc0FuaW1hdGVkKTtcclxuICAgIH1cclxuXHJcbiAgICBfZ2V0Q29uZmlnKGNvbmZpZykge1xyXG4gICAgICBjb25maWcgPSB0aGlzLl9tZXJnZUNvbmZpZ09iaihjb25maWcsIHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgICBjb25maWcgPSB0aGlzLl9jb25maWdBZnRlck1lcmdlKGNvbmZpZyk7XHJcblxyXG4gICAgICB0aGlzLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKTtcclxuXHJcbiAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9IC8vIFN0YXRpY1xyXG5cclxuXHJcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gRGF0YS5nZXQoZ2V0RWxlbWVudChlbGVtZW50KSwgdGhpcy5EQVRBX0tFWSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCwgY29uZmlnID0ge30pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoZWxlbWVudCkgfHwgbmV3IHRoaXMoZWxlbWVudCwgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XHJcbiAgICAgIHJldHVybiBWRVJTSU9OO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XHJcbiAgICAgIHJldHVybiBgYnMuJHt0aGlzLk5BTUV9YDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0IEVWRU5UX0tFWSgpIHtcclxuICAgICAgcmV0dXJuIGAuJHt0aGlzLkRBVEFfS0VZfWA7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGV2ZW50TmFtZShuYW1lKSB7XHJcbiAgICAgIHJldHVybiBgJHtuYW1lfSR7dGhpcy5FVkVOVF9LRVl9YDtcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogdXRpbC9jb21wb25lbnQtZnVuY3Rpb25zLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcbiAgY29uc3QgZW5hYmxlRGlzbWlzc1RyaWdnZXIgPSAoY29tcG9uZW50LCBtZXRob2QgPSAnaGlkZScpID0+IHtcclxuICAgIGNvbnN0IGNsaWNrRXZlbnQgPSBgY2xpY2suZGlzbWlzcyR7Y29tcG9uZW50LkVWRU5UX0tFWX1gO1xyXG4gICAgY29uc3QgbmFtZSA9IGNvbXBvbmVudC5OQU1FO1xyXG4gICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBjbGlja0V2ZW50LCBgW2RhdGEtYnMtZGlzbWlzcz1cIiR7bmFtZX1cIl1gLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpIHx8IHRoaXMuY2xvc2VzdChgLiR7bmFtZX1gKTtcclxuICAgICAgY29uc3QgaW5zdGFuY2UgPSBjb21wb25lbnQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpOyAvLyBNZXRob2QgYXJndW1lbnQgaXMgbGVmdCwgZm9yIEFsZXJ0IGFuZCBvbmx5LCBhcyBpdCBkb2Vzbid0IGltcGxlbWVudCB0aGUgJ2hpZGUnIG1ldGhvZFxyXG5cclxuICAgICAgaW5zdGFuY2VbbWV0aG9kXSgpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IGFsZXJ0LmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgTkFNRSRmID0gJ2FsZXJ0JztcclxuICBjb25zdCBEQVRBX0tFWSRhID0gJ2JzLmFsZXJ0JztcclxuICBjb25zdCBFVkVOVF9LRVkkYiA9IGAuJHtEQVRBX0tFWSRhfWA7XHJcbiAgY29uc3QgRVZFTlRfQ0xPU0UgPSBgY2xvc2Uke0VWRU5UX0tFWSRifWA7XHJcbiAgY29uc3QgRVZFTlRfQ0xPU0VEID0gYGNsb3NlZCR7RVZFTlRfS0VZJGJ9YDtcclxuICBjb25zdCBDTEFTU19OQU1FX0ZBREUkNSA9ICdmYWRlJztcclxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckOCA9ICdzaG93JztcclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIEFsZXJ0IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAvLyBHZXR0ZXJzXHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJGY7XHJcbiAgICB9IC8vIFB1YmxpY1xyXG5cclxuXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgY29uc3QgY2xvc2VFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMT1NFKTtcclxuXHJcbiAgICAgIGlmIChjbG9zZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckOCk7XHJcblxyXG4gICAgICBjb25zdCBpc0FuaW1hdGVkID0gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDUpO1xyXG5cclxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudCgpLCB0aGlzLl9lbGVtZW50LCBpc0FuaW1hdGVkKTtcclxuICAgIH0gLy8gUHJpdmF0ZVxyXG5cclxuXHJcbiAgICBfZGVzdHJveUVsZW1lbnQoKSB7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCk7XHJcblxyXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTE9TRUQpO1xyXG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuICAgIH0gLy8gU3RhdGljXHJcblxyXG5cclxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBBbGVydC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gIH1cclxuICAvKipcclxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxyXG4gICAqL1xyXG5cclxuXHJcbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoQWxlcnQsICdjbG9zZScpO1xyXG4gIC8qKlxyXG4gICAqIGpRdWVyeVxyXG4gICAqL1xyXG5cclxuICBkZWZpbmVKUXVlcnlQbHVnaW4oQWxlcnQpO1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogYnV0dG9uLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgTkFNRSRlID0gJ2J1dHRvbic7XHJcbiAgY29uc3QgREFUQV9LRVkkOSA9ICdicy5idXR0b24nO1xyXG4gIGNvbnN0IEVWRU5UX0tFWSRhID0gYC4ke0RBVEFfS0VZJDl9YDtcclxuICBjb25zdCBEQVRBX0FQSV9LRVkkNiA9ICcuZGF0YS1hcGknO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFJDMgPSAnYWN0aXZlJztcclxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1ID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImJ1dHRvblwiXSc7XHJcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNiA9IGBjbGljayR7RVZFTlRfS0VZJGF9JHtEQVRBX0FQSV9LRVkkNn1gO1xyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgQnV0dG9uIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAvLyBHZXR0ZXJzXHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJGU7XHJcbiAgICB9IC8vIFB1YmxpY1xyXG5cclxuXHJcbiAgICB0b2dnbGUoKSB7XHJcbiAgICAgIC8vIFRvZ2dsZSBjbGFzcyBhbmQgc3luYyB0aGUgYGFyaWEtcHJlc3NlZGAgYXR0cmlidXRlIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYC50b2dnbGUoKWAgbWV0aG9kXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXByZXNzZWQnLCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoQ0xBU1NfTkFNRV9BQ1RJVkUkMykpO1xyXG4gICAgfSAvLyBTdGF0aWNcclxuXHJcblxyXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IEJ1dHRvbi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnID09PSAndG9nZ2xlJykge1xyXG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXHJcbiAgICovXHJcblxyXG5cclxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDYsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUsIGV2ZW50ID0+IHtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBjb25zdCBidXR0b24gPSBldmVudC50YXJnZXQuY2xvc2VzdChTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1KTtcclxuICAgIGNvbnN0IGRhdGEgPSBCdXR0b24uZ2V0T3JDcmVhdGVJbnN0YW5jZShidXR0b24pO1xyXG4gICAgZGF0YS50b2dnbGUoKTtcclxuICB9KTtcclxuICAvKipcclxuICAgKiBqUXVlcnlcclxuICAgKi9cclxuXHJcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKEJ1dHRvbik7XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwICh2NS4yLjMpOiBkb20vc2VsZWN0b3ItZW5naW5lLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgU2VsZWN0b3JFbmdpbmUgPSB7XHJcbiAgICBmaW5kKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBbXS5jb25jYXQoLi4uRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbC5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZpbmRPbmUoc2VsZWN0b3IsIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XHJcbiAgICB9LFxyXG5cclxuICAgIGNoaWxkcmVuKGVsZW1lbnQsIHNlbGVjdG9yKSB7XHJcbiAgICAgIHJldHVybiBbXS5jb25jYXQoLi4uZWxlbWVudC5jaGlsZHJlbikuZmlsdGVyKGNoaWxkID0+IGNoaWxkLm1hdGNoZXMoc2VsZWN0b3IpKTtcclxuICAgIH0sXHJcblxyXG4gICAgcGFyZW50cyhlbGVtZW50LCBzZWxlY3Rvcikge1xyXG4gICAgICBjb25zdCBwYXJlbnRzID0gW107XHJcbiAgICAgIGxldCBhbmNlc3RvciA9IGVsZW1lbnQucGFyZW50Tm9kZS5jbG9zZXN0KHNlbGVjdG9yKTtcclxuXHJcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xyXG4gICAgICAgIHBhcmVudHMucHVzaChhbmNlc3Rvcik7XHJcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlLmNsb3Nlc3Qoc2VsZWN0b3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcGFyZW50cztcclxuICAgIH0sXHJcblxyXG4gICAgcHJldihlbGVtZW50LCBzZWxlY3Rvcikge1xyXG4gICAgICBsZXQgcHJldmlvdXMgPSBlbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XHJcblxyXG4gICAgICB3aGlsZSAocHJldmlvdXMpIHtcclxuICAgICAgICBpZiAocHJldmlvdXMubWF0Y2hlcyhzZWxlY3RvcikpIHtcclxuICAgICAgICAgIHJldHVybiBbcHJldmlvdXNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJldmlvdXMgPSBwcmV2aW91cy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFRPRE86IHRoaXMgaXMgbm93IHVudXNlZDsgcmVtb3ZlIGxhdGVyIGFsb25nIHdpdGggcHJldigpXHJcbiAgICBuZXh0KGVsZW1lbnQsIHNlbGVjdG9yKSB7XHJcbiAgICAgIGxldCBuZXh0ID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmc7XHJcblxyXG4gICAgICB3aGlsZSAobmV4dCkge1xyXG4gICAgICAgIGlmIChuZXh0Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICByZXR1cm4gW25leHRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbmV4dCA9IG5leHQubmV4dEVsZW1lbnRTaWJsaW5nO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9LFxyXG5cclxuICAgIGZvY3VzYWJsZUNoaWxkcmVuKGVsZW1lbnQpIHtcclxuICAgICAgY29uc3QgZm9jdXNhYmxlcyA9IFsnYScsICdidXR0b24nLCAnaW5wdXQnLCAndGV4dGFyZWEnLCAnc2VsZWN0JywgJ2RldGFpbHMnLCAnW3RhYmluZGV4XScsICdbY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXSddLm1hcChzZWxlY3RvciA9PiBgJHtzZWxlY3Rvcn06bm90KFt0YWJpbmRleF49XCItXCJdKWApLmpvaW4oJywnKTtcclxuICAgICAgcmV0dXJuIHRoaXMuZmluZChmb2N1c2FibGVzLCBlbGVtZW50KS5maWx0ZXIoZWwgPT4gIWlzRGlzYWJsZWQoZWwpICYmIGlzVmlzaWJsZShlbCkpO1xyXG4gICAgfVxyXG5cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogdXRpbC9zd2lwZS5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUkZCA9ICdzd2lwZSc7XHJcbiAgY29uc3QgRVZFTlRfS0VZJDkgPSAnLmJzLnN3aXBlJztcclxuICBjb25zdCBFVkVOVF9UT1VDSFNUQVJUID0gYHRvdWNoc3RhcnQke0VWRU5UX0tFWSQ5fWA7XHJcbiAgY29uc3QgRVZFTlRfVE9VQ0hNT1ZFID0gYHRvdWNobW92ZSR7RVZFTlRfS0VZJDl9YDtcclxuICBjb25zdCBFVkVOVF9UT1VDSEVORCA9IGB0b3VjaGVuZCR7RVZFTlRfS0VZJDl9YDtcclxuICBjb25zdCBFVkVOVF9QT0lOVEVSRE9XTiA9IGBwb2ludGVyZG93biR7RVZFTlRfS0VZJDl9YDtcclxuICBjb25zdCBFVkVOVF9QT0lOVEVSVVAgPSBgcG9pbnRlcnVwJHtFVkVOVF9LRVkkOX1gO1xyXG4gIGNvbnN0IFBPSU5URVJfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XHJcbiAgY29uc3QgUE9JTlRFUl9UWVBFX1BFTiA9ICdwZW4nO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfUE9JTlRFUl9FVkVOVCA9ICdwb2ludGVyLWV2ZW50JztcclxuICBjb25zdCBTV0lQRV9USFJFU0hPTEQgPSA0MDtcclxuICBjb25zdCBEZWZhdWx0JGMgPSB7XHJcbiAgICBlbmRDYWxsYmFjazogbnVsbCxcclxuICAgIGxlZnRDYWxsYmFjazogbnVsbCxcclxuICAgIHJpZ2h0Q2FsbGJhY2s6IG51bGxcclxuICB9O1xyXG4gIGNvbnN0IERlZmF1bHRUeXBlJGMgPSB7XHJcbiAgICBlbmRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKScsXHJcbiAgICBsZWZ0Q2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknLFxyXG4gICAgcmlnaHRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKSdcclxuICB9O1xyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgU3dpcGUgZXh0ZW5kcyBDb25maWcge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG5cclxuICAgICAgaWYgKCFlbGVtZW50IHx8ICFTd2lwZS5pc1N1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcclxuICAgICAgdGhpcy5fZGVsdGFYID0gMDtcclxuICAgICAgdGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMgPSBCb29sZWFuKHdpbmRvdy5Qb2ludGVyRXZlbnQpO1xyXG5cclxuICAgICAgdGhpcy5faW5pdEV2ZW50cygpO1xyXG4gICAgfSAvLyBHZXR0ZXJzXHJcblxyXG5cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHQkYztcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkYztcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJGQ7XHJcbiAgICB9IC8vIFB1YmxpY1xyXG5cclxuXHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWSQ5KTtcclxuICAgIH0gLy8gUHJpdmF0ZVxyXG5cclxuXHJcbiAgICBfc3RhcnQoZXZlbnQpIHtcclxuICAgICAgaWYgKCF0aGlzLl9zdXBwb3J0UG9pbnRlckV2ZW50cykge1xyXG4gICAgICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLl9ldmVudElzUG9pbnRlclBlblRvdWNoKGV2ZW50KSkge1xyXG4gICAgICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LmNsaWVudFg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfZW5kKGV2ZW50KSB7XHJcbiAgICAgIGlmICh0aGlzLl9ldmVudElzUG9pbnRlclBlblRvdWNoKGV2ZW50KSkge1xyXG4gICAgICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LmNsaWVudFggLSB0aGlzLl9kZWx0YVg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2hhbmRsZVN3aXBlKCk7XHJcblxyXG4gICAgICBleGVjdXRlKHRoaXMuX2NvbmZpZy5lbmRDYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgX21vdmUoZXZlbnQpIHtcclxuICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEgPyAwIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy5fZGVsdGFYO1xyXG4gICAgfVxyXG5cclxuICAgIF9oYW5kbGVTd2lwZSgpIHtcclxuICAgICAgY29uc3QgYWJzRGVsdGFYID0gTWF0aC5hYnModGhpcy5fZGVsdGFYKTtcclxuXHJcbiAgICAgIGlmIChhYnNEZWx0YVggPD0gU1dJUEVfVEhSRVNIT0xEKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBhYnNEZWx0YVggLyB0aGlzLl9kZWx0YVg7XHJcbiAgICAgIHRoaXMuX2RlbHRhWCA9IDA7XHJcblxyXG4gICAgICBpZiAoIWRpcmVjdGlvbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZXhlY3V0ZShkaXJlY3Rpb24gPiAwID8gdGhpcy5fY29uZmlnLnJpZ2h0Q2FsbGJhY2sgOiB0aGlzLl9jb25maWcubGVmdENhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICBfaW5pdEV2ZW50cygpIHtcclxuICAgICAgaWYgKHRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzKSB7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1BPSU5URVJET1dOLCBldmVudCA9PiB0aGlzLl9zdGFydChldmVudCkpO1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9QT0lOVEVSVVAsIGV2ZW50ID0+IHRoaXMuX2VuZChldmVudCkpO1xyXG5cclxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hTVEFSVCwgZXZlbnQgPT4gdGhpcy5fc3RhcnQoZXZlbnQpKTtcclxuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hNT1ZFLCBldmVudCA9PiB0aGlzLl9tb3ZlKGV2ZW50KSk7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNIRU5ELCBldmVudCA9PiB0aGlzLl9lbmQoZXZlbnQpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9ldmVudElzUG9pbnRlclBlblRvdWNoKGV2ZW50KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9zdXBwb3J0UG9pbnRlckV2ZW50cyAmJiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9QRU4gfHwgZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9UT1VDSCk7XHJcbiAgICB9IC8vIFN0YXRpY1xyXG5cclxuXHJcbiAgICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XHJcbiAgICAgIHJldHVybiAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMDtcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogY2Fyb3VzZWwuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJGMgPSAnY2Fyb3VzZWwnO1xyXG4gIGNvbnN0IERBVEFfS0VZJDggPSAnYnMuY2Fyb3VzZWwnO1xyXG4gIGNvbnN0IEVWRU5UX0tFWSQ4ID0gYC4ke0RBVEFfS0VZJDh9YDtcclxuICBjb25zdCBEQVRBX0FQSV9LRVkkNSA9ICcuZGF0YS1hcGknO1xyXG4gIGNvbnN0IEFSUk9XX0xFRlRfS0VZJDEgPSAnQXJyb3dMZWZ0JztcclxuICBjb25zdCBBUlJPV19SSUdIVF9LRVkkMSA9ICdBcnJvd1JpZ2h0JztcclxuICBjb25zdCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUID0gNTAwOyAvLyBUaW1lIGZvciBtb3VzZSBjb21wYXQgZXZlbnRzIHRvIGZpcmUgYWZ0ZXIgdG91Y2hcclxuXHJcbiAgY29uc3QgT1JERVJfTkVYVCA9ICduZXh0JztcclxuICBjb25zdCBPUkRFUl9QUkVWID0gJ3ByZXYnO1xyXG4gIGNvbnN0IERJUkVDVElPTl9MRUZUID0gJ2xlZnQnO1xyXG4gIGNvbnN0IERJUkVDVElPTl9SSUdIVCA9ICdyaWdodCc7XHJcbiAgY29uc3QgRVZFTlRfU0xJREUgPSBgc2xpZGUke0VWRU5UX0tFWSQ4fWA7XHJcbiAgY29uc3QgRVZFTlRfU0xJRCA9IGBzbGlkJHtFVkVOVF9LRVkkOH1gO1xyXG4gIGNvbnN0IEVWRU5UX0tFWURPV04kMSA9IGBrZXlkb3duJHtFVkVOVF9LRVkkOH1gO1xyXG4gIGNvbnN0IEVWRU5UX01PVVNFRU5URVIkMSA9IGBtb3VzZWVudGVyJHtFVkVOVF9LRVkkOH1gO1xyXG4gIGNvbnN0IEVWRU5UX01PVVNFTEVBVkUkMSA9IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVkkOH1gO1xyXG4gIGNvbnN0IEVWRU5UX0RSQUdfU1RBUlQgPSBgZHJhZ3N0YXJ0JHtFVkVOVF9LRVkkOH1gO1xyXG4gIGNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkkMyA9IGBsb2FkJHtFVkVOVF9LRVkkOH0ke0RBVEFfQVBJX0tFWSQ1fWA7XHJcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSA9IGBjbGljayR7RVZFTlRfS0VZJDh9JHtEQVRBX0FQSV9LRVkkNX1gO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfQ0FST1VTRUwgPSAnY2Fyb3VzZWwnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFJDIgPSAnYWN0aXZlJztcclxuICBjb25zdCBDTEFTU19OQU1FX1NMSURFID0gJ3NsaWRlJztcclxuICBjb25zdCBDTEFTU19OQU1FX0VORCA9ICdjYXJvdXNlbC1pdGVtLWVuZCc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9TVEFSVCA9ICdjYXJvdXNlbC1pdGVtLXN0YXJ0JztcclxuICBjb25zdCBDTEFTU19OQU1FX05FWFQgPSAnY2Fyb3VzZWwtaXRlbS1uZXh0JztcclxuICBjb25zdCBDTEFTU19OQU1FX1BSRVYgPSAnY2Fyb3VzZWwtaXRlbS1wcmV2JztcclxuICBjb25zdCBTRUxFQ1RPUl9BQ1RJVkUgPSAnLmFjdGl2ZSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfSVRFTSA9ICcuY2Fyb3VzZWwtaXRlbSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfQUNUSVZFX0lURU0gPSBTRUxFQ1RPUl9BQ1RJVkUgKyBTRUxFQ1RPUl9JVEVNO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0lURU1fSU1HID0gJy5jYXJvdXNlbC1pdGVtIGltZyc7XHJcbiAgY29uc3QgU0VMRUNUT1JfSU5ESUNBVE9SUyA9ICcuY2Fyb3VzZWwtaW5kaWNhdG9ycyc7XHJcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9TTElERSA9ICdbZGF0YS1icy1zbGlkZV0sIFtkYXRhLWJzLXNsaWRlLXRvXSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9SSURFID0gJ1tkYXRhLWJzLXJpZGU9XCJjYXJvdXNlbFwiXSc7XHJcbiAgY29uc3QgS0VZX1RPX0RJUkVDVElPTiA9IHtcclxuICAgIFtBUlJPV19MRUZUX0tFWSQxXTogRElSRUNUSU9OX1JJR0hULFxyXG4gICAgW0FSUk9XX1JJR0hUX0tFWSQxXTogRElSRUNUSU9OX0xFRlRcclxuICB9O1xyXG4gIGNvbnN0IERlZmF1bHQkYiA9IHtcclxuICAgIGludGVydmFsOiA1MDAwLFxyXG4gICAga2V5Ym9hcmQ6IHRydWUsXHJcbiAgICBwYXVzZTogJ2hvdmVyJyxcclxuICAgIHJpZGU6IGZhbHNlLFxyXG4gICAgdG91Y2g6IHRydWUsXHJcbiAgICB3cmFwOiB0cnVlXHJcbiAgfTtcclxuICBjb25zdCBEZWZhdWx0VHlwZSRiID0ge1xyXG4gICAgaW50ZXJ2YWw6ICcobnVtYmVyfGJvb2xlYW4pJyxcclxuICAgIC8vIFRPRE86djYgcmVtb3ZlIGJvb2xlYW4gc3VwcG9ydFxyXG4gICAga2V5Ym9hcmQ6ICdib29sZWFuJyxcclxuICAgIHBhdXNlOiAnKHN0cmluZ3xib29sZWFuKScsXHJcbiAgICByaWRlOiAnKGJvb2xlYW58c3RyaW5nKScsXHJcbiAgICB0b3VjaDogJ2Jvb2xlYW4nLFxyXG4gICAgd3JhcDogJ2Jvb2xlYW4nXHJcbiAgfTtcclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIENhcm91c2VsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcclxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcclxuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xyXG4gICAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbnVsbDtcclxuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XHJcbiAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gbnVsbDtcclxuICAgICAgdGhpcy5fc3dpcGVIZWxwZXIgPSBudWxsO1xyXG4gICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfSU5ESUNBVE9SUywgdGhpcy5fZWxlbWVudCk7XHJcblxyXG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5yaWRlID09PSBDTEFTU19OQU1FX0NBUk9VU0VMKSB7XHJcbiAgICAgICAgdGhpcy5jeWNsZSgpO1xyXG4gICAgICB9XHJcbiAgICB9IC8vIEdldHRlcnNcclxuXHJcblxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdCRiO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSRiO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgICAgcmV0dXJuIE5BTUUkYztcclxuICAgIH0gLy8gUHVibGljXHJcblxyXG5cclxuICAgIG5leHQoKSB7XHJcbiAgICAgIHRoaXMuX3NsaWRlKE9SREVSX05FWFQpO1xyXG4gICAgfVxyXG5cclxuICAgIG5leHRXaGVuVmlzaWJsZSgpIHtcclxuICAgICAgLy8gRklYTUUgVE9ETyB1c2UgYGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZWBcclxuICAgICAgLy8gRG9uJ3QgY2FsbCBuZXh0IHdoZW4gdGhlIHBhZ2UgaXNuJ3QgdmlzaWJsZVxyXG4gICAgICAvLyBvciB0aGUgY2Fyb3VzZWwgb3IgaXRzIHBhcmVudCBpc24ndCB2aXNpYmxlXHJcbiAgICAgIGlmICghZG9jdW1lbnQuaGlkZGVuICYmIGlzVmlzaWJsZSh0aGlzLl9lbGVtZW50KSkge1xyXG4gICAgICAgIHRoaXMubmV4dCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJldigpIHtcclxuICAgICAgdGhpcy5fc2xpZGUoT1JERVJfUFJFVik7XHJcbiAgICB9XHJcblxyXG4gICAgcGF1c2UoKSB7XHJcbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcclxuICAgICAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fY2xlYXJJbnRlcnZhbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGN5Y2xlKCkge1xyXG4gICAgICB0aGlzLl9jbGVhckludGVydmFsKCk7XHJcblxyXG4gICAgICB0aGlzLl91cGRhdGVJbnRlcnZhbCgpO1xyXG5cclxuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLm5leHRXaGVuVmlzaWJsZSgpLCB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xyXG4gICAgfVxyXG5cclxuICAgIF9tYXliZUVuYWJsZUN5Y2xlKCkge1xyXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5yaWRlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLmN5Y2xlKCkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5jeWNsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRvKGluZGV4KSB7XHJcbiAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXMoKTtcclxuXHJcbiAgICAgIGlmIChpbmRleCA+IGl0ZW1zLmxlbmd0aCAtIDEgfHwgaW5kZXggPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLnRvKGluZGV4KSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9nZXRBY3RpdmUoKSk7XHJcblxyXG4gICAgICBpZiAoYWN0aXZlSW5kZXggPT09IGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBvcmRlciA9IGluZGV4ID4gYWN0aXZlSW5kZXggPyBPUkRFUl9ORVhUIDogT1JERVJfUFJFVjtcclxuXHJcbiAgICAgIHRoaXMuX3NsaWRlKG9yZGVyLCBpdGVtc1tpbmRleF0pO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIGlmICh0aGlzLl9zd2lwZUhlbHBlcikge1xyXG4gICAgICAgIHRoaXMuX3N3aXBlSGVscGVyLmRpc3Bvc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gICAgfSAvLyBQcml2YXRlXHJcblxyXG5cclxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xyXG4gICAgICBjb25maWcuZGVmYXVsdEludGVydmFsID0gY29uZmlnLmludGVydmFsO1xyXG4gICAgICByZXR1cm4gY29uZmlnO1xyXG4gICAgfVxyXG5cclxuICAgIF9hZGRFdmVudExpc3RlbmVycygpIHtcclxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOJDEsIGV2ZW50ID0+IHRoaXMuX2tleWRvd24oZXZlbnQpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gJ2hvdmVyJykge1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRUVOVEVSJDEsICgpID0+IHRoaXMucGF1c2UoKSk7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFTEVBVkUkMSwgKCkgPT4gdGhpcy5fbWF5YmVFbmFibGVDeWNsZSgpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy50b3VjaCAmJiBTd2lwZS5pc1N1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgdGhpcy5fYWRkVG91Y2hFdmVudExpc3RlbmVycygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgIGZvciAoY29uc3QgaW1nIG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSVRFTV9JTUcsIHRoaXMuX2VsZW1lbnQpKSB7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKGltZywgRVZFTlRfRFJBR19TVEFSVCwgZXZlbnQgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGVuZENhbGxCYWNrID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgIT09ICdob3ZlcicpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IC8vIElmIGl0J3MgYSB0b3VjaC1lbmFibGVkIGRldmljZSwgbW91c2VlbnRlci9sZWF2ZSBhcmUgZmlyZWQgYXNcclxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSBtb3VzZSBjb21wYXRpYmlsaXR5IGV2ZW50cyBvbiBmaXJzdCB0YXAgLSB0aGUgY2Fyb3VzZWxcclxuICAgICAgICAvLyB3b3VsZCBzdG9wIGN5Y2xpbmcgdW50aWwgdXNlciB0YXBwZWQgb3V0IG9mIGl0O1xyXG4gICAgICAgIC8vIGhlcmUsIHdlIGxpc3RlbiBmb3IgdG91Y2hlbmQsIGV4cGxpY2l0bHkgcGF1c2UgdGhlIGNhcm91c2VsXHJcbiAgICAgICAgLy8gKGFzIGlmIGl0J3MgdGhlIHNlY29uZCB0aW1lIHdlIHRhcCBvbiBpdCwgbW91c2VlbnRlciBjb21wYXQgZXZlbnRcclxuICAgICAgICAvLyBpcyBOT1QgZmlyZWQpIGFuZCBhZnRlciBhIHRpbWVvdXQgKHRvIGFsbG93IGZvciBtb3VzZSBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgLy8gZXZlbnRzIHRvIGZpcmUpIHdlIGV4cGxpY2l0bHkgcmVzdGFydCBjeWNsaW5nXHJcblxyXG5cclxuICAgICAgICB0aGlzLnBhdXNlKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnRvdWNoVGltZW91dCkge1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudG91Y2hUaW1lb3V0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9tYXliZUVuYWJsZUN5Y2xlKCksIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3Qgc3dpcGVDb25maWcgPSB7XHJcbiAgICAgICAgbGVmdENhbGxiYWNrOiAoKSA9PiB0aGlzLl9zbGlkZSh0aGlzLl9kaXJlY3Rpb25Ub09yZGVyKERJUkVDVElPTl9MRUZUKSksXHJcbiAgICAgICAgcmlnaHRDYWxsYmFjazogKCkgPT4gdGhpcy5fc2xpZGUodGhpcy5fZGlyZWN0aW9uVG9PcmRlcihESVJFQ1RJT05fUklHSFQpKSxcclxuICAgICAgICBlbmRDYWxsYmFjazogZW5kQ2FsbEJhY2tcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fc3dpcGVIZWxwZXIgPSBuZXcgU3dpcGUodGhpcy5fZWxlbWVudCwgc3dpcGVDb25maWcpO1xyXG4gICAgfVxyXG5cclxuICAgIF9rZXlkb3duKGV2ZW50KSB7XHJcbiAgICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGlyZWN0aW9uID0gS0VZX1RPX0RJUkVDVElPTltldmVudC5rZXldO1xyXG5cclxuICAgICAgaWYgKGRpcmVjdGlvbikge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoZGlyZWN0aW9uKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfZ2V0SXRlbUluZGV4KGVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2dldEl0ZW1zKCkuaW5kZXhPZihlbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChpbmRleCkge1xyXG4gICAgICBpZiAoIXRoaXMuX2luZGljYXRvcnNFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBhY3RpdmVJbmRpY2F0b3IgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRSwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpO1xyXG4gICAgICBhY3RpdmVJbmRpY2F0b3IuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQyKTtcclxuICAgICAgYWN0aXZlSW5kaWNhdG9yLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50Jyk7XHJcbiAgICAgIGNvbnN0IG5ld0FjdGl2ZUluZGljYXRvciA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoYFtkYXRhLWJzLXNsaWRlLXRvPVwiJHtpbmRleH1cIl1gLCB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCk7XHJcblxyXG4gICAgICBpZiAobmV3QWN0aXZlSW5kaWNhdG9yKSB7XHJcbiAgICAgICAgbmV3QWN0aXZlSW5kaWNhdG9yLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XHJcbiAgICAgICAgbmV3QWN0aXZlSW5kaWNhdG9yLnNldEF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50JywgJ3RydWUnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF91cGRhdGVJbnRlcnZhbCgpIHtcclxuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2FjdGl2ZUVsZW1lbnQgfHwgdGhpcy5fZ2V0QWN0aXZlKCk7XHJcblxyXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGVsZW1lbnRJbnRlcnZhbCA9IE51bWJlci5wYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1pbnRlcnZhbCcpLCAxMCk7XHJcbiAgICAgIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IGVsZW1lbnRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsO1xyXG4gICAgfVxyXG5cclxuICAgIF9zbGlkZShvcmRlciwgZWxlbWVudCA9IG51bGwpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IHRoaXMuX2dldEFjdGl2ZSgpO1xyXG5cclxuICAgICAgY29uc3QgaXNOZXh0ID0gb3JkZXIgPT09IE9SREVSX05FWFQ7XHJcbiAgICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZWxlbWVudCB8fCBnZXROZXh0QWN0aXZlRWxlbWVudCh0aGlzLl9nZXRJdGVtcygpLCBhY3RpdmVFbGVtZW50LCBpc05leHQsIHRoaXMuX2NvbmZpZy53cmFwKTtcclxuXHJcbiAgICAgIGlmIChuZXh0RWxlbWVudCA9PT0gYWN0aXZlRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbmV4dEVsZW1lbnRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChuZXh0RWxlbWVudCk7XHJcblxyXG4gICAgICBjb25zdCB0cmlnZ2VyRXZlbnQgPSBldmVudE5hbWUgPT4ge1xyXG4gICAgICAgIHJldHVybiBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBldmVudE5hbWUsIHtcclxuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG5leHRFbGVtZW50LFxyXG4gICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKSxcclxuICAgICAgICAgIGZyb206IHRoaXMuX2dldEl0ZW1JbmRleChhY3RpdmVFbGVtZW50KSxcclxuICAgICAgICAgIHRvOiBuZXh0RWxlbWVudEluZGV4XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCBzbGlkZUV2ZW50ID0gdHJpZ2dlckV2ZW50KEVWRU5UX1NMSURFKTtcclxuXHJcbiAgICAgIGlmIChzbGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghYWN0aXZlRWxlbWVudCB8fCAhbmV4dEVsZW1lbnQpIHtcclxuICAgICAgICAvLyBTb21lIHdlaXJkbmVzcyBpcyBoYXBwZW5pbmcsIHNvIHdlIGJhaWxcclxuICAgICAgICAvLyB0b2RvOiBjaGFuZ2UgdGVzdHMgdGhhdCB1c2UgZW1wdHkgZGl2cyB0byBhdm9pZCB0aGlzIGNoZWNrXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBpc0N5Y2xpbmcgPSBCb29sZWFuKHRoaXMuX2ludGVydmFsKTtcclxuICAgICAgdGhpcy5wYXVzZSgpO1xyXG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlO1xyXG5cclxuICAgICAgdGhpcy5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChuZXh0RWxlbWVudEluZGV4KTtcclxuXHJcbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBuZXh0RWxlbWVudDtcclxuICAgICAgY29uc3QgZGlyZWN0aW9uYWxDbGFzc05hbWUgPSBpc05leHQgPyBDTEFTU19OQU1FX1NUQVJUIDogQ0xBU1NfTkFNRV9FTkQ7XHJcbiAgICAgIGNvbnN0IG9yZGVyQ2xhc3NOYW1lID0gaXNOZXh0ID8gQ0xBU1NfTkFNRV9ORVhUIDogQ0xBU1NfTkFNRV9QUkVWO1xyXG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKG9yZGVyQ2xhc3NOYW1lKTtcclxuICAgICAgcmVmbG93KG5leHRFbGVtZW50KTtcclxuICAgICAgYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKGRpcmVjdGlvbmFsQ2xhc3NOYW1lKTtcclxuICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XHJcblxyXG4gICAgICBjb25zdCBjb21wbGV0ZUNhbGxCYWNrID0gKCkgPT4ge1xyXG4gICAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoZGlyZWN0aW9uYWxDbGFzc05hbWUsIG9yZGVyQ2xhc3NOYW1lKTtcclxuICAgICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDIpO1xyXG4gICAgICAgIGFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQyLCBvcmRlckNsYXNzTmFtZSwgZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xyXG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChFVkVOVF9TTElEKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsQmFjaywgYWN0aXZlRWxlbWVudCwgdGhpcy5faXNBbmltYXRlZCgpKTtcclxuXHJcbiAgICAgIGlmIChpc0N5Y2xpbmcpIHtcclxuICAgICAgICB0aGlzLmN5Y2xlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfaXNBbmltYXRlZCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0xJREUpO1xyXG4gICAgfVxyXG5cclxuICAgIF9nZXRBY3RpdmUoKSB7XHJcbiAgICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRV9JVEVNLCB0aGlzLl9lbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBfZ2V0SXRlbXMoKSB7XHJcbiAgICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0lURU0sIHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIF9jbGVhckludGVydmFsKCkge1xyXG4gICAgICBpZiAodGhpcy5faW50ZXJ2YWwpIHtcclxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcclxuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfZGlyZWN0aW9uVG9PcmRlcihkaXJlY3Rpb24pIHtcclxuICAgICAgaWYgKGlzUlRMKCkpIHtcclxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uID09PSBESVJFQ1RJT05fTEVGVCA/IE9SREVSX1BSRVYgOiBPUkRFUl9ORVhUO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGlyZWN0aW9uID09PSBESVJFQ1RJT05fTEVGVCA/IE9SREVSX05FWFQgOiBPUkRFUl9QUkVWO1xyXG4gICAgfVxyXG5cclxuICAgIF9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKSB7XHJcbiAgICAgIGlmIChpc1JUTCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIG9yZGVyID09PSBPUkRFUl9QUkVWID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBvcmRlciA9PT0gT1JERVJfUFJFViA/IERJUkVDVElPTl9SSUdIVCA6IERJUkVDVElPTl9MRUZUO1xyXG4gICAgfSAvLyBTdGF0aWNcclxuXHJcblxyXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IENhcm91c2VsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICBkYXRhLnRvKGNvbmZpZyk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gIH1cclxuICAvKipcclxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxyXG4gICAqL1xyXG5cclxuXHJcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ1LCBTRUxFQ1RPUl9EQVRBX1NMSURFLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcyk7XHJcblxyXG4gICAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9DQVJPVVNFTCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBjb25zdCBjYXJvdXNlbCA9IENhcm91c2VsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTtcclxuICAgIGNvbnN0IHNsaWRlSW5kZXggPSB0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS1icy1zbGlkZS10bycpO1xyXG5cclxuICAgIGlmIChzbGlkZUluZGV4KSB7XHJcbiAgICAgIGNhcm91c2VsLnRvKHNsaWRlSW5kZXgpO1xyXG5cclxuICAgICAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKTtcclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZSh0aGlzLCAnc2xpZGUnKSA9PT0gJ25leHQnKSB7XHJcbiAgICAgIGNhcm91c2VsLm5leHQoKTtcclxuXHJcbiAgICAgIGNhcm91c2VsLl9tYXliZUVuYWJsZUN5Y2xlKCk7XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY2Fyb3VzZWwucHJldigpO1xyXG5cclxuICAgIGNhcm91c2VsLl9tYXliZUVuYWJsZUN5Y2xlKCk7XHJcbiAgfSk7XHJcbiAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQzLCAoKSA9PiB7XHJcbiAgICBjb25zdCBjYXJvdXNlbHMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfUklERSk7XHJcblxyXG4gICAgZm9yIChjb25zdCBjYXJvdXNlbCBvZiBjYXJvdXNlbHMpIHtcclxuICAgICAgQ2Fyb3VzZWwuZ2V0T3JDcmVhdGVJbnN0YW5jZShjYXJvdXNlbCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgLyoqXHJcbiAgICogalF1ZXJ5XHJcbiAgICovXHJcblxyXG4gIGRlZmluZUpRdWVyeVBsdWdpbihDYXJvdXNlbCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwICh2NS4yLjMpOiBjb2xsYXBzZS5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUkYiA9ICdjb2xsYXBzZSc7XHJcbiAgY29uc3QgREFUQV9LRVkkNyA9ICdicy5jb2xsYXBzZSc7XHJcbiAgY29uc3QgRVZFTlRfS0VZJDcgPSBgLiR7REFUQV9LRVkkN31gO1xyXG4gIGNvbnN0IERBVEFfQVBJX0tFWSQ0ID0gJy5kYXRhLWFwaSc7XHJcbiAgY29uc3QgRVZFTlRfU0hPVyQ2ID0gYHNob3cke0VWRU5UX0tFWSQ3fWA7XHJcbiAgY29uc3QgRVZFTlRfU0hPV04kNiA9IGBzaG93biR7RVZFTlRfS0VZJDd9YDtcclxuICBjb25zdCBFVkVOVF9ISURFJDYgPSBgaGlkZSR7RVZFTlRfS0VZJDd9YDtcclxuICBjb25zdCBFVkVOVF9ISURERU4kNiA9IGBoaWRkZW4ke0VWRU5UX0tFWSQ3fWA7XHJcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCA9IGBjbGljayR7RVZFTlRfS0VZJDd9JHtEQVRBX0FQSV9LRVkkNH1gO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ3ID0gJ3Nob3cnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0UgPSAnY29sbGFwc2UnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0lORyA9ICdjb2xsYXBzaW5nJztcclxuICBjb25zdCBDTEFTU19OQU1FX0NPTExBUFNFRCA9ICdjb2xsYXBzZWQnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfREVFUEVSX0NISUxEUkVOID0gYDpzY29wZSAuJHtDTEFTU19OQU1FX0NPTExBUFNFfSAuJHtDTEFTU19OQU1FX0NPTExBUFNFfWA7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9IT1JJWk9OVEFMID0gJ2NvbGxhcHNlLWhvcml6b250YWwnO1xyXG4gIGNvbnN0IFdJRFRIID0gJ3dpZHRoJztcclxuICBjb25zdCBIRUlHSFQgPSAnaGVpZ2h0JztcclxuICBjb25zdCBTRUxFQ1RPUl9BQ1RJVkVTID0gJy5jb2xsYXBzZS5zaG93LCAuY29sbGFwc2UuY29sbGFwc2luZyc7XHJcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkNCA9ICdbZGF0YS1icy10b2dnbGU9XCJjb2xsYXBzZVwiXSc7XHJcbiAgY29uc3QgRGVmYXVsdCRhID0ge1xyXG4gICAgcGFyZW50OiBudWxsLFxyXG4gICAgdG9nZ2xlOiB0cnVlXHJcbiAgfTtcclxuICBjb25zdCBEZWZhdWx0VHlwZSRhID0ge1xyXG4gICAgcGFyZW50OiAnKG51bGx8ZWxlbWVudCknLFxyXG4gICAgdG9nZ2xlOiAnYm9vbGVhbidcclxuICB9O1xyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgQ29sbGFwc2UgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xyXG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xyXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy5fdHJpZ2dlckFycmF5ID0gW107XHJcbiAgICAgIGNvbnN0IHRvZ2dsZUxpc3QgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQpO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBlbGVtIG9mIHRvZ2dsZUxpc3QpIHtcclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbSk7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpLmZpbHRlcihmb3VuZEVsZW1lbnQgPT4gZm91bmRFbGVtZW50ID09PSB0aGlzLl9lbGVtZW50KTtcclxuXHJcbiAgICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsICYmIGZpbHRlckVsZW1lbnQubGVuZ3RoKSB7XHJcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChlbGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2luaXRpYWxpemVDaGlsZHJlbigpO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XHJcbiAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdGhpcy5faXNTaG93bigpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy50b2dnbGUpIHtcclxuICAgICAgICB0aGlzLnRvZ2dsZSgpO1xyXG4gICAgICB9XHJcbiAgICB9IC8vIEdldHRlcnNcclxuXHJcblxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdCRhO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSRhO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgICAgcmV0dXJuIE5BTUUkYjtcclxuICAgIH0gLy8gUHVibGljXHJcblxyXG5cclxuICAgIHRvZ2dsZSgpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24oKSkge1xyXG4gICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2hvdygpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCB0aGlzLl9pc1Nob3duKCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBhY3RpdmVDaGlsZHJlbiA9IFtdOyAvLyBmaW5kIGFjdGl2ZSBjaGlsZHJlblxyXG5cclxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcclxuICAgICAgICBhY3RpdmVDaGlsZHJlbiA9IHRoaXMuX2dldEZpcnN0TGV2ZWxDaGlsZHJlbihTRUxFQ1RPUl9BQ1RJVkVTKS5maWx0ZXIoZWxlbWVudCA9PiBlbGVtZW50ICE9PSB0aGlzLl9lbGVtZW50KS5tYXAoZWxlbWVudCA9PiBDb2xsYXBzZS5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIHtcclxuICAgICAgICAgIHRvZ2dsZTogZmFsc2VcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhY3RpdmVDaGlsZHJlbi5sZW5ndGggJiYgYWN0aXZlQ2hpbGRyZW5bMF0uX2lzVHJhbnNpdGlvbmluZykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgc3RhcnRFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckNik7XHJcblxyXG4gICAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGFjdGl2ZUluc3RhbmNlIG9mIGFjdGl2ZUNoaWxkcmVuKSB7XHJcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UuaGlkZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcclxuXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNFKTtcclxuXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gMDtcclxuXHJcbiAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl90cmlnZ2VyQXJyYXksIHRydWUpO1xyXG5cclxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcclxuXHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0UsIENMQVNTX05BTUVfU0hPVyQ3KTtcclxuXHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kNik7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCBjYXBpdGFsaXplZERpbWVuc2lvbiA9IGRpbWVuc2lvblswXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKDEpO1xyXG4gICAgICBjb25zdCBzY3JvbGxTaXplID0gYHNjcm9sbCR7Y2FwaXRhbGl6ZWREaW1lbnNpb259YDtcclxuXHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudFtzY3JvbGxTaXplXX1weGA7XHJcbiAgICB9XHJcblxyXG4gICAgaGlkZSgpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCAhdGhpcy5faXNTaG93bigpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBzdGFydEV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQ2KTtcclxuXHJcbiAgICAgIGlmIChzdGFydEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkaW1lbnNpb25dfXB4YDtcclxuICAgICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XHJcblxyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRSwgQ0xBU1NfTkFNRV9TSE9XJDcpO1xyXG5cclxuICAgICAgZm9yIChjb25zdCB0cmlnZ2VyIG9mIHRoaXMuX3RyaWdnZXJBcnJheSkge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRyaWdnZXIpO1xyXG5cclxuICAgICAgICBpZiAoZWxlbWVudCAmJiAhdGhpcy5faXNTaG93bihlbGVtZW50KSkge1xyXG4gICAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFt0cmlnZ2VyXSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcclxuXHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0UpO1xyXG5cclxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kNik7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJztcclxuXHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIF9pc1Nob3duKGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckNyk7XHJcbiAgICB9IC8vIFByaXZhdGVcclxuXHJcblxyXG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XHJcbiAgICAgIGNvbmZpZy50b2dnbGUgPSBCb29sZWFuKGNvbmZpZy50b2dnbGUpOyAvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlc1xyXG5cclxuICAgICAgY29uZmlnLnBhcmVudCA9IGdldEVsZW1lbnQoY29uZmlnLnBhcmVudCk7XHJcbiAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9XHJcblxyXG4gICAgX2dldERpbWVuc2lvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfSE9SSVpPTlRBTCkgPyBXSURUSCA6IEhFSUdIVDtcclxuICAgIH1cclxuXHJcbiAgICBfaW5pdGlhbGl6ZUNoaWxkcmVuKCkge1xyXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQpO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGNoaWxkcmVuKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpO1xyXG5cclxuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcclxuICAgICAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhbZWxlbWVudF0sIHRoaXMuX2lzU2hvd24oc2VsZWN0ZWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKHNlbGVjdG9yKSB7XHJcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gU2VsZWN0b3JFbmdpbmUuZmluZChDTEFTU19OQU1FX0RFRVBFUl9DSElMRFJFTiwgdGhpcy5fY29uZmlnLnBhcmVudCk7IC8vIHJlbW92ZSBjaGlsZHJlbiBpZiBncmVhdGVyIGRlcHRoXHJcblxyXG4gICAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvciwgdGhpcy5fY29uZmlnLnBhcmVudCkuZmlsdGVyKGVsZW1lbnQgPT4gIWNoaWxkcmVuLmluY2x1ZGVzKGVsZW1lbnQpKTtcclxuICAgIH1cclxuXHJcbiAgICBfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRyaWdnZXJBcnJheSwgaXNPcGVuKSB7XHJcbiAgICAgIGlmICghdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRyaWdnZXJBcnJheSkge1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19OQU1FX0NPTExBUFNFRCwgIWlzT3Blbik7XHJcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pO1xyXG4gICAgICB9XHJcbiAgICB9IC8vIFN0YXRpY1xyXG5cclxuXHJcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xyXG4gICAgICBjb25zdCBfY29uZmlnID0ge307XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycgJiYgL3Nob3d8aGlkZS8udGVzdChjb25maWcpKSB7XHJcbiAgICAgICAgX2NvbmZpZy50b2dnbGUgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IENvbGxhcHNlLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgX2NvbmZpZyk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXHJcbiAgICovXHJcblxyXG5cclxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDQsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgLy8gcHJldmVudERlZmF1bHQgb25seSBmb3IgPGE+IGVsZW1lbnRzICh3aGljaCBjaGFuZ2UgdGhlIFVSTCkgbm90IGluc2lkZSB0aGUgY29sbGFwc2libGUgZWxlbWVudFxyXG4gICAgaWYgKGV2ZW50LnRhcmdldC50YWdOYW1lID09PSAnQScgfHwgZXZlbnQuZGVsZWdhdGVUYXJnZXQgJiYgZXZlbnQuZGVsZWdhdGVUYXJnZXQudGFnTmFtZSA9PT0gJ0EnKSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMpO1xyXG4gICAgY29uc3Qgc2VsZWN0b3JFbGVtZW50cyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpO1xyXG5cclxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBzZWxlY3RvckVsZW1lbnRzKSB7XHJcbiAgICAgIENvbGxhcHNlLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCwge1xyXG4gICAgICAgIHRvZ2dsZTogZmFsc2VcclxuICAgICAgfSkudG9nZ2xlKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgLyoqXHJcbiAgICogalF1ZXJ5XHJcbiAgICovXHJcblxyXG4gIGRlZmluZUpRdWVyeVBsdWdpbihDb2xsYXBzZSk7XHJcblxyXG4gIHZhciB0b3AgPSAndG9wJztcclxuICB2YXIgYm90dG9tID0gJ2JvdHRvbSc7XHJcbiAgdmFyIHJpZ2h0ID0gJ3JpZ2h0JztcclxuICB2YXIgbGVmdCA9ICdsZWZ0JztcclxuICB2YXIgYXV0byA9ICdhdXRvJztcclxuICB2YXIgYmFzZVBsYWNlbWVudHMgPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcclxuICB2YXIgc3RhcnQgPSAnc3RhcnQnO1xyXG4gIHZhciBlbmQgPSAnZW5kJztcclxuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gJ2NsaXBwaW5nUGFyZW50cyc7XHJcbiAgdmFyIHZpZXdwb3J0ID0gJ3ZpZXdwb3J0JztcclxuICB2YXIgcG9wcGVyID0gJ3BvcHBlcic7XHJcbiAgdmFyIHJlZmVyZW5jZSA9ICdyZWZlcmVuY2UnO1xyXG4gIHZhciB2YXJpYXRpb25QbGFjZW1lbnRzID0gLyojX19QVVJFX18qL2Jhc2VQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcclxuICAgIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xyXG4gIH0sIFtdKTtcclxuICB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xyXG4gICAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcclxuICB9LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXHJcblxyXG4gIHZhciBiZWZvcmVSZWFkID0gJ2JlZm9yZVJlYWQnO1xyXG4gIHZhciByZWFkID0gJ3JlYWQnO1xyXG4gIHZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcclxuXHJcbiAgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XHJcbiAgdmFyIG1haW4gPSAnbWFpbic7XHJcbiAgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXHJcblxyXG4gIHZhciBiZWZvcmVXcml0ZSA9ICdiZWZvcmVXcml0ZSc7XHJcbiAgdmFyIHdyaXRlID0gJ3dyaXRlJztcclxuICB2YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcclxuICB2YXIgbW9kaWZpZXJQaGFzZXMgPSBbYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZV07XHJcblxyXG4gIGZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQpIHtcclxuICAgIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcclxuICAgIGlmIChub2RlID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xyXG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcclxuICAgICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbm9kZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XHJcbiAgICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xyXG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XHJcbiAgICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcclxuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xyXG4gICAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcclxuICAgIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XHJcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XHJcbiAgfVxyXG5cclxuICAvLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XHJcblxyXG4gIGZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcclxuICAgIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XHJcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XHJcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcclxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXHJcblxyXG4gICAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxyXG4gICAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxyXG4gICAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cclxuXHJcblxyXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcclxuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVmZmVjdCQyKF9yZWYyKSB7XHJcbiAgICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcclxuICAgIHZhciBpbml0aWFsU3R5bGVzID0ge1xyXG4gICAgICBwb3BwZXI6IHtcclxuICAgICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcclxuICAgICAgICBsZWZ0OiAnMCcsXHJcbiAgICAgICAgdG9wOiAnMCcsXHJcbiAgICAgICAgbWFyZ2luOiAnMCdcclxuICAgICAgfSxcclxuICAgICAgYXJyb3c6IHtcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xyXG4gICAgICB9LFxyXG4gICAgICByZWZlcmVuY2U6IHt9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcclxuICAgIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XHJcblxyXG4gICAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XHJcbiAgICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxyXG5cclxuICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcclxuICAgICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xyXG4gICAgICAgICAgcmV0dXJuIHN0eWxlO1xyXG4gICAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXHJcblxyXG4gICAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xyXG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xyXG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xyXG5cclxuXHJcbiAgY29uc3QgYXBwbHlTdHlsZXMkMSA9IHtcclxuICAgIG5hbWU6ICdhcHBseVN0eWxlcycsXHJcbiAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgcGhhc2U6ICd3cml0ZScsXHJcbiAgICBmbjogYXBwbHlTdHlsZXMsXHJcbiAgICBlZmZlY3Q6IGVmZmVjdCQyLFxyXG4gICAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcclxuICAgIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcclxuICB9XHJcblxyXG4gIHZhciBtYXggPSBNYXRoLm1heDtcclxuICB2YXIgbWluID0gTWF0aC5taW47XHJcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0VUFTdHJpbmcoKSB7XHJcbiAgICB2YXIgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XHJcblxyXG4gICAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5icmFuZHMpIHtcclxuICAgICAgcmV0dXJuIHVhRGF0YS5icmFuZHMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0uYnJhbmQgKyBcIi9cIiArIGl0ZW0udmVyc2lvbjtcclxuICAgICAgfSkuam9pbignICcpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNMYXlvdXRWaWV3cG9ydCgpIHtcclxuICAgIHJldHVybiAhL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChnZXRVQVN0cmluZygpKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSkge1xyXG4gICAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xyXG4gICAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICB2YXIgc2NhbGVYID0gMTtcclxuICAgIHZhciBzY2FsZVkgPSAxO1xyXG5cclxuICAgIGlmIChpbmNsdWRlU2NhbGUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xyXG4gICAgICBzY2FsZVggPSBlbGVtZW50Lm9mZnNldFdpZHRoID4gMCA/IHJvdW5kKGNsaWVudFJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxIDogMTtcclxuICAgICAgc2NhbGVZID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgPiAwID8gcm91bmQoY2xpZW50UmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSA6IDE7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF9yZWYgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3csXHJcbiAgICAgICAgdmlzdWFsVmlld3BvcnQgPSBfcmVmLnZpc3VhbFZpZXdwb3J0O1xyXG5cclxuICAgIHZhciBhZGRWaXN1YWxPZmZzZXRzID0gIWlzTGF5b3V0Vmlld3BvcnQoKSAmJiBpc0ZpeGVkU3RyYXRlZ3k7XHJcbiAgICB2YXIgeCA9IChjbGllbnRSZWN0LmxlZnQgKyAoYWRkVmlzdWFsT2Zmc2V0cyAmJiB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQgOiAwKSkgLyBzY2FsZVg7XHJcbiAgICB2YXIgeSA9IChjbGllbnRSZWN0LnRvcCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC8gc2NhbGVZO1xyXG4gICAgdmFyIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlWDtcclxuICAgIHZhciBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodCAvIHNjYWxlWTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgIHRvcDogeSxcclxuICAgICAgcmlnaHQ6IHggKyB3aWR0aCxcclxuICAgICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxyXG4gICAgICBsZWZ0OiB4LFxyXG4gICAgICB4OiB4LFxyXG4gICAgICB5OiB5XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxyXG5cclxuICBmdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcclxuICAgIHZhciBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpOyAvLyBVc2UgdGhlIGNsaWVudFJlY3Qgc2l6ZXMgaWYgaXQncyBub3QgYmVlbiB0cmFuc2Zvcm1lZC5cclxuICAgIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xyXG5cclxuICAgIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XHJcbiAgICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XHJcblxyXG4gICAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xyXG4gICAgICB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XHJcbiAgICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcclxuICAgICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXHJcbiAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgaGVpZ2h0OiBoZWlnaHRcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XHJcbiAgICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXHJcblxyXG4gICAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XHJcbiAgICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XHJcbiAgICAgICAgdmFyIG5leHQgPSBjaGlsZDtcclxuXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgaWYgKG5leHQgJiYgcGFyZW50LmlzU2FtZU5vZGUobmV4dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cclxuXHJcblxyXG4gICAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XHJcbiAgICAgICAgfSB3aGlsZSAobmV4dCk7XHJcbiAgICAgIH0gLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxyXG5cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcclxuICAgIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxyXG4gICAgZWxlbWVudC5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcclxuICAgIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcclxuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxyXG4gICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cclxuICAgICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcclxuICAgICAgZWxlbWVudC5wYXJlbnROb2RlIHx8ICggLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcclxuICAgICAgaXNTaGFkb3dSb290KGVsZW1lbnQpID8gZWxlbWVudC5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxyXG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXHJcbiAgICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xyXG5cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcclxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xyXG4gICAgZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcclxuICB9IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXHJcbiAgLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXHJcblxyXG5cclxuICBmdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xyXG4gICAgdmFyIGlzRmlyZWZveCA9IC9maXJlZm94L2kudGVzdChnZXRVQVN0cmluZygpKTtcclxuICAgIHZhciBpc0lFID0gL1RyaWRlbnQvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xyXG5cclxuICAgIGlmIChpc0lFICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcclxuICAgICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxyXG4gICAgICB2YXIgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KTtcclxuXHJcbiAgICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xyXG5cclxuICAgIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XHJcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuaG9zdDtcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgWydodG1sJywgJ2JvZHknXS5pbmRleE9mKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkgPCAwKSB7XHJcbiAgICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlJDEoY3VycmVudE5vZGUpOyAvLyBUaGlzIGlzIG5vbi1leGhhdXN0aXZlIGJ1dCBjb3ZlcnMgdGhlIG1vc3QgY29tbW9uIENTUyBwcm9wZXJ0aWVzIHRoYXRcclxuICAgICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cclxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcclxuXHJcbiAgICAgIGlmIChjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmRleE9mKGNzcy53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpIHtcclxuICAgICAgICByZXR1cm4gY3VycmVudE5vZGU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSAvLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXHJcbiAgLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XHJcbiAgICB2YXIgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xyXG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XHJcblxyXG4gICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUkMShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xyXG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlJDEob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XHJcbiAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xyXG4gICAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gd2l0aGluKG1pbiQxLCB2YWx1ZSwgbWF4JDEpIHtcclxuICAgIHJldHVybiBtYXgobWluJDEsIG1pbih2YWx1ZSwgbWF4JDEpKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gd2l0aGluTWF4Q2xhbXAobWluLCB2YWx1ZSwgbWF4KSB7XHJcbiAgICB2YXIgdiA9IHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpO1xyXG4gICAgcmV0dXJuIHYgPiBtYXggPyBtYXggOiB2O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9wOiAwLFxyXG4gICAgICByaWdodDogMCxcclxuICAgICAgYm90dG9tOiAwLFxyXG4gICAgICBsZWZ0OiAwXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbWVyZ2VQYWRkaW5nT2JqZWN0KHBhZGRpbmdPYmplY3QpIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBleHBhbmRUb0hhc2hNYXAodmFsdWUsIGtleXMpIHtcclxuICAgIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XHJcbiAgICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xyXG4gICAgICByZXR1cm4gaGFzaE1hcDtcclxuICAgIH0sIHt9KTtcclxuICB9XHJcblxyXG4gIHZhciB0b1BhZGRpbmdPYmplY3QgPSBmdW5jdGlvbiB0b1BhZGRpbmdPYmplY3QocGFkZGluZywgc3RhdGUpIHtcclxuICAgIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcclxuICAgICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcclxuICAgIH0pKSA6IHBhZGRpbmc7XHJcbiAgICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBhcnJvdyhfcmVmKSB7XHJcbiAgICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xyXG5cclxuICAgIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXHJcbiAgICAgICAgbmFtZSA9IF9yZWYubmFtZSxcclxuICAgICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xyXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xyXG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XHJcbiAgICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcclxuICAgIHZhciBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xyXG4gICAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcclxuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xyXG5cclxuICAgIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcclxuICAgIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XHJcbiAgICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XHJcbiAgICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xyXG4gICAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcclxuICAgIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xyXG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XHJcbiAgICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcclxuICAgIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xyXG4gICAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xyXG5cclxuICAgIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xyXG4gICAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XHJcbiAgICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcclxuICAgIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cclxuXHJcbiAgICB2YXIgYXhpc1Byb3AgPSBheGlzO1xyXG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVmZmVjdCQxKF9yZWYyKSB7XHJcbiAgICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcclxuICAgICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcclxuICAgIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxyXG4gICAgICAgIGFycm93RWxlbWVudCA9IF9vcHRpb25zJGVsZW1lbnQgPT09IHZvaWQgMCA/ICdbZGF0YS1wb3BwZXItYXJyb3ddJyA6IF9vcHRpb25zJGVsZW1lbnQ7XHJcblxyXG4gICAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH0gLy8gQ1NTIHNlbGVjdG9yXHJcblxyXG5cclxuICAgIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xyXG4gICAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xyXG5cclxuICAgICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNvbnRhaW5zKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xyXG5cclxuXHJcbiAgY29uc3QgYXJyb3ckMSA9IHtcclxuICAgIG5hbWU6ICdhcnJvdycsXHJcbiAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgcGhhc2U6ICdtYWluJyxcclxuICAgIGZuOiBhcnJvdyxcclxuICAgIGVmZmVjdDogZWZmZWN0JDEsXHJcbiAgICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXHJcbiAgICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xyXG4gICAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xyXG4gIH1cclxuXHJcbiAgdmFyIHVuc2V0U2lkZXMgPSB7XHJcbiAgICB0b3A6ICdhdXRvJyxcclxuICAgIHJpZ2h0OiAnYXV0bycsXHJcbiAgICBib3R0b206ICdhdXRvJyxcclxuICAgIGxlZnQ6ICdhdXRvJ1xyXG4gIH07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXHJcbiAgLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcclxuICAvLyBjbGVhbmx5IGRpdmlkZSB0aGUgdmFsdWVzIGludG8gdGhlIGFwcHJvcHJpYXRlIHN1YnBpeGVscy5cclxuXHJcbiAgZnVuY3Rpb24gcm91bmRPZmZzZXRzQnlEUFIoX3JlZikge1xyXG4gICAgdmFyIHggPSBfcmVmLngsXHJcbiAgICAgICAgeSA9IF9yZWYueTtcclxuICAgIHZhciB3aW4gPSB3aW5kb3c7XHJcbiAgICB2YXIgZHByID0gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXHJcbiAgICAgIHk6IHJvdW5kKHkgKiBkcHIpIC8gZHByIHx8IDBcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtYXBUb1N0eWxlcyhfcmVmMikge1xyXG4gICAgdmFyIF9PYmplY3QkYXNzaWduMjtcclxuXHJcbiAgICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxyXG4gICAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxyXG4gICAgICAgIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcclxuICAgICAgICB2YXJpYXRpb24gPSBfcmVmMi52YXJpYXRpb24sXHJcbiAgICAgICAgb2Zmc2V0cyA9IF9yZWYyLm9mZnNldHMsXHJcbiAgICAgICAgcG9zaXRpb24gPSBfcmVmMi5wb3NpdGlvbixcclxuICAgICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXHJcbiAgICAgICAgYWRhcHRpdmUgPSBfcmVmMi5hZGFwdGl2ZSxcclxuICAgICAgICByb3VuZE9mZnNldHMgPSBfcmVmMi5yb3VuZE9mZnNldHMsXHJcbiAgICAgICAgaXNGaXhlZCA9IF9yZWYyLmlzRml4ZWQ7XHJcbiAgICB2YXIgX29mZnNldHMkeCA9IG9mZnNldHMueCxcclxuICAgICAgICB4ID0gX29mZnNldHMkeCA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHgsXHJcbiAgICAgICAgX29mZnNldHMkeSA9IG9mZnNldHMueSxcclxuICAgICAgICB5ID0gX29mZnNldHMkeSA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHk7XHJcblxyXG4gICAgdmFyIF9yZWYzID0gdHlwZW9mIHJvdW5kT2Zmc2V0cyA9PT0gJ2Z1bmN0aW9uJyA/IHJvdW5kT2Zmc2V0cyh7XHJcbiAgICAgIHg6IHgsXHJcbiAgICAgIHk6IHlcclxuICAgIH0pIDoge1xyXG4gICAgICB4OiB4LFxyXG4gICAgICB5OiB5XHJcbiAgICB9O1xyXG5cclxuICAgIHggPSBfcmVmMy54O1xyXG4gICAgeSA9IF9yZWYzLnk7XHJcbiAgICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcclxuICAgIHZhciBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xyXG4gICAgdmFyIHNpZGVYID0gbGVmdDtcclxuICAgIHZhciBzaWRlWSA9IHRvcDtcclxuICAgIHZhciB3aW4gPSB3aW5kb3c7XHJcblxyXG4gICAgaWYgKGFkYXB0aXZlKSB7XHJcbiAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKTtcclxuICAgICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcclxuICAgICAgdmFyIHdpZHRoUHJvcCA9ICdjbGllbnRXaWR0aCc7XHJcblxyXG4gICAgICBpZiAob2Zmc2V0UGFyZW50ID09PSBnZXRXaW5kb3cocG9wcGVyKSkge1xyXG4gICAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xyXG5cclxuICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSQxKG9mZnNldFBhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnICYmIHBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSB7XHJcbiAgICAgICAgICBoZWlnaHRQcm9wID0gJ3Njcm9sbEhlaWdodCc7XHJcbiAgICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xyXG4gICAgICAgIH1cclxuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcclxuXHJcblxyXG4gICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQ7XHJcblxyXG4gICAgICBpZiAocGxhY2VtZW50ID09PSB0b3AgfHwgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCBwbGFjZW1lbnQgPT09IHJpZ2h0KSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xyXG4gICAgICAgIHNpZGVZID0gYm90dG9tO1xyXG4gICAgICAgIHZhciBvZmZzZXRZID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXHJcbiAgICAgICAgb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdO1xyXG4gICAgICAgIHkgLT0gb2Zmc2V0WSAtIHBvcHBlclJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocGxhY2VtZW50ID09PSBsZWZ0IHx8IChwbGFjZW1lbnQgPT09IHRvcCB8fCBwbGFjZW1lbnQgPT09IGJvdHRvbSkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcclxuICAgICAgICBzaWRlWCA9IHJpZ2h0O1xyXG4gICAgICAgIHZhciBvZmZzZXRYID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cclxuICAgICAgICBvZmZzZXRQYXJlbnRbd2lkdGhQcm9wXTtcclxuICAgICAgICB4IC09IG9mZnNldFggLSBwb3BwZXJSZWN0LndpZHRoO1xyXG4gICAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb25cclxuICAgIH0sIGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpO1xyXG5cclxuICAgIHZhciBfcmVmNCA9IHJvdW5kT2Zmc2V0cyA9PT0gdHJ1ZSA/IHJvdW5kT2Zmc2V0c0J5RFBSKHtcclxuICAgICAgeDogeCxcclxuICAgICAgeTogeVxyXG4gICAgfSkgOiB7XHJcbiAgICAgIHg6IHgsXHJcbiAgICAgIHk6IHlcclxuICAgIH07XHJcblxyXG4gICAgeCA9IF9yZWY0Lng7XHJcbiAgICB5ID0gX3JlZjQueTtcclxuXHJcbiAgICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XHJcbiAgICAgIHZhciBfT2JqZWN0JGFzc2lnbjtcclxuXHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnbltzaWRlWV0gPSBoYXNZID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduW3NpZGVYXSA9IGhhc1ggPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ24udHJhbnNmb3JtID0gKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKVwiLCBfT2JqZWN0JGFzc2lnbikpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmNSkge1xyXG4gICAgdmFyIHN0YXRlID0gX3JlZjUuc3RhdGUsXHJcbiAgICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XHJcbiAgICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXHJcbiAgICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZ3B1QWNjZWxlcmF0LFxyXG4gICAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcclxuICAgICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmUsXHJcbiAgICAgICAgX29wdGlvbnMkcm91bmRPZmZzZXRzID0gb3B0aW9ucy5yb3VuZE9mZnNldHMsXHJcbiAgICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xyXG5cclxuICAgIHZhciBjb21tb25TdHlsZXMgPSB7XHJcbiAgICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxyXG4gICAgICB2YXJpYXRpb246IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpLFxyXG4gICAgICBwb3BwZXI6IHN0YXRlLmVsZW1lbnRzLnBvcHBlcixcclxuICAgICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxyXG4gICAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvbixcclxuICAgICAgaXNGaXhlZDogc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJ1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcclxuICAgICAgc3RhdGUuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5wb3BwZXIsIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xyXG4gICAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcclxuICAgICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcclxuICAgICAgICBhZGFwdGl2ZTogYWRhcHRpdmUsXHJcbiAgICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcclxuICAgICAgfSkpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XHJcbiAgICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5hcnJvdywgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XHJcbiAgICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICBhZGFwdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcclxuICAgICAgfSkpKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XHJcbiAgICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcclxuICAgIH0pO1xyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xyXG5cclxuXHJcbiAgY29uc3QgY29tcHV0ZVN0eWxlcyQxID0ge1xyXG4gICAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxyXG4gICAgZm46IGNvbXB1dGVTdHlsZXMsXHJcbiAgICBkYXRhOiB7fVxyXG4gIH07XHJcblxyXG4gIHZhciBwYXNzaXZlID0ge1xyXG4gICAgcGFzc2l2ZTogdHJ1ZVxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGVmZmVjdChfcmVmKSB7XHJcbiAgICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxyXG4gICAgICAgIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcclxuICAgICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xyXG4gICAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxyXG4gICAgICAgIHNjcm9sbCA9IF9vcHRpb25zJHNjcm9sbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHNjcm9sbCxcclxuICAgICAgICBfb3B0aW9ucyRyZXNpemUgPSBvcHRpb25zLnJlc2l6ZSxcclxuICAgICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XHJcbiAgICB2YXIgd2luZG93ID0gZ2V0V2luZG93KHN0YXRlLmVsZW1lbnRzLnBvcHBlcik7XHJcbiAgICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xyXG5cclxuICAgIGlmIChzY3JvbGwpIHtcclxuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcclxuICAgICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlc2l6ZSkge1xyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAoc2Nyb2xsKSB7XHJcbiAgICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcclxuICAgICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVzaXplKSB7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXHJcblxyXG5cclxuICBjb25zdCBldmVudExpc3RlbmVycyA9IHtcclxuICAgIG5hbWU6ICdldmVudExpc3RlbmVycycsXHJcbiAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgcGhhc2U6ICd3cml0ZScsXHJcbiAgICBmbjogZnVuY3Rpb24gZm4oKSB7fSxcclxuICAgIGVmZmVjdDogZWZmZWN0LFxyXG4gICAgZGF0YToge31cclxuICB9O1xyXG5cclxuICB2YXIgaGFzaCQxID0ge1xyXG4gICAgbGVmdDogJ3JpZ2h0JyxcclxuICAgIHJpZ2h0OiAnbGVmdCcsXHJcbiAgICBib3R0b206ICd0b3AnLFxyXG4gICAgdG9wOiAnYm90dG9tJ1xyXG4gIH07XHJcbiAgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XHJcbiAgICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xyXG4gICAgICByZXR1cm4gaGFzaCQxW21hdGNoZWRdO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICB2YXIgaGFzaCA9IHtcclxuICAgIHN0YXJ0OiAnZW5kJyxcclxuICAgIGVuZDogJ3N0YXJ0J1xyXG4gIH07XHJcbiAgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XHJcbiAgICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xyXG4gICAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKG5vZGUpIHtcclxuICAgIHZhciB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XHJcbiAgICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcclxuICAgIHZhciBzY3JvbGxUb3AgPSB3aW4ucGFnZVlPZmZzZXQ7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxyXG4gICAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xyXG4gICAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxyXG4gICAgLy8gaW5jb3JyZWN0IGZvciBSVEwuXHJcbiAgICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxyXG4gICAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxyXG4gICAgLy8gYW55d2F5LlxyXG4gICAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcclxuICAgIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXHJcbiAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldFdpbmRvd1Njcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XHJcbiAgICB2YXIgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xyXG4gICAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XHJcbiAgICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XHJcbiAgICB2YXIgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xyXG4gICAgdmFyIGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xyXG4gICAgdmFyIHggPSAwO1xyXG4gICAgdmFyIHkgPSAwO1xyXG5cclxuICAgIGlmICh2aXN1YWxWaWV3cG9ydCkge1xyXG4gICAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xyXG4gICAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XHJcbiAgICAgIHZhciBsYXlvdXRWaWV3cG9ydCA9IGlzTGF5b3V0Vmlld3BvcnQoKTtcclxuXHJcbiAgICAgIGlmIChsYXlvdXRWaWV3cG9ydCB8fCAhbGF5b3V0Vmlld3BvcnQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpIHtcclxuICAgICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcclxuICAgICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXHJcbiAgICAgIHk6IHlcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlXHJcblxyXG4gIGZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XHJcbiAgICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xyXG5cclxuICAgIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcclxuICAgIHZhciBib2R5ID0gKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5O1xyXG4gICAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcclxuICAgIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcclxuICAgIHZhciB4ID0gLXdpblNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcclxuICAgIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XHJcblxyXG4gICAgaWYgKGdldENvbXB1dGVkU3R5bGUkMShib2R5IHx8IGh0bWwpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcclxuICAgICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgIHg6IHgsXHJcbiAgICAgIHk6IHlcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc1Njcm9sbFBhcmVudChlbGVtZW50KSB7XHJcbiAgICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXHJcbiAgICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCksXHJcbiAgICAgICAgb3ZlcmZsb3cgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvdyxcclxuICAgICAgICBvdmVyZmxvd1ggPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gsXHJcbiAgICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xyXG5cclxuICAgIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcclxuICAgIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XHJcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcclxuICAgICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpICYmIGlzU2Nyb2xsUGFyZW50KG5vZGUpKSB7XHJcbiAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gIGdpdmVuIGEgRE9NIGVsZW1lbnQsIHJldHVybiB0aGUgbGlzdCBvZiBhbGwgc2Nyb2xsIHBhcmVudHMsIHVwIHRoZSBsaXN0IG9mIGFuY2Vzb3JzXHJcbiAgdW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcclxuICB0bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXHJcbiAgcmVmZXJlbmNlIGVsZW1lbnQncyBwb3NpdGlvbi5cclxuICAqL1xyXG5cclxuICBmdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XHJcbiAgICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xyXG5cclxuICAgIGlmIChsaXN0ID09PSB2b2lkIDApIHtcclxuICAgICAgbGlzdCA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XHJcbiAgICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcclxuICAgIHZhciB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsUGFyZW50KTtcclxuICAgIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xyXG4gICAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcclxuICAgIHJldHVybiBpc0JvZHkgPyB1cGRhdGVkTGlzdCA6IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxyXG4gICAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xyXG4gICAgICBsZWZ0OiByZWN0LngsXHJcbiAgICAgIHRvcDogcmVjdC55LFxyXG4gICAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcclxuICAgICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xyXG4gICAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgZmFsc2UsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcclxuICAgIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcclxuICAgIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcclxuICAgIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodDtcclxuICAgIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgcmVjdC53aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgICByZWN0LmhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgcmVjdC54ID0gcmVjdC5sZWZ0O1xyXG4gICAgcmVjdC55ID0gcmVjdC50b3A7XHJcbiAgICByZXR1cm4gcmVjdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkge1xyXG4gICAgcmV0dXJuIGNsaXBwaW5nUGFyZW50ID09PSB2aWV3cG9ydCA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSkgOiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xyXG4gIH0gLy8gQSBcImNsaXBwaW5nIHBhcmVudFwiIGlzIGFuIG92ZXJmbG93YWJsZSBjb250YWluZXIgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2ZcclxuICAvLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cclxuICAvLyBgaW5pdGlhbGBcclxuXHJcblxyXG4gIGZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XHJcbiAgICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XHJcbiAgICB2YXIgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkucG9zaXRpb24pID49IDA7XHJcbiAgICB2YXIgY2xpcHBlckVsZW1lbnQgPSBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIDogZWxlbWVudDtcclxuXHJcbiAgICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxyXG5cclxuXHJcbiAgICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcclxuICAgICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5JztcclxuICAgIH0pO1xyXG4gIH0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxyXG4gIC8vIGNsaXBwaW5nIHBhcmVudHNcclxuXHJcblxyXG4gIGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSkge1xyXG4gICAgdmFyIG1haW5DbGlwcGluZ1BhcmVudHMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cycgPyBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xyXG4gICAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IFtdLmNvbmNhdChtYWluQ2xpcHBpbmdQYXJlbnRzLCBbcm9vdEJvdW5kYXJ5XSk7XHJcbiAgICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcclxuICAgIHZhciBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ1BhcmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2NSZWN0LCBjbGlwcGluZ1BhcmVudCkge1xyXG4gICAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSk7XHJcbiAgICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XHJcbiAgICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XHJcbiAgICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XHJcbiAgICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XHJcbiAgICAgIHJldHVybiBhY2NSZWN0O1xyXG4gICAgfSwgZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgZmlyc3RDbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpKTtcclxuICAgIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xyXG4gICAgY2xpcHBpbmdSZWN0LmhlaWdodCA9IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wO1xyXG4gICAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcclxuICAgIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcclxuICAgIHJldHVybiBjbGlwcGluZ1JlY3Q7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XHJcbiAgICB2YXIgcmVmZXJlbmNlID0gX3JlZi5yZWZlcmVuY2UsXHJcbiAgICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcclxuICAgICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcclxuICAgIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50ID8gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIDogbnVsbDtcclxuICAgIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XHJcbiAgICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xyXG4gICAgdmFyIGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZWxlbWVudC5oZWlnaHQgLyAyO1xyXG4gICAgdmFyIG9mZnNldHM7XHJcblxyXG4gICAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XHJcbiAgICAgIGNhc2UgdG9wOlxyXG4gICAgICAgIG9mZnNldHMgPSB7XHJcbiAgICAgICAgICB4OiBjb21tb25YLFxyXG4gICAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIGJvdHRvbTpcclxuICAgICAgICBvZmZzZXRzID0ge1xyXG4gICAgICAgICAgeDogY29tbW9uWCxcclxuICAgICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIHJpZ2h0OlxyXG4gICAgICAgIG9mZnNldHMgPSB7XHJcbiAgICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcclxuICAgICAgICAgIHk6IGNvbW1vbllcclxuICAgICAgICB9O1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSBsZWZ0OlxyXG4gICAgICAgIG9mZnNldHMgPSB7XHJcbiAgICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXHJcbiAgICAgICAgICB5OiBjb21tb25ZXHJcbiAgICAgICAgfTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgb2Zmc2V0cyA9IHtcclxuICAgICAgICAgIHg6IHJlZmVyZW5jZS54LFxyXG4gICAgICAgICAgeTogcmVmZXJlbmNlLnlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnQgPyBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCkgOiBudWxsO1xyXG5cclxuICAgIGlmIChtYWluQXhpcyAhPSBudWxsKSB7XHJcbiAgICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xyXG5cclxuICAgICAgc3dpdGNoICh2YXJpYXRpb24pIHtcclxuICAgICAgICBjYXNlIHN0YXJ0OlxyXG4gICAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSAtIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIGVuZDpcclxuICAgICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvZmZzZXRzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcclxuICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXHJcbiAgICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxyXG4gICAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zJHBsYWNlbWVudCA9PT0gdm9pZCAwID8gc3RhdGUucGxhY2VtZW50IDogX29wdGlvbnMkcGxhY2VtZW50LFxyXG4gICAgICAgIF9vcHRpb25zJHN0cmF0ZWd5ID0gX29wdGlvbnMuc3RyYXRlZ3ksXHJcbiAgICAgICAgc3RyYXRlZ3kgPSBfb3B0aW9ucyRzdHJhdGVneSA9PT0gdm9pZCAwID8gc3RhdGUuc3RyYXRlZ3kgOiBfb3B0aW9ucyRzdHJhdGVneSxcclxuICAgICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxyXG4gICAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxyXG4gICAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcclxuICAgICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxyXG4gICAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxyXG4gICAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBwb3BwZXIgOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXHJcbiAgICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcclxuICAgICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxyXG4gICAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxyXG4gICAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcclxuICAgIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcclxuICAgIHZhciBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcclxuICAgIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xyXG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XHJcbiAgICB2YXIgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IGdldERvY3VtZW50RWxlbWVudChzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSk7XHJcbiAgICB2YXIgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2UpO1xyXG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XHJcbiAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcclxuICAgICAgZWxlbWVudDogcG9wcGVyUmVjdCxcclxuICAgICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXHJcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50XHJcbiAgICB9KTtcclxuICAgIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XHJcbiAgICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcclxuICAgIC8vIDAgb3IgbmVnYXRpdmUgPSB3aXRoaW4gdGhlIGNsaXBwaW5nIHJlY3RcclxuXHJcbiAgICB2YXIgb3ZlcmZsb3dPZmZzZXRzID0ge1xyXG4gICAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcclxuICAgICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXHJcbiAgICAgIGxlZnQ6IGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCxcclxuICAgICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxyXG4gICAgfTtcclxuICAgIHZhciBvZmZzZXREYXRhID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7IC8vIE9mZnNldHMgY2FuIGJlIGFwcGxpZWQgb25seSB0byB0aGUgcG9wcGVyIGVsZW1lbnRcclxuXHJcbiAgICBpZiAoZWxlbWVudENvbnRleHQgPT09IHBvcHBlciAmJiBvZmZzZXREYXRhKSB7XHJcbiAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XHJcbiAgICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIG11bHRpcGx5ID0gW3JpZ2h0LCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xyXG4gICAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcclxuICAgICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCBvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxyXG4gICAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcclxuICAgICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxyXG4gICAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcclxuICAgICAgICBwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcclxuICAgICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxyXG4gICAgICAgIF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9IF9vcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxcclxuICAgICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPT09IHZvaWQgMCA/IHBsYWNlbWVudHMgOiBfb3B0aW9ucyRhbGxvd2VkQXV0b1A7XHJcbiAgICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XHJcbiAgICB2YXIgcGxhY2VtZW50cyQxID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xyXG4gICAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcclxuICAgIH0pIDogYmFzZVBsYWNlbWVudHM7XHJcbiAgICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzJDEuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzJDE7XHJcbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdOiBGbG93IHNlZW1zIHRvIGhhdmUgcHJvYmxlbXMgd2l0aCB0d28gYXJyYXkgdW5pb25zLi4uXHJcblxyXG5cclxuICAgIHZhciBvdmVyZmxvd3MgPSBhbGxvd2VkUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XHJcbiAgICAgIGFjY1twbGFjZW1lbnRdID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcclxuICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcclxuICAgICAgICBib3VuZGFyeTogYm91bmRhcnksXHJcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXHJcbiAgICAgICAgcGFkZGluZzogcGFkZGluZ1xyXG4gICAgICB9KVtnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCldO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30pO1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJmbG93cykuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICByZXR1cm4gb3ZlcmZsb3dzW2FdIC0gb3ZlcmZsb3dzW2JdO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcclxuICAgIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XHJcbiAgICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZmxpcChfcmVmKSB7XHJcbiAgICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxyXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXHJcbiAgICAgICAgbmFtZSA9IF9yZWYubmFtZTtcclxuXHJcbiAgICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcclxuICAgICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcclxuICAgICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxyXG4gICAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxyXG4gICAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxyXG4gICAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXHJcbiAgICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxyXG4gICAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxyXG4gICAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcclxuICAgICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxyXG4gICAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxyXG4gICAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IG9wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzO1xyXG4gICAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xyXG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XHJcbiAgICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xyXG4gICAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xyXG4gICAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XHJcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0byA/IGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCB7XHJcbiAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXHJcbiAgICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxyXG4gICAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxyXG4gICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXHJcbiAgICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxyXG4gICAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYWxsb3dlZEF1dG9QbGFjZW1lbnRzXHJcbiAgICAgIH0pIDogcGxhY2VtZW50KTtcclxuICAgIH0sIFtdKTtcclxuICAgIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xyXG4gICAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XHJcbiAgICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgdmFyIG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XHJcbiAgICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XHJcblxyXG4gICAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XHJcblxyXG4gICAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcclxuICAgICAgdmFyIGlzVmVydGljYWwgPSBbdG9wLCBib3R0b21dLmluZGV4T2YoX2Jhc2VQbGFjZW1lbnQpID49IDA7XHJcbiAgICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xyXG4gICAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xyXG4gICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxyXG4gICAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcclxuICAgICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcclxuICAgICAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnksXHJcbiAgICAgICAgcGFkZGluZzogcGFkZGluZ1xyXG4gICAgICB9KTtcclxuICAgICAgdmFyIG1haW5WYXJpYXRpb25TaWRlID0gaXNWZXJ0aWNhbCA/IGlzU3RhcnRWYXJpYXRpb24gPyByaWdodCA6IGxlZnQgOiBpc1N0YXJ0VmFyaWF0aW9uID8gYm90dG9tIDogdG9wO1xyXG5cclxuICAgICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xyXG4gICAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcclxuICAgICAgdmFyIGNoZWNrcyA9IFtdO1xyXG5cclxuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcclxuICAgICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjaGVja0FsdEF4aXMpIHtcclxuICAgICAgICBjaGVja3MucHVzaChvdmVyZmxvd1ttYWluVmFyaWF0aW9uU2lkZV0gPD0gMCwgb3ZlcmZsb3dbYWx0VmFyaWF0aW9uU2lkZV0gPD0gMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoZWNrO1xyXG4gICAgICB9KSkge1xyXG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcclxuICAgICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xyXG4gICAgICAvLyBgMmAgbWF5IGJlIGRlc2lyZWQgaW4gc29tZSBjYXNlcyDigJMgcmVzZWFyY2ggbGF0ZXJcclxuICAgICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcclxuXHJcbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XHJcbiAgICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xyXG4gICAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcclxuXHJcbiAgICAgICAgICBpZiAoY2hlY2tzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBjaGVjaztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XHJcbiAgICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBmaXR0aW5nUGxhY2VtZW50O1xyXG4gICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBmb3IgKHZhciBfaSA9IG51bWJlck9mQ2hlY2tzOyBfaSA+IDA7IF9pLS0pIHtcclxuICAgICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcclxuXHJcbiAgICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhdGUucGxhY2VtZW50ICE9PSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQpIHtcclxuICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XHJcbiAgICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcclxuICAgICAgc3RhdGUucmVzZXQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xyXG5cclxuXHJcbiAgY29uc3QgZmxpcCQxID0ge1xyXG4gICAgbmFtZTogJ2ZsaXAnLFxyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIHBoYXNlOiAnbWFpbicsXHJcbiAgICBmbjogZmxpcCxcclxuICAgIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXHJcbiAgICBkYXRhOiB7XHJcbiAgICAgIF9za2lwOiBmYWxzZVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XHJcbiAgICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIHByZXZlbnRlZE9mZnNldHMgPSB7XHJcbiAgICAgICAgeDogMCxcclxuICAgICAgICB5OiAwXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcclxuICAgICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcclxuICAgICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcclxuICAgICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcclxuICAgIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XHJcbiAgICAgIHJldHVybiBvdmVyZmxvd1tzaWRlXSA+PSAwO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBoaWRlKF9yZWYpIHtcclxuICAgIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXHJcbiAgICAgICAgbmFtZSA9IF9yZWYubmFtZTtcclxuICAgIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xyXG4gICAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XHJcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xyXG4gICAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcclxuICAgICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXHJcbiAgICB9KTtcclxuICAgIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XHJcbiAgICAgIGFsdEJvdW5kYXJ5OiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XHJcbiAgICB2YXIgcG9wcGVyRXNjYXBlT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHBvcHBlckFsdE92ZXJmbG93LCBwb3BwZXJSZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKTtcclxuICAgIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xyXG4gICAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XHJcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0ge1xyXG4gICAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcclxuICAgICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcclxuICAgICAgaXNSZWZlcmVuY2VIaWRkZW46IGlzUmVmZXJlbmNlSGlkZGVuLFxyXG4gICAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXHJcbiAgICB9O1xyXG4gICAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xyXG4gICAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxyXG4gICAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcclxuICAgIH0pO1xyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xyXG5cclxuXHJcbiAgY29uc3QgaGlkZSQxID0ge1xyXG4gICAgbmFtZTogJ2hpZGUnLFxyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIHBoYXNlOiAnbWFpbicsXHJcbiAgICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxyXG4gICAgZm46IGhpZGVcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcclxuICAgIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xyXG4gICAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xyXG5cclxuICAgIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xyXG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxyXG4gICAgfSkpIDogb2Zmc2V0LFxyXG4gICAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcclxuICAgICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XHJcblxyXG4gICAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xyXG4gICAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcclxuICAgIHJldHVybiBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcclxuICAgICAgeDogZGlzdGFuY2UsXHJcbiAgICAgIHk6IHNraWRkaW5nXHJcbiAgICB9IDoge1xyXG4gICAgICB4OiBza2lkZGluZyxcclxuICAgICAgeTogZGlzdGFuY2VcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcclxuICAgIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxyXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxyXG4gICAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xyXG4gICAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxyXG4gICAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xyXG4gICAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcclxuICAgICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30pO1xyXG4gICAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcclxuICAgICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXHJcbiAgICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xyXG5cclxuICAgIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xyXG4gICAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xyXG4gICAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xyXG5cclxuXHJcbiAgY29uc3Qgb2Zmc2V0JDEgPSB7XHJcbiAgICBuYW1lOiAnb2Zmc2V0JyxcclxuICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICBwaGFzZTogJ21haW4nLFxyXG4gICAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxyXG4gICAgZm46IG9mZnNldFxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xyXG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcclxuICAgICAgICBuYW1lID0gX3JlZi5uYW1lO1xyXG4gICAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcclxuICAgIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcclxuICAgIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxyXG4gICAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXHJcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xyXG4gICAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcclxuICAgICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxyXG4gICAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcclxuICAgICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcclxuICAgIH0pO1xyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xyXG5cclxuXHJcbiAgY29uc3QgcG9wcGVyT2Zmc2V0cyQxID0ge1xyXG4gICAgbmFtZTogJ3BvcHBlck9mZnNldHMnLFxyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIHBoYXNlOiAncmVhZCcsXHJcbiAgICBmbjogcG9wcGVyT2Zmc2V0cyxcclxuICAgIGRhdGE6IHt9XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0QWx0QXhpcyhheGlzKSB7XHJcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcclxuICAgIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXHJcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcclxuICAgICAgICBuYW1lID0gX3JlZi5uYW1lO1xyXG4gICAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcclxuICAgICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcclxuICAgICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxyXG4gICAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcclxuICAgICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXHJcbiAgICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXHJcbiAgICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxyXG4gICAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXHJcbiAgICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXHJcbiAgICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxyXG4gICAgICAgIF9vcHRpb25zJHRldGhlck9mZnNldCA9IG9wdGlvbnMudGV0aGVyT2Zmc2V0LFxyXG4gICAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcclxuICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XHJcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcclxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXHJcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXHJcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeVxyXG4gICAgfSk7XHJcbiAgICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcclxuICAgIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KTtcclxuICAgIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xyXG4gICAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xyXG4gICAgdmFyIGFsdEF4aXMgPSBnZXRBbHRBeGlzKG1haW5BeGlzKTtcclxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xyXG4gICAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XHJcbiAgICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcclxuICAgIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcclxuICAgICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcclxuICAgIH0pKSA6IHRldGhlck9mZnNldDtcclxuICAgIHZhciBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0VmFsdWUgPT09ICdudW1iZXInID8ge1xyXG4gICAgICBtYWluQXhpczogdGV0aGVyT2Zmc2V0VmFsdWUsXHJcbiAgICAgIGFsdEF4aXM6IHRldGhlck9mZnNldFZhbHVlXHJcbiAgICB9IDogT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgIG1haW5BeGlzOiAwLFxyXG4gICAgICBhbHRBeGlzOiAwXHJcbiAgICB9LCB0ZXRoZXJPZmZzZXRWYWx1ZSk7XHJcbiAgICB2YXIgb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XSA6IG51bGw7XHJcbiAgICB2YXIgZGF0YSA9IHtcclxuICAgICAgeDogMCxcclxuICAgICAgeTogMFxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIXBvcHBlck9mZnNldHMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XHJcbiAgICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQ7XHJcblxyXG4gICAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcclxuICAgICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XHJcbiAgICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xyXG4gICAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XHJcbiAgICAgIHZhciBtaW4kMSA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcclxuICAgICAgdmFyIG1heCQxID0gb2Zmc2V0IC0gb3ZlcmZsb3dbYWx0U2lkZV07XHJcbiAgICAgIHZhciBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcclxuICAgICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XHJcbiAgICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXHJcbiAgICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcclxuXHJcbiAgICAgIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcclxuICAgICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XHJcbiAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgIH07XHJcbiAgICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xyXG4gICAgICB2YXIgYXJyb3dQYWRkaW5nTWluID0gYXJyb3dQYWRkaW5nT2JqZWN0W21haW5TaWRlXTtcclxuICAgICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcclxuICAgICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxyXG4gICAgICAvLyBhbmQgbmVhciB0aGUgZWRnZSBvZiBhIGJvdW5kYXJ5LCB0aGUgcG9wcGVyIGNhbiBvdmVyZmxvdyBldmVuIGlmIHRoZVxyXG4gICAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXHJcbiAgICAgIC8vIHdpZHRoIG9yIGhlaWdodClcclxuXHJcbiAgICAgIHZhciBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcclxuICAgICAgdmFyIG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IHJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgLSBhZGRpdGl2ZSAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XHJcbiAgICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcclxuICAgICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcclxuICAgICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcclxuICAgICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVttYWluQXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgOiAwO1xyXG4gICAgICB2YXIgdGV0aGVyTWluID0gb2Zmc2V0ICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcclxuICAgICAgdmFyIHRldGhlck1heCA9IG9mZnNldCArIG1heE9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWU7XHJcbiAgICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWluKG1pbiQxLCB0ZXRoZXJNaW4pIDogbWluJDEsIG9mZnNldCwgdGV0aGVyID8gbWF4KG1heCQxLCB0ZXRoZXJNYXgpIDogbWF4JDEpO1xyXG4gICAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcclxuICAgICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xyXG4gICAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkMjtcclxuXHJcbiAgICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcclxuXHJcbiAgICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcclxuXHJcbiAgICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcclxuXHJcbiAgICAgIHZhciBfbGVuID0gYWx0QXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xyXG5cclxuICAgICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcclxuXHJcbiAgICAgIHZhciBfbWF4ID0gX29mZnNldCAtIG92ZXJmbG93W19hbHRTaWRlXTtcclxuXHJcbiAgICAgIHZhciBpc09yaWdpblNpZGUgPSBbdG9wLCBsZWZ0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcclxuXHJcbiAgICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVthbHRBeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJDIgOiAwO1xyXG5cclxuICAgICAgdmFyIF90ZXRoZXJNaW4gPSBpc09yaWdpblNpZGUgPyBfbWluIDogX29mZnNldCAtIHJlZmVyZW5jZVJlY3RbX2xlbl0gLSBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcztcclxuXHJcbiAgICAgIHZhciBfdGV0aGVyTWF4ID0gaXNPcmlnaW5TaWRlID8gX29mZnNldCArIHJlZmVyZW5jZVJlY3RbX2xlbl0gKyBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcyA6IF9tYXg7XHJcblxyXG4gICAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHRldGhlciAmJiBpc09yaWdpblNpZGUgPyB3aXRoaW5NYXhDbGFtcChfdGV0aGVyTWluLCBfb2Zmc2V0LCBfdGV0aGVyTWF4KSA6IHdpdGhpbih0ZXRoZXIgPyBfdGV0aGVyTWluIDogX21pbiwgX29mZnNldCwgdGV0aGVyID8gX3RldGhlck1heCA6IF9tYXgpO1xyXG5cclxuICAgICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XHJcbiAgICAgIGRhdGFbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0IC0gX29mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcclxuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcclxuXHJcblxyXG4gIGNvbnN0IHByZXZlbnRPdmVyZmxvdyQxID0ge1xyXG4gICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXHJcbiAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgcGhhc2U6ICdtYWluJyxcclxuICAgIGZuOiBwcmV2ZW50T3ZlcmZsb3csXHJcbiAgICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxyXG4gICAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XHJcbiAgICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XHJcbiAgICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc0VsZW1lbnRTY2FsZWQoZWxlbWVudCkge1xyXG4gICAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgdmFyIHNjYWxlWCA9IHJvdW5kKHJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxO1xyXG4gICAgdmFyIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XHJcbiAgICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcclxuICB9IC8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cclxuICAvLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXHJcblxyXG5cclxuICBmdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnQsIGlzRml4ZWQpIHtcclxuICAgIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcclxuICAgICAgaXNGaXhlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcclxuICAgIHZhciBvZmZzZXRQYXJlbnRJc1NjYWxlZCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc0VsZW1lbnRTY2FsZWQob2Zmc2V0UGFyZW50KTtcclxuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcclxuICAgIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnRJc1NjYWxlZCwgaXNGaXhlZCk7XHJcbiAgICB2YXIgc2Nyb2xsID0ge1xyXG4gICAgICBzY3JvbGxMZWZ0OiAwLFxyXG4gICAgICBzY3JvbGxUb3A6IDBcclxuICAgIH07XHJcbiAgICB2YXIgb2Zmc2V0cyA9IHtcclxuICAgICAgeDogMCxcclxuICAgICAgeTogMFxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XHJcbiAgICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XHJcbiAgICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcclxuICAgICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcclxuICAgICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XHJcbiAgICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xyXG4gICAgICAgIG9mZnNldHMueSArPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xyXG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxyXG4gICAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXHJcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxyXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XHJcbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xyXG4gICAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcclxuICAgICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XHJcbiAgICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxyXG5cclxuICAgIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcclxuICAgICAgdmlzaXRlZC5hZGQobW9kaWZpZXIubmFtZSk7XHJcbiAgICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XHJcbiAgICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xyXG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMoZGVwKSkge1xyXG4gICAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xyXG5cclxuICAgICAgICAgIGlmIChkZXBNb2RpZmllcikge1xyXG4gICAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXN1bHQucHVzaChtb2RpZmllcik7XHJcbiAgICB9XHJcblxyXG4gICAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XHJcbiAgICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcclxuICAgICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcclxuICAgICAgICBzb3J0KG1vZGlmaWVyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XHJcbiAgICAvLyBvcmRlciBiYXNlZCBvbiBkZXBlbmRlbmNpZXNcclxuICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcclxuXHJcbiAgICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XHJcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xyXG4gICAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XHJcbiAgICAgIH0pKTtcclxuICAgIH0sIFtdKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XHJcbiAgICB2YXIgcGVuZGluZztcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICghcGVuZGluZykge1xyXG4gICAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHJlc29sdmUoZm4oKSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHBlbmRpbmc7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbWVyZ2VCeU5hbWUobW9kaWZpZXJzKSB7XHJcbiAgICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XHJcbiAgICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xyXG4gICAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIGN1cnJlbnQsIHtcclxuICAgICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5vcHRpb25zLCBjdXJyZW50Lm9wdGlvbnMpLFxyXG4gICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLmRhdGEsIGN1cnJlbnQuZGF0YSlcclxuICAgICAgfSkgOiBjdXJyZW50O1xyXG4gICAgICByZXR1cm4gbWVyZ2VkO1xyXG4gICAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xyXG5cclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIHJldHVybiBtZXJnZWRba2V5XTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcclxuICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXHJcbiAgICBtb2RpZmllcnM6IFtdLFxyXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xyXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwb3BwZXJHZW5lcmF0b3IoZ2VuZXJhdG9yT3B0aW9ucykge1xyXG4gICAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xyXG4gICAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcclxuICAgICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxyXG4gICAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxyXG4gICAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcclxuICAgICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XHJcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcclxuICAgICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzdGF0ZSA9IHtcclxuICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxyXG4gICAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxyXG4gICAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgZGVmYXVsdE9wdGlvbnMpLFxyXG4gICAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxyXG4gICAgICAgIGVsZW1lbnRzOiB7XHJcbiAgICAgICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcclxuICAgICAgICAgIHBvcHBlcjogcG9wcGVyXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICBzdHlsZXM6IHt9XHJcbiAgICAgIH07XHJcbiAgICAgIHZhciBlZmZlY3RDbGVhbnVwRm5zID0gW107XHJcbiAgICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgICB2YXIgaW5zdGFuY2UgPSB7XHJcbiAgICAgICAgc3RhdGU6IHN0YXRlLFxyXG4gICAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xyXG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xyXG4gICAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xyXG4gICAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcclxuICAgICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XHJcbiAgICAgICAgICAgIHJlZmVyZW5jZTogaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpIDogcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50ID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSA6IFtdLFxyXG4gICAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcclxuICAgICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxyXG4gICAgICAgICAgLy8gcHJvcGVydGllc1xyXG5cclxuICAgICAgICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMobWVyZ2VCeU5hbWUoW10uY29uY2F0KGRlZmF1bHRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSkpOyAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXHJcblxyXG4gICAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XHJcbiAgICAgICAgICB9KTsgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIG1vZGlmaWVycyBzbyB0aGF0IHRoZSBjb25zdW1lciB3aWxsIGdldCB3YXJuZWRcclxuXHJcbiAgICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcclxuICAgICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXHJcbiAgICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxyXG4gICAgICAgIC8vIGxvZ2ljLlxyXG4gICAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcclxuICAgICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXHJcbiAgICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xyXG4gICAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXHJcbiAgICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcclxuICAgICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcclxuICAgICAgICAgIC8vIGFueW1vcmVcclxuXHJcbiAgICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xyXG5cclxuXHJcbiAgICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcclxuICAgICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxyXG4gICAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxyXG4gICAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcclxuICAgICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXHJcbiAgICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxyXG4gICAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcclxuICAgICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxyXG5cclxuICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcclxuICAgICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xyXG4gICAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cclxuICAgICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxyXG5cclxuICAgICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICBpbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgX3N0YXRlJG9yZGVyZWRNb2RpZmllID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF0sXHJcbiAgICAgICAgICAgICAgICBmbiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5mbixcclxuICAgICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIF9vcHRpb25zID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9PT0gdm9pZCAwID8ge30gOiBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyLFxyXG4gICAgICAgICAgICAgICAgbmFtZSA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5uYW1lO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgIHN0YXRlID0gZm4oe1xyXG4gICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgfSkgfHwgc3RhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxyXG4gICAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxyXG4gICAgICAgIHVwZGF0ZTogZGVib3VuY2UoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcclxuICAgICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcclxuICAgICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XHJcbiAgICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxyXG4gICAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcclxuICAgICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcclxuICAgICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XHJcbiAgICAgIC8vIG9uZS5cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcclxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XHJcbiAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWUsXHJcbiAgICAgICAgICAgICAgX3JlZjMkb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYzJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjMkb3B0aW9ucyxcclxuICAgICAgICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3Q7XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XHJcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxyXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxyXG4gICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XHJcblxyXG4gICAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XHJcbiAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICB9O1xyXG4gIH1cclxuICB2YXIgY3JlYXRlUG9wcGVyJDIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcclxuXHJcbiAgdmFyIGRlZmF1bHRNb2RpZmllcnMkMSA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cyQxLCBjb21wdXRlU3R5bGVzJDEsIGFwcGx5U3R5bGVzJDFdO1xyXG4gIHZhciBjcmVhdGVQb3BwZXIkMSA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xyXG4gICAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVycyQxXHJcbiAgfSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcclxuXHJcbiAgdmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMkMSwgY29tcHV0ZVN0eWxlcyQxLCBhcHBseVN0eWxlcyQxLCBvZmZzZXQkMSwgZmxpcCQxLCBwcmV2ZW50T3ZlcmZsb3ckMSwgYXJyb3ckMSwgaGlkZSQxXTtcclxuICB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XHJcbiAgICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXHJcbiAgfSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcclxuXHJcbiAgY29uc3QgUG9wcGVyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoLyojX19QVVJFX18qL09iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XHJcbiAgICBfX3Byb3RvX186IG51bGwsXHJcbiAgICBwb3BwZXJHZW5lcmF0b3IsXHJcbiAgICBkZXRlY3RPdmVyZmxvdyxcclxuICAgIGNyZWF0ZVBvcHBlckJhc2U6IGNyZWF0ZVBvcHBlciQyLFxyXG4gICAgY3JlYXRlUG9wcGVyLFxyXG4gICAgY3JlYXRlUG9wcGVyTGl0ZTogY3JlYXRlUG9wcGVyJDEsXHJcbiAgICB0b3AsXHJcbiAgICBib3R0b20sXHJcbiAgICByaWdodCxcclxuICAgIGxlZnQsXHJcbiAgICBhdXRvLFxyXG4gICAgYmFzZVBsYWNlbWVudHMsXHJcbiAgICBzdGFydCxcclxuICAgIGVuZCxcclxuICAgIGNsaXBwaW5nUGFyZW50cyxcclxuICAgIHZpZXdwb3J0LFxyXG4gICAgcG9wcGVyLFxyXG4gICAgcmVmZXJlbmNlLFxyXG4gICAgdmFyaWF0aW9uUGxhY2VtZW50cyxcclxuICAgIHBsYWNlbWVudHMsXHJcbiAgICBiZWZvcmVSZWFkLFxyXG4gICAgcmVhZCxcclxuICAgIGFmdGVyUmVhZCxcclxuICAgIGJlZm9yZU1haW4sXHJcbiAgICBtYWluLFxyXG4gICAgYWZ0ZXJNYWluLFxyXG4gICAgYmVmb3JlV3JpdGUsXHJcbiAgICB3cml0ZSxcclxuICAgIGFmdGVyV3JpdGUsXHJcbiAgICBtb2RpZmllclBoYXNlcyxcclxuICAgIGFwcGx5U3R5bGVzOiBhcHBseVN0eWxlcyQxLFxyXG4gICAgYXJyb3c6IGFycm93JDEsXHJcbiAgICBjb21wdXRlU3R5bGVzOiBjb21wdXRlU3R5bGVzJDEsXHJcbiAgICBldmVudExpc3RlbmVycyxcclxuICAgIGZsaXA6IGZsaXAkMSxcclxuICAgIGhpZGU6IGhpZGUkMSxcclxuICAgIG9mZnNldDogb2Zmc2V0JDEsXHJcbiAgICBwb3BwZXJPZmZzZXRzOiBwb3BwZXJPZmZzZXRzJDEsXHJcbiAgICBwcmV2ZW50T3ZlcmZsb3c6IHByZXZlbnRPdmVyZmxvdyQxXHJcbiAgfSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwICh2NS4yLjMpOiBkcm9wZG93bi5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUkYSA9ICdkcm9wZG93bic7XHJcbiAgY29uc3QgREFUQV9LRVkkNiA9ICdicy5kcm9wZG93bic7XHJcbiAgY29uc3QgRVZFTlRfS0VZJDYgPSBgLiR7REFUQV9LRVkkNn1gO1xyXG4gIGNvbnN0IERBVEFfQVBJX0tFWSQzID0gJy5kYXRhLWFwaSc7XHJcbiAgY29uc3QgRVNDQVBFX0tFWSQyID0gJ0VzY2FwZSc7XHJcbiAgY29uc3QgVEFCX0tFWSQxID0gJ1RhYic7XHJcbiAgY29uc3QgQVJST1dfVVBfS0VZJDEgPSAnQXJyb3dVcCc7XHJcbiAgY29uc3QgQVJST1dfRE9XTl9LRVkkMSA9ICdBcnJvd0Rvd24nO1xyXG4gIGNvbnN0IFJJR0hUX01PVVNFX0JVVFRPTiA9IDI7IC8vIE1vdXNlRXZlbnQuYnV0dG9uIHZhbHVlIGZvciB0aGUgc2Vjb25kYXJ5IGJ1dHRvbiwgdXN1YWxseSB0aGUgcmlnaHQgYnV0dG9uXHJcblxyXG4gIGNvbnN0IEVWRU5UX0hJREUkNSA9IGBoaWRlJHtFVkVOVF9LRVkkNn1gO1xyXG4gIGNvbnN0IEVWRU5UX0hJRERFTiQ1ID0gYGhpZGRlbiR7RVZFTlRfS0VZJDZ9YDtcclxuICBjb25zdCBFVkVOVF9TSE9XJDUgPSBgc2hvdyR7RVZFTlRfS0VZJDZ9YDtcclxuICBjb25zdCBFVkVOVF9TSE9XTiQ1ID0gYHNob3duJHtFVkVOVF9LRVkkNn1gO1xyXG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMgPSBgY2xpY2ske0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcclxuICBjb25zdCBFVkVOVF9LRVlET1dOX0RBVEFfQVBJID0gYGtleWRvd24ke0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcclxuICBjb25zdCBFVkVOVF9LRVlVUF9EQVRBX0FQSSA9IGBrZXl1cCR7RVZFTlRfS0VZJDZ9JHtEQVRBX0FQSV9LRVkkM31gO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ2ID0gJ3Nob3cnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUFVQID0gJ2Ryb3B1cCc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9EUk9QRU5EID0gJ2Ryb3BlbmQnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUFNUQVJUID0gJ2Ryb3BzdGFydCc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9EUk9QVVBfQ0VOVEVSID0gJ2Ryb3B1cC1jZW50ZXInO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUERPV05fQ0VOVEVSID0gJ2Ryb3Bkb3duLWNlbnRlcic7XHJcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMyA9ICdbZGF0YS1icy10b2dnbGU9XCJkcm9wZG93blwiXTpub3QoLmRpc2FibGVkKTpub3QoOmRpc2FibGVkKSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEVfU0hPV04gPSBgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzfS4ke0NMQVNTX05BTUVfU0hPVyQ2fWA7XHJcbiAgY29uc3QgU0VMRUNUT1JfTUVOVSA9ICcuZHJvcGRvd24tbWVudSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfTkFWQkFSID0gJy5uYXZiYXInO1xyXG4gIGNvbnN0IFNFTEVDVE9SX05BVkJBUl9OQVYgPSAnLm5hdmJhci1uYXYnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX1ZJU0lCTEVfSVRFTVMgPSAnLmRyb3Bkb3duLW1lbnUgLmRyb3Bkb3duLWl0ZW06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZCknO1xyXG4gIGNvbnN0IFBMQUNFTUVOVF9UT1AgPSBpc1JUTCgpID8gJ3RvcC1lbmQnIDogJ3RvcC1zdGFydCc7XHJcbiAgY29uc3QgUExBQ0VNRU5UX1RPUEVORCA9IGlzUlRMKCkgPyAndG9wLXN0YXJ0JyA6ICd0b3AtZW5kJztcclxuICBjb25zdCBQTEFDRU1FTlRfQk9UVE9NID0gaXNSVEwoKSA/ICdib3R0b20tZW5kJyA6ICdib3R0b20tc3RhcnQnO1xyXG4gIGNvbnN0IFBMQUNFTUVOVF9CT1RUT01FTkQgPSBpc1JUTCgpID8gJ2JvdHRvbS1zdGFydCcgOiAnYm90dG9tLWVuZCc7XHJcbiAgY29uc3QgUExBQ0VNRU5UX1JJR0hUID0gaXNSVEwoKSA/ICdsZWZ0LXN0YXJ0JyA6ICdyaWdodC1zdGFydCc7XHJcbiAgY29uc3QgUExBQ0VNRU5UX0xFRlQgPSBpc1JUTCgpID8gJ3JpZ2h0LXN0YXJ0JyA6ICdsZWZ0LXN0YXJ0JztcclxuICBjb25zdCBQTEFDRU1FTlRfVE9QQ0VOVEVSID0gJ3RvcCc7XHJcbiAgY29uc3QgUExBQ0VNRU5UX0JPVFRPTUNFTlRFUiA9ICdib3R0b20nO1xyXG4gIGNvbnN0IERlZmF1bHQkOSA9IHtcclxuICAgIGF1dG9DbG9zZTogdHJ1ZSxcclxuICAgIGJvdW5kYXJ5OiAnY2xpcHBpbmdQYXJlbnRzJyxcclxuICAgIGRpc3BsYXk6ICdkeW5hbWljJyxcclxuICAgIG9mZnNldDogWzAsIDJdLFxyXG4gICAgcG9wcGVyQ29uZmlnOiBudWxsLFxyXG4gICAgcmVmZXJlbmNlOiAndG9nZ2xlJ1xyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkOSA9IHtcclxuICAgIGF1dG9DbG9zZTogJyhib29sZWFufHN0cmluZyknLFxyXG4gICAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcclxuICAgIGRpc3BsYXk6ICdzdHJpbmcnLFxyXG4gICAgb2Zmc2V0OiAnKGFycmF5fHN0cmluZ3xmdW5jdGlvbiknLFxyXG4gICAgcG9wcGVyQ29uZmlnOiAnKG51bGx8b2JqZWN0fGZ1bmN0aW9uKScsXHJcbiAgICByZWZlcmVuY2U6ICcoc3RyaW5nfGVsZW1lbnR8b2JqZWN0KSdcclxuICB9O1xyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgRHJvcGRvd24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xyXG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xyXG4gICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xyXG4gICAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGU7IC8vIGRyb3Bkb3duIHdyYXBwZXJcclxuICAgICAgLy8gdG9kbzogdjYgcmV2ZXJ0ICMzNzAxMSAmIGNoYW5nZSBtYXJrdXAgaHR0cHM6Ly9nZXRib290c3RyYXAuY29tL2RvY3MvNS4yL2Zvcm1zL2lucHV0LWdyb3VwL1xyXG5cclxuICAgICAgdGhpcy5fbWVudSA9IFNlbGVjdG9yRW5naW5lLm5leHQodGhpcy5fZWxlbWVudCwgU0VMRUNUT1JfTUVOVSlbMF0gfHwgU2VsZWN0b3JFbmdpbmUucHJldih0aGlzLl9lbGVtZW50LCBTRUxFQ1RPUl9NRU5VKVswXSB8fCBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX01FTlUsIHRoaXMuX3BhcmVudCk7XHJcbiAgICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCk7XHJcbiAgICB9IC8vIEdldHRlcnNcclxuXHJcblxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdCQ5O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ5O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgICAgcmV0dXJuIE5BTUUkYTtcclxuICAgIH0gLy8gUHVibGljXHJcblxyXG5cclxuICAgIHRvZ2dsZSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd24oKSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2hvdygpIHtcclxuICAgICAgaWYgKGlzRGlzYWJsZWQodGhpcy5fZWxlbWVudCkgfHwgdGhpcy5faXNTaG93bigpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xyXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcclxuICAgICAgfTtcclxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ1LCByZWxhdGVkVGFyZ2V0KTtcclxuXHJcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fY3JlYXRlUG9wcGVyKCk7IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcclxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcclxuICAgICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcclxuICAgICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXHJcblxyXG5cclxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhdGhpcy5fcGFyZW50LmNsb3Nlc3QoU0VMRUNUT1JfTkFWQkFSX05BVikpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcclxuXHJcbiAgICAgIHRoaXMuX21lbnUuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNik7XHJcblxyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDYpO1xyXG5cclxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kNSwgcmVsYXRlZFRhcmdldCk7XHJcbiAgICB9XHJcblxyXG4gICAgaGlkZSgpIHtcclxuICAgICAgaWYgKGlzRGlzYWJsZWQodGhpcy5fZWxlbWVudCkgfHwgIXRoaXMuX2lzU2hvd24oKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcclxuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLl9jb21wbGV0ZUhpZGUocmVsYXRlZFRhcmdldCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xyXG4gICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XHJcbiAgICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9IC8vIFByaXZhdGVcclxuXHJcblxyXG4gICAgX2NvbXBsZXRlSGlkZShyZWxhdGVkVGFyZ2V0KSB7XHJcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNSwgcmVsYXRlZFRhcmdldCk7XHJcblxyXG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcclxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcclxuXHJcblxyXG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XHJcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fbWVudS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ2KTtcclxuXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNik7XHJcblxyXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xyXG5cclxuICAgICAgTWFuaXB1bGF0b3IucmVtb3ZlRGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJyk7XHJcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQ1LCByZWxhdGVkVGFyZ2V0KTtcclxuICAgIH1cclxuXHJcbiAgICBfZ2V0Q29uZmlnKGNvbmZpZykge1xyXG4gICAgICBjb25maWcgPSBzdXBlci5fZ2V0Q29uZmlnKGNvbmZpZyk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWZlcmVuY2UgPT09ICdvYmplY3QnICYmICFpc0VsZW1lbnQkMShjb25maWcucmVmZXJlbmNlKSAmJiB0eXBlb2YgY29uZmlnLnJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBQb3BwZXIgdmlydHVhbCBlbGVtZW50cyByZXF1aXJlIGEgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG1ldGhvZFxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7TkFNRSRhLnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCJyZWZlcmVuY2VcIiBwcm92aWRlZCB0eXBlIFwib2JqZWN0XCIgd2l0aG91dCBhIHJlcXVpcmVkIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIgbWV0aG9kLmApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gY29uZmlnO1xyXG4gICAgfVxyXG5cclxuICAgIF9jcmVhdGVQb3BwZXIoKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgZHJvcGRvd25zIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSAncGFyZW50Jykge1xyXG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9wYXJlbnQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNFbGVtZW50JDEodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkpIHtcclxuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gZ2V0RWxlbWVudCh0aGlzLl9jb25maWcucmVmZXJlbmNlKTtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fY29uZmlnLnJlZmVyZW5jZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcG9wcGVyQ29uZmlnID0gdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCk7XHJcblxyXG4gICAgICB0aGlzLl9wb3BwZXIgPSBjcmVhdGVQb3BwZXIocmVmZXJlbmNlRWxlbWVudCwgdGhpcy5fbWVudSwgcG9wcGVyQ29uZmlnKTtcclxuICAgIH1cclxuXHJcbiAgICBfaXNTaG93bigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX21lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ2KTtcclxuICAgIH1cclxuXHJcbiAgICBfZ2V0UGxhY2VtZW50KCkge1xyXG4gICAgICBjb25zdCBwYXJlbnREcm9wZG93biA9IHRoaXMuX3BhcmVudDtcclxuXHJcbiAgICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRU5EKSkge1xyXG4gICAgICAgIHJldHVybiBQTEFDRU1FTlRfUklHSFQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QU1RBUlQpKSB7XHJcbiAgICAgICAgcmV0dXJuIFBMQUNFTUVOVF9MRUZUO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFVQX0NFTlRFUikpIHtcclxuICAgICAgICByZXR1cm4gUExBQ0VNRU5UX1RPUENFTlRFUjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUikpIHtcclxuICAgICAgICByZXR1cm4gUExBQ0VNRU5UX0JPVFRPTUNFTlRFUjtcclxuICAgICAgfSAvLyBXZSBuZWVkIHRvIHRyaW0gdGhlIHZhbHVlIGJlY2F1c2UgY3VzdG9tIHByb3BlcnRpZXMgY2FuIGFsc28gaW5jbHVkZSBzcGFjZXNcclxuXHJcblxyXG4gICAgICBjb25zdCBpc0VuZCA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fbWVudSkuZ2V0UHJvcGVydHlWYWx1ZSgnLS1icy1wb3NpdGlvbicpLnRyaW0oKSA9PT0gJ2VuZCc7XHJcblxyXG4gICAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFVQKSkge1xyXG4gICAgICAgIHJldHVybiBpc0VuZCA/IFBMQUNFTUVOVF9UT1BFTkQgOiBQTEFDRU1FTlRfVE9QO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfQk9UVE9NRU5EIDogUExBQ0VNRU5UX0JPVFRPTTtcclxuICAgIH1cclxuXHJcbiAgICBfZGV0ZWN0TmF2YmFyKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX05BVkJBUikgIT09IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgX2dldE9mZnNldCgpIHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIG9mZnNldFxyXG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldC5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiBOdW1iZXIucGFyc2VJbnQodmFsdWUsIDEwKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIHBvcHBlckRhdGEgPT4gb2Zmc2V0KHBvcHBlckRhdGEsIHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIF9nZXRQb3BwZXJDb25maWcoKSB7XHJcbiAgICAgIGNvbnN0IGRlZmF1bHRCc1BvcHBlckNvbmZpZyA9IHtcclxuICAgICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxyXG4gICAgICAgIG1vZGlmaWVyczogW3tcclxuICAgICAgICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxyXG4gICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgbmFtZTogJ29mZnNldCcsXHJcbiAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XVxyXG4gICAgICB9OyAvLyBEaXNhYmxlIFBvcHBlciBpZiB3ZSBoYXZlIGEgc3RhdGljIGRpc3BsYXkgb3IgRHJvcGRvd24gaXMgaW4gTmF2YmFyXHJcblxyXG4gICAgICBpZiAodGhpcy5faW5OYXZiYXIgfHwgdGhpcy5fY29uZmlnLmRpc3BsYXkgPT09ICdzdGF0aWMnKSB7XHJcbiAgICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJywgJ3N0YXRpYycpOyAvLyB0b2RvOnY2IHJlbW92ZVxyXG5cclxuICAgICAgICBkZWZhdWx0QnNQb3BwZXJDb25maWcubW9kaWZpZXJzID0gW3tcclxuICAgICAgICAgIG5hbWU6ICdhcHBseVN0eWxlcycsXHJcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxyXG4gICAgICAgIH1dO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geyAuLi5kZWZhdWx0QnNQb3BwZXJDb25maWcsXHJcbiAgICAgICAgLi4uKHR5cGVvZiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnID09PSAnZnVuY3Rpb24nID8gdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyhkZWZhdWx0QnNQb3BwZXJDb25maWcpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZylcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBfc2VsZWN0TWVudUl0ZW0oe1xyXG4gICAgICBrZXksXHJcbiAgICAgIHRhcmdldFxyXG4gICAgfSkge1xyXG4gICAgICBjb25zdCBpdGVtcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfVklTSUJMRV9JVEVNUywgdGhpcy5fbWVudSkuZmlsdGVyKGVsZW1lbnQgPT4gaXNWaXNpYmxlKGVsZW1lbnQpKTtcclxuXHJcbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9IC8vIGlmIHRhcmdldCBpc24ndCBpbmNsdWRlZCBpbiBpdGVtcyAoZS5nLiB3aGVuIGV4cGFuZGluZyB0aGUgZHJvcGRvd24pXHJcbiAgICAgIC8vIGFsbG93IGN5Y2xpbmcgdG8gZ2V0IHRoZSBsYXN0IGl0ZW0gaW4gY2FzZSBrZXkgZXF1YWxzIEFSUk9XX1VQX0tFWVxyXG5cclxuXHJcbiAgICAgIGdldE5leHRBY3RpdmVFbGVtZW50KGl0ZW1zLCB0YXJnZXQsIGtleSA9PT0gQVJST1dfRE9XTl9LRVkkMSwgIWl0ZW1zLmluY2x1ZGVzKHRhcmdldCkpLmZvY3VzKCk7XHJcbiAgICB9IC8vIFN0YXRpY1xyXG5cclxuXHJcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gRHJvcGRvd24uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgY2xlYXJNZW51cyhldmVudCkge1xyXG4gICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSBSSUdIVF9NT1VTRV9CVVRUT04gfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC5rZXkgIT09IFRBQl9LRVkkMSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgb3BlblRvZ2dsZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFX1NIT1dOKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgdG9nZ2xlIG9mIG9wZW5Ub2dnbGVzKSB7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IERyb3Bkb3duLmdldEluc3RhbmNlKHRvZ2dsZSk7XHJcblxyXG4gICAgICAgIGlmICghY29udGV4dCB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjb21wb3NlZFBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcclxuICAgICAgICBjb25zdCBpc01lbnVUYXJnZXQgPSBjb21wb3NlZFBhdGguaW5jbHVkZXMoY29udGV4dC5fbWVudSk7XHJcblxyXG4gICAgICAgIGlmIChjb21wb3NlZFBhdGguaW5jbHVkZXMoY29udGV4dC5fZWxlbWVudCkgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gJ2luc2lkZScgJiYgIWlzTWVudVRhcmdldCB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSAnb3V0c2lkZScgJiYgaXNNZW51VGFyZ2V0KSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IC8vIFRhYiBuYXZpZ2F0aW9uIHRocm91Z2ggdGhlIGRyb3Bkb3duIG1lbnUgb3IgZXZlbnRzIGZyb20gY29udGFpbmVkIGlucHV0cyBzaG91bGRuJ3QgY2xvc2UgdGhlIG1lbnVcclxuXHJcblxyXG4gICAgICAgIGlmIChjb250ZXh0Ll9tZW51LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkgJiYgKGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ID09PSBUQUJfS0VZJDEgfHwgL2lucHV0fHNlbGVjdHxvcHRpb258dGV4dGFyZWF8Zm9ybS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xyXG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogY29udGV4dC5fZWxlbWVudFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnY2xpY2snKSB7XHJcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0LmNsaWNrRXZlbnQgPSBldmVudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnRleHQuX2NvbXBsZXRlSGlkZShyZWxhdGVkVGFyZ2V0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBkYXRhQXBpS2V5ZG93bkhhbmRsZXIoZXZlbnQpIHtcclxuICAgICAgLy8gSWYgbm90IGFuIFVQIHwgRE9XTiB8IEVTQ0FQRSBrZXkgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxyXG4gICAgICAvLyBJZiBpbnB1dC90ZXh0YXJlYSAmJiBpZiBrZXkgaXMgb3RoZXIgdGhhbiBFU0NBUEUgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxyXG4gICAgICBjb25zdCBpc0lucHV0ID0gL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSk7XHJcbiAgICAgIGNvbnN0IGlzRXNjYXBlRXZlbnQgPSBldmVudC5rZXkgPT09IEVTQ0FQRV9LRVkkMjtcclxuICAgICAgY29uc3QgaXNVcE9yRG93bkV2ZW50ID0gW0FSUk9XX1VQX0tFWSQxLCBBUlJPV19ET1dOX0tFWSQxXS5pbmNsdWRlcyhldmVudC5rZXkpO1xyXG5cclxuICAgICAgaWYgKCFpc1VwT3JEb3duRXZlbnQgJiYgIWlzRXNjYXBlRXZlbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc0lucHV0ICYmICFpc0VzY2FwZUV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyB0b2RvOiB2NiByZXZlcnQgIzM3MDExICYgY2hhbmdlIG1hcmt1cCBodHRwczovL2dldGJvb3RzdHJhcC5jb20vZG9jcy81LjIvZm9ybXMvaW5wdXQtZ3JvdXAvXHJcblxyXG4gICAgICBjb25zdCBnZXRUb2dnbGVCdXR0b24gPSB0aGlzLm1hdGNoZXMoU0VMRUNUT1JfREFUQV9UT0dHTEUkMykgPyB0aGlzIDogU2VsZWN0b3JFbmdpbmUucHJldih0aGlzLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzKVswXSB8fCBTZWxlY3RvckVuZ2luZS5uZXh0KHRoaXMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMpWzBdIHx8IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgZXZlbnQuZGVsZWdhdGVUYXJnZXQucGFyZW50Tm9kZSk7XHJcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gRHJvcGRvd24uZ2V0T3JDcmVhdGVJbnN0YW5jZShnZXRUb2dnbGVCdXR0b24pO1xyXG5cclxuICAgICAgaWYgKGlzVXBPckRvd25FdmVudCkge1xyXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIGluc3RhbmNlLnNob3coKTtcclxuXHJcbiAgICAgICAgaW5zdGFuY2UuX3NlbGVjdE1lbnVJdGVtKGV2ZW50KTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaW5zdGFuY2UuX2lzU2hvd24oKSkge1xyXG4gICAgICAgIC8vIGVsc2UgaXMgZXNjYXBlIGFuZCB3ZSBjaGVjayBpZiBpdCBpcyBzaG93blxyXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIGluc3RhbmNlLmhpZGUoKTtcclxuICAgICAgICBnZXRUb2dnbGVCdXR0b24uZm9jdXMoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICB9XHJcbiAgLyoqXHJcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cclxuICAgKi9cclxuXHJcblxyXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgRHJvcGRvd24uZGF0YUFwaUtleWRvd25IYW5kbGVyKTtcclxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fREFUQV9BUEksIFNFTEVDVE9SX01FTlUsIERyb3Bkb3duLmRhdGFBcGlLZXlkb3duSGFuZGxlcik7XHJcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQzLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcclxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWVVQX0RBVEFfQVBJLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcclxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykudG9nZ2xlKCk7XHJcbiAgfSk7XHJcbiAgLyoqXHJcbiAgICogalF1ZXJ5XHJcbiAgICovXHJcblxyXG4gIGRlZmluZUpRdWVyeVBsdWdpbihEcm9wZG93bik7XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwICh2NS4yLjMpOiB1dGlsL3Njcm9sbEJhci5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQgPSAnLmZpeGVkLXRvcCwgLmZpeGVkLWJvdHRvbSwgLmlzLWZpeGVkLCAuc3RpY2t5LXRvcCc7XHJcbiAgY29uc3QgU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQgPSAnLnN0aWNreS10b3AnO1xyXG4gIGNvbnN0IFBST1BFUlRZX1BBRERJTkcgPSAncGFkZGluZy1yaWdodCc7XHJcbiAgY29uc3QgUFJPUEVSVFlfTUFSR0lOID0gJ21hcmdpbi1yaWdodCc7XHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBTY3JvbGxCYXJIZWxwZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBkb2N1bWVudC5ib2R5O1xyXG4gICAgfSAvLyBQdWJsaWNcclxuXHJcblxyXG4gICAgZ2V0V2lkdGgoKSB7XHJcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvaW5uZXJXaWR0aCN1c2FnZV9ub3Rlc1xyXG4gICAgICBjb25zdCBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICByZXR1cm4gTWF0aC5hYnMod2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudFdpZHRoKTtcclxuICAgIH1cclxuXHJcbiAgICBoaWRlKCkge1xyXG4gICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcclxuXHJcbiAgICAgIHRoaXMuX2Rpc2FibGVPdmVyRmxvdygpOyAvLyBnaXZlIHBhZGRpbmcgdG8gZWxlbWVudCB0byBiYWxhbmNlIHRoZSBoaWRkZW4gc2Nyb2xsYmFyIHdpZHRoXHJcblxyXG5cclxuICAgICAgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgUFJPUEVSVFlfUEFERElORywgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSArIHdpZHRoKTsgLy8gdHJpY2s6IFdlIGFkanVzdCBwb3NpdGl2ZSBwYWRkaW5nUmlnaHQgYW5kIG5lZ2F0aXZlIG1hcmdpblJpZ2h0IHRvIHN0aWNreS10b3AgZWxlbWVudHMgdG8ga2VlcCBzaG93aW5nIGZ1bGx3aWR0aFxyXG5cclxuXHJcbiAgICAgIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQsIFBST1BFUlRZX1BBRERJTkcsIGNhbGN1bGF0ZWRWYWx1ZSA9PiBjYWxjdWxhdGVkVmFsdWUgKyB3aWR0aCk7XHJcblxyXG4gICAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCwgUFJPUEVSVFlfTUFSR0lOLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlIC0gd2lkdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsICdvdmVyZmxvdycpO1xyXG5cclxuICAgICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBQUk9QRVJUWV9QQURESU5HKTtcclxuXHJcbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfRklYRURfQ09OVEVOVCwgUFJPUEVSVFlfUEFERElORyk7XHJcblxyXG4gICAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX1NUSUNLWV9DT05URU5ULCBQUk9QRVJUWV9NQVJHSU4pO1xyXG4gICAgfVxyXG5cclxuICAgIGlzT3ZlcmZsb3dpbmcoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldFdpZHRoKCkgPiAwO1xyXG4gICAgfSAvLyBQcml2YXRlXHJcblxyXG5cclxuICAgIF9kaXNhYmxlT3ZlckZsb3coKSB7XHJcbiAgICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKHRoaXMuX2VsZW1lbnQsICdvdmVyZmxvdycpO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xyXG4gICAgfVxyXG5cclxuICAgIF9zZXRFbGVtZW50QXR0cmlidXRlcyhzZWxlY3Rvciwgc3R5bGVQcm9wZXJ0eSwgY2FsbGJhY2spIHtcclxuICAgICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XHJcblxyXG4gICAgICBjb25zdCBtYW5pcHVsYXRpb25DYWxsQmFjayA9IGVsZW1lbnQgPT4ge1xyXG4gICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9lbGVtZW50ICYmIHdpbmRvdy5pbm5lcldpZHRoID4gZWxlbWVudC5jbGllbnRXaWR0aCArIHNjcm9sbGJhcldpZHRoKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KTtcclxuXHJcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZFZhbHVlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShzdHlsZVByb3BlcnR5KTtcclxuICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHN0eWxlUHJvcGVydHksIGAke2NhbGxiYWNrKE51bWJlci5wYXJzZUZsb2F0KGNhbGN1bGF0ZWRWYWx1ZSkpfXB4YCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBtYW5pcHVsYXRpb25DYWxsQmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgX3NhdmVJbml0aWFsQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpIHtcclxuICAgICAgY29uc3QgYWN0dWFsVmFsdWUgPSBlbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUoc3R5bGVQcm9wZXJ0eSk7XHJcblxyXG4gICAgICBpZiAoYWN0dWFsVmFsdWUpIHtcclxuICAgICAgICBNYW5pcHVsYXRvci5zZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHksIGFjdHVhbFZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHNlbGVjdG9yLCBzdHlsZVByb3BlcnR5KSB7XHJcbiAgICAgIGNvbnN0IG1hbmlwdWxhdGlvbkNhbGxCYWNrID0gZWxlbWVudCA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpOyAvLyBXZSBvbmx5IHdhbnQgdG8gcmVtb3ZlIHRoZSBwcm9wZXJ0eSBpZiB0aGUgdmFsdWUgaXMgYG51bGxgOyB0aGUgdmFsdWUgY2FuIGFsc28gYmUgemVyb1xyXG5cclxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoc3R5bGVQcm9wZXJ0eSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBNYW5pcHVsYXRvci5yZW1vdmVEYXRhQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpO1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVQcm9wZXJ0eSwgdmFsdWUpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgbWFuaXB1bGF0aW9uQ2FsbEJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIF9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBjYWxsQmFjaykge1xyXG4gICAgICBpZiAoaXNFbGVtZW50JDEoc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgY2FsbEJhY2soc2VsZWN0b3IpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChjb25zdCBzZWwgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvciwgdGhpcy5fZWxlbWVudCkpIHtcclxuICAgICAgICBjYWxsQmFjayhzZWwpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IHV0aWwvYmFja2Ryb3AuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJDkgPSAnYmFja2Ryb3AnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQ0ID0gJ2ZhZGUnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ1ID0gJ3Nob3cnO1xyXG4gIGNvbnN0IEVWRU5UX01PVVNFRE9XTiA9IGBtb3VzZWRvd24uYnMuJHtOQU1FJDl9YDtcclxuICBjb25zdCBEZWZhdWx0JDggPSB7XHJcbiAgICBjbGFzc05hbWU6ICdtb2RhbC1iYWNrZHJvcCcsXHJcbiAgICBjbGlja0NhbGxiYWNrOiBudWxsLFxyXG4gICAgaXNBbmltYXRlZDogZmFsc2UsXHJcbiAgICBpc1Zpc2libGU6IHRydWUsXHJcbiAgICAvLyBpZiBmYWxzZSwgd2UgdXNlIHRoZSBiYWNrZHJvcCBoZWxwZXIgd2l0aG91dCBhZGRpbmcgYW55IGVsZW1lbnQgdG8gdGhlIGRvbVxyXG4gICAgcm9vdEVsZW1lbnQ6ICdib2R5JyAvLyBnaXZlIHRoZSBjaG9pY2UgdG8gcGxhY2UgYmFja2Ryb3AgdW5kZXIgZGlmZmVyZW50IGVsZW1lbnRzXHJcblxyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkOCA9IHtcclxuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXHJcbiAgICBjbGlja0NhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJyxcclxuICAgIGlzQW5pbWF0ZWQ6ICdib29sZWFuJyxcclxuICAgIGlzVmlzaWJsZTogJ2Jvb2xlYW4nLFxyXG4gICAgcm9vdEVsZW1lbnQ6ICcoZWxlbWVudHxzdHJpbmcpJ1xyXG4gIH07XHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBCYWNrZHJvcCBleHRlbmRzIENvbmZpZyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XHJcbiAgICAgIHRoaXMuX2lzQXBwZW5kZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XHJcbiAgICB9IC8vIEdldHRlcnNcclxuXHJcblxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdCQ4O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ4O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgICAgcmV0dXJuIE5BTUUkOTtcclxuICAgIH0gLy8gUHVibGljXHJcblxyXG5cclxuICAgIHNob3coY2FsbGJhY2spIHtcclxuICAgICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9hcHBlbmQoKTtcclxuXHJcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9nZXRFbGVtZW50KCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcclxuICAgICAgICByZWZsb3coZWxlbWVudCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNSk7XHJcblxyXG4gICAgICB0aGlzLl9lbXVsYXRlQW5pbWF0aW9uKCgpID0+IHtcclxuICAgICAgICBleGVjdXRlKGNhbGxiYWNrKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaGlkZShjYWxsYmFjaykge1xyXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5pc1Zpc2libGUpIHtcclxuICAgICAgICBleGVjdXRlKGNhbGxiYWNrKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ1KTtcclxuXHJcbiAgICAgIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xyXG4gICAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICBpZiAoIXRoaXMuX2lzQXBwZW5kZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOKTtcclxuXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCk7XHJcblxyXG4gICAgICB0aGlzLl9pc0FwcGVuZGVkID0gZmFsc2U7XHJcbiAgICB9IC8vIFByaXZhdGVcclxuXHJcblxyXG4gICAgX2dldEVsZW1lbnQoKSB7XHJcbiAgICAgIGlmICghdGhpcy5fZWxlbWVudCkge1xyXG4gICAgICAgIGNvbnN0IGJhY2tkcm9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgYmFja2Ryb3AuY2xhc3NOYW1lID0gdGhpcy5fY29uZmlnLmNsYXNzTmFtZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKSB7XHJcbiAgICAgICAgICBiYWNrZHJvcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSQ0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBiYWNrZHJvcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XHJcbiAgICAgIC8vIHVzZSBnZXRFbGVtZW50KCkgd2l0aCB0aGUgZGVmYXVsdCBcImJvZHlcIiB0byBnZXQgYSBmcmVzaCBFbGVtZW50IG9uIGVhY2ggaW5zdGFudGlhdGlvblxyXG4gICAgICBjb25maWcucm9vdEVsZW1lbnQgPSBnZXRFbGVtZW50KGNvbmZpZy5yb290RWxlbWVudCk7XHJcbiAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9XHJcblxyXG4gICAgX2FwcGVuZCgpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzQXBwZW5kZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9nZXRFbGVtZW50KCk7XHJcblxyXG4gICAgICB0aGlzLl9jb25maWcucm9vdEVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xyXG5cclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsIEVWRU5UX01PVVNFRE9XTiwgKCkgPT4ge1xyXG4gICAgICAgIGV4ZWN1dGUodGhpcy5fY29uZmlnLmNsaWNrQ2FsbGJhY2spO1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5faXNBcHBlbmRlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgX2VtdWxhdGVBbmltYXRpb24oY2FsbGJhY2spIHtcclxuICAgICAgZXhlY3V0ZUFmdGVyVHJhbnNpdGlvbihjYWxsYmFjaywgdGhpcy5fZ2V0RWxlbWVudCgpLCB0aGlzLl9jb25maWcuaXNBbmltYXRlZCk7XHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IHV0aWwvZm9jdXN0cmFwLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgTkFNRSQ4ID0gJ2ZvY3VzdHJhcCc7XHJcbiAgY29uc3QgREFUQV9LRVkkNSA9ICdicy5mb2N1c3RyYXAnO1xyXG4gIGNvbnN0IEVWRU5UX0tFWSQ1ID0gYC4ke0RBVEFfS0VZJDV9YDtcclxuICBjb25zdCBFVkVOVF9GT0NVU0lOJDIgPSBgZm9jdXNpbiR7RVZFTlRfS0VZJDV9YDtcclxuICBjb25zdCBFVkVOVF9LRVlET1dOX1RBQiA9IGBrZXlkb3duLnRhYiR7RVZFTlRfS0VZJDV9YDtcclxuICBjb25zdCBUQUJfS0VZID0gJ1RhYic7XHJcbiAgY29uc3QgVEFCX05BVl9GT1JXQVJEID0gJ2ZvcndhcmQnO1xyXG4gIGNvbnN0IFRBQl9OQVZfQkFDS1dBUkQgPSAnYmFja3dhcmQnO1xyXG4gIGNvbnN0IERlZmF1bHQkNyA9IHtcclxuICAgIGF1dG9mb2N1czogdHJ1ZSxcclxuICAgIHRyYXBFbGVtZW50OiBudWxsIC8vIFRoZSBlbGVtZW50IHRvIHRyYXAgZm9jdXMgaW5zaWRlIG9mXHJcblxyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkNyA9IHtcclxuICAgIGF1dG9mb2N1czogJ2Jvb2xlYW4nLFxyXG4gICAgdHJhcEVsZW1lbnQ6ICdlbGVtZW50J1xyXG4gIH07XHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBGb2N1c1RyYXAgZXh0ZW5kcyBDb25maWcge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xyXG4gICAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID0gbnVsbDtcclxuICAgIH0gLy8gR2V0dGVyc1xyXG5cclxuXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0JDc7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDc7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRSQ4O1xyXG4gICAgfSAvLyBQdWJsaWNcclxuXHJcblxyXG4gICAgYWN0aXZhdGUoKSB7XHJcbiAgICAgIGlmICh0aGlzLl9pc0FjdGl2ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5hdXRvZm9jdXMpIHtcclxuICAgICAgICB0aGlzLl9jb25maWcudHJhcEVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfS0VZJDUpOyAvLyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcclxuXHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTiQyLCBldmVudCA9PiB0aGlzLl9oYW5kbGVGb2N1c2luKGV2ZW50KSk7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9UQUIsIGV2ZW50ID0+IHRoaXMuX2hhbmRsZUtleWRvd24oZXZlbnQpKTtcclxuICAgICAgdGhpcy5faXNBY3RpdmUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGRlYWN0aXZhdGUoKSB7XHJcbiAgICAgIGlmICghdGhpcy5faXNBY3RpdmUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0tFWSQ1KTtcclxuICAgIH0gLy8gUHJpdmF0ZVxyXG5cclxuXHJcbiAgICBfaGFuZGxlRm9jdXNpbihldmVudCkge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgdHJhcEVsZW1lbnRcclxuICAgICAgfSA9IHRoaXMuX2NvbmZpZztcclxuXHJcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGRvY3VtZW50IHx8IGV2ZW50LnRhcmdldCA9PT0gdHJhcEVsZW1lbnQgfHwgdHJhcEVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZWxlbWVudHMgPSBTZWxlY3RvckVuZ2luZS5mb2N1c2FibGVDaGlsZHJlbih0cmFwRWxlbWVudCk7XHJcblxyXG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgdHJhcEVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID09PSBUQUJfTkFWX0JBQ0tXQVJEKSB7XHJcbiAgICAgICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0uZm9jdXMoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbGVtZW50c1swXS5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgX2hhbmRsZUtleWRvd24oZXZlbnQpIHtcclxuICAgICAgaWYgKGV2ZW50LmtleSAhPT0gVEFCX0tFWSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fbGFzdFRhYk5hdkRpcmVjdGlvbiA9IGV2ZW50LnNoaWZ0S2V5ID8gVEFCX05BVl9CQUNLV0FSRCA6IFRBQl9OQVZfRk9SV0FSRDtcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogbW9kYWwuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJDcgPSAnbW9kYWwnO1xyXG4gIGNvbnN0IERBVEFfS0VZJDQgPSAnYnMubW9kYWwnO1xyXG4gIGNvbnN0IEVWRU5UX0tFWSQ0ID0gYC4ke0RBVEFfS0VZJDR9YDtcclxuICBjb25zdCBEQVRBX0FQSV9LRVkkMiA9ICcuZGF0YS1hcGknO1xyXG4gIGNvbnN0IEVTQ0FQRV9LRVkkMSA9ICdFc2NhcGUnO1xyXG4gIGNvbnN0IEVWRU5UX0hJREUkNCA9IGBoaWRlJHtFVkVOVF9LRVkkNH1gO1xyXG4gIGNvbnN0IEVWRU5UX0hJREVfUFJFVkVOVEVEJDEgPSBgaGlkZVByZXZlbnRlZCR7RVZFTlRfS0VZJDR9YDtcclxuICBjb25zdCBFVkVOVF9ISURERU4kNCA9IGBoaWRkZW4ke0VWRU5UX0tFWSQ0fWA7XHJcbiAgY29uc3QgRVZFTlRfU0hPVyQ0ID0gYHNob3cke0VWRU5UX0tFWSQ0fWA7XHJcbiAgY29uc3QgRVZFTlRfU0hPV04kNCA9IGBzaG93biR7RVZFTlRfS0VZJDR9YDtcclxuICBjb25zdCBFVkVOVF9SRVNJWkUkMSA9IGByZXNpemUke0VWRU5UX0tFWSQ0fWA7XHJcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfRElTTUlTUyA9IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVkkNH1gO1xyXG4gIGNvbnN0IEVWRU5UX01PVVNFRE9XTl9ESVNNSVNTID0gYG1vdXNlZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkNH1gO1xyXG4gIGNvbnN0IEVWRU5UX0tFWURPV05fRElTTUlTUyQxID0gYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZJDR9YDtcclxuICBjb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQyID0gYGNsaWNrJHtFVkVOVF9LRVkkNH0ke0RBVEFfQVBJX0tFWSQyfWA7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9PUEVOID0gJ21vZGFsLW9wZW4nO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQzID0gJ2ZhZGUnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ0ID0gJ3Nob3cnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfU1RBVElDID0gJ21vZGFsLXN0YXRpYyc7XHJcbiAgY29uc3QgT1BFTl9TRUxFQ1RPUiQxID0gJy5tb2RhbC5zaG93JztcclxuICBjb25zdCBTRUxFQ1RPUl9ESUFMT0cgPSAnLm1vZGFsLWRpYWxvZyc7XHJcbiAgY29uc3QgU0VMRUNUT1JfTU9EQUxfQk9EWSA9ICcubW9kYWwtYm9keSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMiA9ICdbZGF0YS1icy10b2dnbGU9XCJtb2RhbFwiXSc7XHJcbiAgY29uc3QgRGVmYXVsdCQ2ID0ge1xyXG4gICAgYmFja2Ryb3A6IHRydWUsXHJcbiAgICBmb2N1czogdHJ1ZSxcclxuICAgIGtleWJvYXJkOiB0cnVlXHJcbiAgfTtcclxuICBjb25zdCBEZWZhdWx0VHlwZSQ2ID0ge1xyXG4gICAgYmFja2Ryb3A6ICcoYm9vbGVhbnxzdHJpbmcpJyxcclxuICAgIGZvY3VzOiAnYm9vbGVhbicsXHJcbiAgICBrZXlib2FyZDogJ2Jvb2xlYW4nXHJcbiAgfTtcclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIE1vZGFsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcclxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcclxuICAgICAgdGhpcy5fZGlhbG9nID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9ESUFMT0csIHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgICB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpO1xyXG4gICAgICB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCk7XHJcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcclxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX3Njcm9sbEJhciA9IG5ldyBTY3JvbGxCYXJIZWxwZXIoKTtcclxuXHJcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICB9IC8vIEdldHRlcnNcclxuXHJcblxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdCQ2O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ2O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgICAgcmV0dXJuIE5BTUUkNztcclxuICAgIH0gLy8gUHVibGljXHJcblxyXG5cclxuICAgIHRvZ2dsZShyZWxhdGVkVGFyZ2V0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2hvdyhyZWxhdGVkVGFyZ2V0KSB7XHJcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ0LCB7XHJcbiAgICAgICAgcmVsYXRlZFRhcmdldFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XHJcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XHJcblxyXG4gICAgICB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpO1xyXG5cclxuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfT1BFTik7XHJcblxyXG4gICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcclxuXHJcbiAgICAgIHRoaXMuX2JhY2tkcm9wLnNob3coKCkgPT4gdGhpcy5fc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgIGlmICghdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNCk7XHJcblxyXG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcclxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XHJcblxyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDQpO1xyXG5cclxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9oaWRlTW9kYWwoKSwgdGhpcy5fZWxlbWVudCwgdGhpcy5faXNBbmltYXRlZCgpKTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICBmb3IgKGNvbnN0IGh0bWxFbGVtZW50IG9mIFt3aW5kb3csIHRoaXMuX2RpYWxvZ10pIHtcclxuICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGh0bWxFbGVtZW50LCBFVkVOVF9LRVkkNCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKTtcclxuXHJcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XHJcblxyXG4gICAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlVXBkYXRlKCkge1xyXG4gICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcclxuICAgIH0gLy8gUHJpdmF0ZVxyXG5cclxuXHJcbiAgICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xyXG4gICAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcclxuICAgICAgICBpc1Zpc2libGU6IEJvb2xlYW4odGhpcy5fY29uZmlnLmJhY2tkcm9wKSxcclxuICAgICAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWUsXHJcbiAgICAgICAgaXNBbmltYXRlZDogdGhpcy5faXNBbmltYXRlZCgpXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xyXG4gICAgICByZXR1cm4gbmV3IEZvY3VzVHJhcCh7XHJcbiAgICAgICAgdHJhcEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnRcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpIHtcclxuICAgICAgLy8gdHJ5IHRvIGFwcGVuZCBkeW5hbWljIG1vZGFsXHJcbiAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLl9lbGVtZW50KSkge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XHJcblxyXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsIHRydWUpO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJyk7XHJcblxyXG4gICAgICB0aGlzLl9lbGVtZW50LnNjcm9sbFRvcCA9IDA7XHJcbiAgICAgIGNvbnN0IG1vZGFsQm9keSA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfTU9EQUxfQk9EWSwgdGhpcy5fZGlhbG9nKTtcclxuXHJcbiAgICAgIGlmIChtb2RhbEJvZHkpIHtcclxuICAgICAgICBtb2RhbEJvZHkuc2Nyb2xsVG9wID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ0KTtcclxuXHJcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25Db21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XHJcbiAgICAgICAgICB0aGlzLl9mb2N1c3RyYXAuYWN0aXZhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDQsIHtcclxuICAgICAgICAgIHJlbGF0ZWRUYXJnZXRcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2sodHJhbnNpdGlvbkNvbXBsZXRlLCB0aGlzLl9kaWFsb2csIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTl9ESVNNSVNTJDEsIGV2ZW50ID0+IHtcclxuICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSBFU0NBUEVfS0VZJDEpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcclxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcclxuICAgICAgfSk7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX1JFU0laRSQxLCAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzU2hvd24gJiYgIXRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xyXG4gICAgICAgICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFRE9XTl9ESVNNSVNTLCBldmVudCA9PiB7XHJcbiAgICAgICAgLy8gYSBiYWQgdHJpY2sgdG8gc2VncmVnYXRlIGNsaWNrcyB0aGF0IG1heSBzdGFydCBpbnNpZGUgZGlhbG9nIGJ1dCBlbmQgb3V0c2lkZSwgYW5kIGF2b2lkIGxpc3RlbiB0byBzY3JvbGxiYXIgY2xpY2tzXHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDS19ESVNNSVNTLCBldmVudDIgPT4ge1xyXG4gICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQgIT09IGV2ZW50LnRhcmdldCB8fCB0aGlzLl9lbGVtZW50ICE9PSBldmVudDIudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xyXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xyXG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgX2hpZGVNb2RhbCgpIHtcclxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XHJcblxyXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcclxuXHJcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgdGhpcy5fYmFja2Ryb3AuaGlkZSgoKSA9PiB7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfT1BFTik7XHJcblxyXG4gICAgICAgIHRoaXMuX3Jlc2V0QWRqdXN0bWVudHMoKTtcclxuXHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XHJcblxyXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQ0KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgX2lzQW5pbWF0ZWQoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMyk7XHJcbiAgICB9XHJcblxyXG4gICAgX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKSB7XHJcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREVfUFJFVkVOVEVEJDEpO1xyXG5cclxuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgIGNvbnN0IGluaXRpYWxPdmVyZmxvd1kgPSB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WTsgLy8gcmV0dXJuIGlmIHRoZSBmb2xsb3dpbmcgYmFja2dyb3VuZCB0cmFuc2l0aW9uIGhhc24ndCB5ZXQgY29tcGxldGVkXHJcblxyXG4gICAgICBpZiAoaW5pdGlhbE92ZXJmbG93WSA9PT0gJ2hpZGRlbicgfHwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TVEFUSUMpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWlzTW9kYWxPdmVyZmxvd2luZykge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NUQVRJQyk7XHJcblxyXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TVEFUSUMpO1xyXG5cclxuICAgICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gaW5pdGlhbE92ZXJmbG93WTtcclxuICAgICAgICB9LCB0aGlzLl9kaWFsb2cpO1xyXG4gICAgICB9LCB0aGlzLl9kaWFsb2cpO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xyXG4gICAgICovXHJcblxyXG5cclxuICAgIF9hZGp1c3REaWFsb2coKSB7XHJcbiAgICAgIGNvbnN0IGlzTW9kYWxPdmVyZmxvd2luZyA9IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcclxuXHJcbiAgICAgIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gdGhpcy5fc2Nyb2xsQmFyLmdldFdpZHRoKCk7XHJcblxyXG4gICAgICBjb25zdCBpc0JvZHlPdmVyZmxvd2luZyA9IHNjcm9sbGJhcldpZHRoID4gMDtcclxuXHJcbiAgICAgIGlmIChpc0JvZHlPdmVyZmxvd2luZyAmJiAhaXNNb2RhbE92ZXJmbG93aW5nKSB7XHJcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBpc1JUTCgpID8gJ3BhZGRpbmdMZWZ0JyA6ICdwYWRkaW5nUmlnaHQnO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gYCR7c2Nyb2xsYmFyV2lkdGh9cHhgO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWlzQm9keU92ZXJmbG93aW5nICYmIGlzTW9kYWxPdmVyZmxvd2luZykge1xyXG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gaXNSVEwoKSA/ICdwYWRkaW5nUmlnaHQnIDogJ3BhZGRpbmdMZWZ0JztcclxuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IGAke3Njcm9sbGJhcldpZHRofXB4YDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9yZXNldEFkanVzdG1lbnRzKCkge1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gJyc7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XHJcbiAgICB9IC8vIFN0YXRpY1xyXG5cclxuXHJcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZywgcmVsYXRlZFRhcmdldCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRhdGFbY29uZmlnXShyZWxhdGVkVGFyZ2V0KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gIH1cclxuICAvKipcclxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxyXG4gICAqL1xyXG5cclxuXHJcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQyLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcyk7XHJcblxyXG4gICAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9TSE9XJDQsIHNob3dFdmVudCA9PiB7XHJcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9ISURERU4kNCwgKCkgPT4ge1xyXG4gICAgICAgIGlmIChpc1Zpc2libGUodGhpcykpIHtcclxuICAgICAgICAgIHRoaXMuZm9jdXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7IC8vIGF2b2lkIGNvbmZsaWN0IHdoZW4gY2xpY2tpbmcgbW9kYWwgdG9nZ2xlciB3aGlsZSBhbm90aGVyIG9uZSBpcyBvcGVuXHJcblxyXG4gICAgY29uc3QgYWxyZWFkeU9wZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKE9QRU5fU0VMRUNUT1IkMSk7XHJcblxyXG4gICAgaWYgKGFscmVhZHlPcGVuKSB7XHJcbiAgICAgIE1vZGFsLmdldEluc3RhbmNlKGFscmVhZHlPcGVuKS5oaWRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGF0YSA9IE1vZGFsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTtcclxuICAgIGRhdGEudG9nZ2xlKHRoaXMpO1xyXG4gIH0pO1xyXG4gIGVuYWJsZURpc21pc3NUcmlnZ2VyKE1vZGFsKTtcclxuICAvKipcclxuICAgKiBqUXVlcnlcclxuICAgKi9cclxuXHJcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKE1vZGFsKTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IG9mZmNhbnZhcy5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUkNiA9ICdvZmZjYW52YXMnO1xyXG4gIGNvbnN0IERBVEFfS0VZJDMgPSAnYnMub2ZmY2FudmFzJztcclxuICBjb25zdCBFVkVOVF9LRVkkMyA9IGAuJHtEQVRBX0tFWSQzfWA7XHJcbiAgY29uc3QgREFUQV9BUElfS0VZJDEgPSAnLmRhdGEtYXBpJztcclxuICBjb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDIgPSBgbG9hZCR7RVZFTlRfS0VZJDN9JHtEQVRBX0FQSV9LRVkkMX1gO1xyXG4gIGNvbnN0IEVTQ0FQRV9LRVkgPSAnRXNjYXBlJztcclxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckMyA9ICdzaG93JztcclxuICBjb25zdCBDTEFTU19OQU1FX1NIT1dJTkckMSA9ICdzaG93aW5nJztcclxuICBjb25zdCBDTEFTU19OQU1FX0hJRElORyA9ICdoaWRpbmcnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfQkFDS0RST1AgPSAnb2ZmY2FudmFzLWJhY2tkcm9wJztcclxuICBjb25zdCBPUEVOX1NFTEVDVE9SID0gJy5vZmZjYW52YXMuc2hvdyc7XHJcbiAgY29uc3QgRVZFTlRfU0hPVyQzID0gYHNob3cke0VWRU5UX0tFWSQzfWA7XHJcbiAgY29uc3QgRVZFTlRfU0hPV04kMyA9IGBzaG93biR7RVZFTlRfS0VZJDN9YDtcclxuICBjb25zdCBFVkVOVF9ISURFJDMgPSBgaGlkZSR7RVZFTlRfS0VZJDN9YDtcclxuICBjb25zdCBFVkVOVF9ISURFX1BSRVZFTlRFRCA9IGBoaWRlUHJldmVudGVkJHtFVkVOVF9LRVkkM31gO1xyXG4gIGNvbnN0IEVWRU5UX0hJRERFTiQzID0gYGhpZGRlbiR7RVZFTlRfS0VZJDN9YDtcclxuICBjb25zdCBFVkVOVF9SRVNJWkUgPSBgcmVzaXplJHtFVkVOVF9LRVkkM31gO1xyXG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDEgPSBgY2xpY2ske0VWRU5UX0tFWSQzfSR7REFUQV9BUElfS0VZJDF9YDtcclxuICBjb25zdCBFVkVOVF9LRVlET1dOX0RJU01JU1MgPSBga2V5ZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkM31gO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDEgPSAnW2RhdGEtYnMtdG9nZ2xlPVwib2ZmY2FudmFzXCJdJztcclxuICBjb25zdCBEZWZhdWx0JDUgPSB7XHJcbiAgICBiYWNrZHJvcDogdHJ1ZSxcclxuICAgIGtleWJvYXJkOiB0cnVlLFxyXG4gICAgc2Nyb2xsOiBmYWxzZVxyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkNSA9IHtcclxuICAgIGJhY2tkcm9wOiAnKGJvb2xlYW58c3RyaW5nKScsXHJcbiAgICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxyXG4gICAgc2Nyb2xsOiAnYm9vbGVhbidcclxuICB9O1xyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgT2ZmY2FudmFzIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcclxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcclxuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpO1xyXG4gICAgICB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCk7XHJcblxyXG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xyXG4gICAgfSAvLyBHZXR0ZXJzXHJcblxyXG5cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHQkNTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkNTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJDY7XHJcbiAgICB9IC8vIFB1YmxpY1xyXG5cclxuXHJcbiAgICB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHJlbGF0ZWRUYXJnZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHNob3cocmVsYXRlZFRhcmdldCkge1xyXG4gICAgICBpZiAodGhpcy5faXNTaG93bikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQzLCB7XHJcbiAgICAgICAgcmVsYXRlZFRhcmdldFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XHJcblxyXG4gICAgICB0aGlzLl9iYWNrZHJvcC5zaG93KCk7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwpIHtcclxuICAgICAgICBuZXcgU2Nyb2xsQmFySGVscGVyKCkuaGlkZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsIHRydWUpO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJyk7XHJcblxyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XSU5HJDEpO1xyXG5cclxuICAgICAgY29uc3QgY29tcGxldGVDYWxsQmFjayA9ICgpID0+IHtcclxuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgdGhpcy5fY29uZmlnLmJhY2tkcm9wKSB7XHJcbiAgICAgICAgICB0aGlzLl9mb2N1c3RyYXAuYWN0aXZhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckMyk7XHJcblxyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkckMSk7XHJcblxyXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDMsIHtcclxuICAgICAgICAgIHJlbGF0ZWRUYXJnZXRcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsQmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaGlkZSgpIHtcclxuICAgICAgaWYgKCF0aGlzLl9pc1Nob3duKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDMpO1xyXG5cclxuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5ibHVyKCk7XHJcblxyXG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XHJcblxyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9ISURJTkcpO1xyXG5cclxuICAgICAgdGhpcy5fYmFja2Ryb3AuaGlkZSgpO1xyXG5cclxuICAgICAgY29uc3QgY29tcGxldGVDYWxsYmFjayA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDMsIENMQVNTX05BTUVfSElESU5HKTtcclxuXHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKTtcclxuXHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsKSB7XHJcbiAgICAgICAgICBuZXcgU2Nyb2xsQmFySGVscGVyKCkucmVzZXQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQzKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsYmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpO1xyXG5cclxuICAgICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKTtcclxuXHJcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICAgIH0gLy8gUHJpdmF0ZVxyXG5cclxuXHJcbiAgICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xyXG4gICAgICBjb25zdCBjbGlja0NhbGxiYWNrID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XHJcbiAgICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgfTsgLy8gJ3N0YXRpYycgb3B0aW9uIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0cnVlLCBhbmQgYm9vbGVhbnMgd2lsbCBrZWVwIHRoZWlyIHZhbHVlXHJcblxyXG5cclxuICAgICAgY29uc3QgaXNWaXNpYmxlID0gQm9vbGVhbih0aGlzLl9jb25maWcuYmFja2Ryb3ApO1xyXG4gICAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcclxuICAgICAgICBjbGFzc05hbWU6IENMQVNTX05BTUVfQkFDS0RST1AsXHJcbiAgICAgICAgaXNWaXNpYmxlLFxyXG4gICAgICAgIGlzQW5pbWF0ZWQ6IHRydWUsXHJcbiAgICAgICAgcm9vdEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSxcclxuICAgICAgICBjbGlja0NhbGxiYWNrOiBpc1Zpc2libGUgPyBjbGlja0NhbGxiYWNrIDogbnVsbFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcclxuICAgICAgcmV0dXJuIG5ldyBGb2N1c1RyYXAoe1xyXG4gICAgICAgIHRyYXBFbGVtZW50OiB0aGlzLl9lbGVtZW50XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIF9hZGRFdmVudExpc3RlbmVycygpIHtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUywgZXZlbnQgPT4ge1xyXG4gICAgICAgIGlmIChldmVudC5rZXkgIT09IEVTQ0FQRV9LRVkpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XHJcbiAgICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgfSk7XHJcbiAgICB9IC8vIFN0YXRpY1xyXG5cclxuXHJcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICB9XHJcbiAgLyoqXHJcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cclxuICAgKi9cclxuXHJcblxyXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMSwgU0VMRUNUT1JfREFUQV9UT0dHTEUkMSwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpO1xyXG5cclxuICAgIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX0hJRERFTiQzLCAoKSA9PiB7XHJcbiAgICAgIC8vIGZvY3VzIG9uIHRyaWdnZXIgd2hlbiBpdCBpcyBjbG9zZWRcclxuICAgICAgaWYgKGlzVmlzaWJsZSh0aGlzKSkge1xyXG4gICAgICAgIHRoaXMuZm9jdXMoKTtcclxuICAgICAgfVxyXG4gICAgfSk7IC8vIGF2b2lkIGNvbmZsaWN0IHdoZW4gY2xpY2tpbmcgYSB0b2dnbGVyIG9mIGFuIG9mZmNhbnZhcywgd2hpbGUgYW5vdGhlciBpcyBvcGVuXHJcblxyXG4gICAgY29uc3QgYWxyZWFkeU9wZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKE9QRU5fU0VMRUNUT1IpO1xyXG5cclxuICAgIGlmIChhbHJlYWR5T3BlbiAmJiBhbHJlYWR5T3BlbiAhPT0gdGFyZ2V0KSB7XHJcbiAgICAgIE9mZmNhbnZhcy5nZXRJbnN0YW5jZShhbHJlYWR5T3BlbikuaGlkZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRhdGEgPSBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpO1xyXG4gICAgZGF0YS50b2dnbGUodGhpcyk7XHJcbiAgfSk7XHJcbiAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQyLCAoKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IHNlbGVjdG9yIG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoT1BFTl9TRUxFQ1RPUikpIHtcclxuICAgICAgT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2Uoc2VsZWN0b3IpLnNob3coKTtcclxuICAgIH1cclxuICB9KTtcclxuICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9SRVNJWkUsICgpID0+IHtcclxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBTZWxlY3RvckVuZ2luZS5maW5kKCdbYXJpYS1tb2RhbF1bY2xhc3MqPXNob3ddW2NsYXNzKj1vZmZjYW52YXMtXScpKSB7XHJcbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XHJcbiAgICAgICAgT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCkuaGlkZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoT2ZmY2FudmFzKTtcclxuICAvKipcclxuICAgKiBqUXVlcnlcclxuICAgKi9cclxuXHJcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKE9mZmNhbnZhcyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwICh2NS4yLjMpOiB1dGlsL3Nhbml0aXplci5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcbiAgY29uc3QgdXJpQXR0cmlidXRlcyA9IG5ldyBTZXQoWydiYWNrZ3JvdW5kJywgJ2NpdGUnLCAnaHJlZicsICdpdGVtdHlwZScsICdsb25nZGVzYycsICdwb3N0ZXInLCAnc3JjJywgJ3hsaW5rOmhyZWYnXSk7XHJcbiAgY29uc3QgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiA9IC9eYXJpYS1bXFx3LV0qJC9pO1xyXG4gIC8qKlxyXG4gICAqIEEgcGF0dGVybiB0aGF0IHJlY29nbml6ZXMgYSBjb21tb25seSB1c2VmdWwgc3Vic2V0IG9mIFVSTHMgdGhhdCBhcmUgc2FmZS5cclxuICAgKlxyXG4gICAqIFNob3V0LW91dCB0byBBbmd1bGFyIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi8xMi4yLngvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgU0FGRV9VUkxfUEFUVEVSTiA9IC9eKD86KD86aHR0cHM/fG1haWx0b3xmdHB8dGVsfGZpbGV8c21zKTp8W14jJi86P10qKD86WyMvP118JCkpL2k7XHJcbiAgLyoqXHJcbiAgICogQSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyBzYWZlIGRhdGEgVVJMcy4gT25seSBtYXRjaGVzIGltYWdlLCB2aWRlbyBhbmQgYXVkaW8gdHlwZXMuXHJcbiAgICpcclxuICAgKiBTaG91dC1vdXQgdG8gQW5ndWxhciBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvMTIuMi54L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IERBVEFfVVJMX1BBVFRFUk4gPSAvXmRhdGE6KD86aW1hZ2VcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnApfHZpZGVvXFwvKD86bXBlZ3xtcDR8b2dnfHdlYm0pfGF1ZGlvXFwvKD86bXAzfG9nYXxvZ2d8b3B1cykpO2Jhc2U2NCxbXFxkKy9hLXpdKz0qJC9pO1xyXG5cclxuICBjb25zdCBhbGxvd2VkQXR0cmlidXRlID0gKGF0dHJpYnV0ZSwgYWxsb3dlZEF0dHJpYnV0ZUxpc3QpID0+IHtcclxuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICBpZiAoYWxsb3dlZEF0dHJpYnV0ZUxpc3QuaW5jbHVkZXMoYXR0cmlidXRlTmFtZSkpIHtcclxuICAgICAgaWYgKHVyaUF0dHJpYnV0ZXMuaGFzKGF0dHJpYnV0ZU5hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oU0FGRV9VUkxfUEFUVEVSTi50ZXN0KGF0dHJpYnV0ZS5ub2RlVmFsdWUpIHx8IERBVEFfVVJMX1BBVFRFUk4udGVzdChhdHRyaWJ1dGUubm9kZVZhbHVlKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSAvLyBDaGVjayBpZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB2YWxpZGF0ZXMgdGhlIGF0dHJpYnV0ZS5cclxuXHJcblxyXG4gICAgcmV0dXJuIGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmZpbHRlcihhdHRyaWJ1dGVSZWdleCA9PiBhdHRyaWJ1dGVSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCkuc29tZShyZWdleCA9PiByZWdleC50ZXN0KGF0dHJpYnV0ZU5hbWUpKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBEZWZhdWx0QWxsb3dsaXN0ID0ge1xyXG4gICAgLy8gR2xvYmFsIGF0dHJpYnV0ZXMgYWxsb3dlZCBvbiBhbnkgc3VwcGxpZWQgZWxlbWVudCBiZWxvdy5cclxuICAgICcqJzogWydjbGFzcycsICdkaXInLCAnaWQnLCAnbGFuZycsICdyb2xlJywgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTl0sXHJcbiAgICBhOiBbJ3RhcmdldCcsICdocmVmJywgJ3RpdGxlJywgJ3JlbCddLFxyXG4gICAgYXJlYTogW10sXHJcbiAgICBiOiBbXSxcclxuICAgIGJyOiBbXSxcclxuICAgIGNvbDogW10sXHJcbiAgICBjb2RlOiBbXSxcclxuICAgIGRpdjogW10sXHJcbiAgICBlbTogW10sXHJcbiAgICBocjogW10sXHJcbiAgICBoMTogW10sXHJcbiAgICBoMjogW10sXHJcbiAgICBoMzogW10sXHJcbiAgICBoNDogW10sXHJcbiAgICBoNTogW10sXHJcbiAgICBoNjogW10sXHJcbiAgICBpOiBbXSxcclxuICAgIGltZzogWydzcmMnLCAnc3Jjc2V0JywgJ2FsdCcsICd0aXRsZScsICd3aWR0aCcsICdoZWlnaHQnXSxcclxuICAgIGxpOiBbXSxcclxuICAgIG9sOiBbXSxcclxuICAgIHA6IFtdLFxyXG4gICAgcHJlOiBbXSxcclxuICAgIHM6IFtdLFxyXG4gICAgc21hbGw6IFtdLFxyXG4gICAgc3BhbjogW10sXHJcbiAgICBzdWI6IFtdLFxyXG4gICAgc3VwOiBbXSxcclxuICAgIHN0cm9uZzogW10sXHJcbiAgICB1OiBbXSxcclxuICAgIHVsOiBbXVxyXG4gIH07XHJcbiAgZnVuY3Rpb24gc2FuaXRpemVIdG1sKHVuc2FmZUh0bWwsIGFsbG93TGlzdCwgc2FuaXRpemVGdW5jdGlvbikge1xyXG4gICAgaWYgKCF1bnNhZmVIdG1sLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gdW5zYWZlSHRtbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2FuaXRpemVGdW5jdGlvbiAmJiB0eXBlb2Ygc2FuaXRpemVGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gc2FuaXRpemVGdW5jdGlvbih1bnNhZmVIdG1sKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkb21QYXJzZXIgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpO1xyXG4gICAgY29uc3QgY3JlYXRlZERvY3VtZW50ID0gZG9tUGFyc2VyLnBhcnNlRnJvbVN0cmluZyh1bnNhZmVIdG1sLCAndGV4dC9odG1sJyk7XHJcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdLmNvbmNhdCguLi5jcmVhdGVkRG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yQWxsKCcqJykpO1xyXG5cclxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xyXG4gICAgICBjb25zdCBlbGVtZW50TmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgIGlmICghT2JqZWN0LmtleXMoYWxsb3dMaXN0KS5pbmNsdWRlcyhlbGVtZW50TmFtZSkpIHtcclxuICAgICAgICBlbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBhdHRyaWJ1dGVMaXN0ID0gW10uY29uY2F0KC4uLmVsZW1lbnQuYXR0cmlidXRlcyk7XHJcbiAgICAgIGNvbnN0IGFsbG93ZWRBdHRyaWJ1dGVzID0gW10uY29uY2F0KGFsbG93TGlzdFsnKiddIHx8IFtdLCBhbGxvd0xpc3RbZWxlbWVudE5hbWVdIHx8IFtdKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZUxpc3QpIHtcclxuICAgICAgICBpZiAoIWFsbG93ZWRBdHRyaWJ1dGUoYXR0cmlidXRlLCBhbGxvd2VkQXR0cmlidXRlcykpIHtcclxuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZS5ub2RlTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNyZWF0ZWREb2N1bWVudC5ib2R5LmlubmVySFRNTDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwICh2NS4yLjMpOiB1dGlsL3RlbXBsYXRlLWZhY3RvcnkuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJDUgPSAnVGVtcGxhdGVGYWN0b3J5JztcclxuICBjb25zdCBEZWZhdWx0JDQgPSB7XHJcbiAgICBhbGxvd0xpc3Q6IERlZmF1bHRBbGxvd2xpc3QsXHJcbiAgICBjb250ZW50OiB7fSxcclxuICAgIC8vIHsgc2VsZWN0b3IgOiB0ZXh0ICwgIHNlbGVjdG9yMiA6IHRleHQyICwgfVxyXG4gICAgZXh0cmFDbGFzczogJycsXHJcbiAgICBodG1sOiBmYWxzZSxcclxuICAgIHNhbml0aXplOiB0cnVlLFxyXG4gICAgc2FuaXRpemVGbjogbnVsbCxcclxuICAgIHRlbXBsYXRlOiAnPGRpdj48L2Rpdj4nXHJcbiAgfTtcclxuICBjb25zdCBEZWZhdWx0VHlwZSQ0ID0ge1xyXG4gICAgYWxsb3dMaXN0OiAnb2JqZWN0JyxcclxuICAgIGNvbnRlbnQ6ICdvYmplY3QnLFxyXG4gICAgZXh0cmFDbGFzczogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcclxuICAgIGh0bWw6ICdib29sZWFuJyxcclxuICAgIHNhbml0aXplOiAnYm9vbGVhbicsXHJcbiAgICBzYW5pdGl6ZUZuOiAnKG51bGx8ZnVuY3Rpb24pJyxcclxuICAgIHRlbXBsYXRlOiAnc3RyaW5nJ1xyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdENvbnRlbnRUeXBlID0ge1xyXG4gICAgZW50cnk6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb258bnVsbCknLFxyXG4gICAgc2VsZWN0b3I6ICcoc3RyaW5nfGVsZW1lbnQpJ1xyXG4gIH07XHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBUZW1wbGF0ZUZhY3RvcnkgZXh0ZW5kcyBDb25maWcge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xyXG4gICAgfSAvLyBHZXR0ZXJzXHJcblxyXG5cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHQkNDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkNDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJDU7XHJcbiAgICB9IC8vIFB1YmxpY1xyXG5cclxuXHJcbiAgICBnZXRDb250ZW50KCkge1xyXG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9jb25maWcuY29udGVudCkubWFwKGNvbmZpZyA9PiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihjb25maWcpKS5maWx0ZXIoQm9vbGVhbik7XHJcbiAgICB9XHJcblxyXG4gICAgaGFzQ29udGVudCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29udGVudCgpLmxlbmd0aCA+IDA7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhbmdlQ29udGVudChjb250ZW50KSB7XHJcbiAgICAgIHRoaXMuX2NoZWNrQ29udGVudChjb250ZW50KTtcclxuXHJcbiAgICAgIHRoaXMuX2NvbmZpZy5jb250ZW50ID0geyAuLi50aGlzLl9jb25maWcuY29udGVudCxcclxuICAgICAgICAuLi5jb250ZW50XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHRvSHRtbCgpIHtcclxuICAgICAgY29uc3QgdGVtcGxhdGVXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgIHRlbXBsYXRlV3JhcHBlci5pbm5lckhUTUwgPSB0aGlzLl9tYXliZVNhbml0aXplKHRoaXMuX2NvbmZpZy50ZW1wbGF0ZSk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IFtzZWxlY3RvciwgdGV4dF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5fY29uZmlnLmNvbnRlbnQpKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0Q29udGVudCh0ZW1wbGF0ZVdyYXBwZXIsIHRleHQsIHNlbGVjdG9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZVdyYXBwZXIuY2hpbGRyZW5bMF07XHJcblxyXG4gICAgICBjb25zdCBleHRyYUNsYXNzID0gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmV4dHJhQ2xhc3MpO1xyXG5cclxuICAgICAgaWYgKGV4dHJhQ2xhc3MpIHtcclxuICAgICAgICB0ZW1wbGF0ZS5jbGFzc0xpc3QuYWRkKC4uLmV4dHJhQ2xhc3Muc3BsaXQoJyAnKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0ZW1wbGF0ZTtcclxuICAgIH0gLy8gUHJpdmF0ZVxyXG5cclxuXHJcbiAgICBfdHlwZUNoZWNrQ29uZmlnKGNvbmZpZykge1xyXG4gICAgICBzdXBlci5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XHJcblxyXG4gICAgICB0aGlzLl9jaGVja0NvbnRlbnQoY29uZmlnLmNvbnRlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIF9jaGVja0NvbnRlbnQoYXJnKSB7XHJcbiAgICAgIGZvciAoY29uc3QgW3NlbGVjdG9yLCBjb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhhcmcpKSB7XHJcbiAgICAgICAgc3VwZXIuX3R5cGVDaGVja0NvbmZpZyh7XHJcbiAgICAgICAgICBzZWxlY3RvcixcclxuICAgICAgICAgIGVudHJ5OiBjb250ZW50XHJcbiAgICAgICAgfSwgRGVmYXVsdENvbnRlbnRUeXBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9zZXRDb250ZW50KHRlbXBsYXRlLCBjb250ZW50LCBzZWxlY3Rvcikge1xyXG4gICAgICBjb25zdCB0ZW1wbGF0ZUVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKHNlbGVjdG9yLCB0ZW1wbGF0ZSk7XHJcblxyXG4gICAgICBpZiAoIXRlbXBsYXRlRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29udGVudCA9IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGNvbnRlbnQpO1xyXG5cclxuICAgICAgaWYgKCFjb250ZW50KSB7XHJcbiAgICAgICAgdGVtcGxhdGVFbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzRWxlbWVudCQxKGNvbnRlbnQpKSB7XHJcbiAgICAgICAgdGhpcy5fcHV0RWxlbWVudEluVGVtcGxhdGUoZ2V0RWxlbWVudChjb250ZW50KSwgdGVtcGxhdGVFbGVtZW50KTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmh0bWwpIHtcclxuICAgICAgICB0ZW1wbGF0ZUVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5fbWF5YmVTYW5pdGl6ZShjb250ZW50KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRlbXBsYXRlRWxlbWVudC50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgX21heWJlU2FuaXRpemUoYXJnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9jb25maWcuc2FuaXRpemUgPyBzYW5pdGl6ZUh0bWwoYXJnLCB0aGlzLl9jb25maWcuYWxsb3dMaXN0LCB0aGlzLl9jb25maWcuc2FuaXRpemVGbikgOiBhcmc7XHJcbiAgICB9XHJcblxyXG4gICAgX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGFyZykge1xyXG4gICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGFyZyh0aGlzKSA6IGFyZztcclxuICAgIH1cclxuXHJcbiAgICBfcHV0RWxlbWVudEluVGVtcGxhdGUoZWxlbWVudCwgdGVtcGxhdGVFbGVtZW50KSB7XHJcbiAgICAgIGlmICh0aGlzLl9jb25maWcuaHRtbCkge1xyXG4gICAgICAgIHRlbXBsYXRlRWxlbWVudC5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICB0ZW1wbGF0ZUVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGVtcGxhdGVFbGVtZW50LnRleHRDb250ZW50ID0gZWxlbWVudC50ZXh0Q29udGVudDtcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogdG9vbHRpcC5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUkNCA9ICd0b29sdGlwJztcclxuICBjb25zdCBESVNBTExPV0VEX0FUVFJJQlVURVMgPSBuZXcgU2V0KFsnc2FuaXRpemUnLCAnYWxsb3dMaXN0JywgJ3Nhbml0aXplRm4nXSk7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9GQURFJDIgPSAnZmFkZSc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9NT0RBTCA9ICdtb2RhbCc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDIgPSAnc2hvdyc7XHJcbiAgY29uc3QgU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiA9ICcudG9vbHRpcC1pbm5lcic7XHJcbiAgY29uc3QgU0VMRUNUT1JfTU9EQUwgPSBgLiR7Q0xBU1NfTkFNRV9NT0RBTH1gO1xyXG4gIGNvbnN0IEVWRU5UX01PREFMX0hJREUgPSAnaGlkZS5icy5tb2RhbCc7XHJcbiAgY29uc3QgVFJJR0dFUl9IT1ZFUiA9ICdob3Zlcic7XHJcbiAgY29uc3QgVFJJR0dFUl9GT0NVUyA9ICdmb2N1cyc7XHJcbiAgY29uc3QgVFJJR0dFUl9DTElDSyA9ICdjbGljayc7XHJcbiAgY29uc3QgVFJJR0dFUl9NQU5VQUwgPSAnbWFudWFsJztcclxuICBjb25zdCBFVkVOVF9ISURFJDIgPSAnaGlkZSc7XHJcbiAgY29uc3QgRVZFTlRfSElEREVOJDIgPSAnaGlkZGVuJztcclxuICBjb25zdCBFVkVOVF9TSE9XJDIgPSAnc2hvdyc7XHJcbiAgY29uc3QgRVZFTlRfU0hPV04kMiA9ICdzaG93bic7XHJcbiAgY29uc3QgRVZFTlRfSU5TRVJURUQgPSAnaW5zZXJ0ZWQnO1xyXG4gIGNvbnN0IEVWRU5UX0NMSUNLJDEgPSAnY2xpY2snO1xyXG4gIGNvbnN0IEVWRU5UX0ZPQ1VTSU4kMSA9ICdmb2N1c2luJztcclxuICBjb25zdCBFVkVOVF9GT0NVU09VVCQxID0gJ2ZvY3Vzb3V0JztcclxuICBjb25zdCBFVkVOVF9NT1VTRUVOVEVSID0gJ21vdXNlZW50ZXInO1xyXG4gIGNvbnN0IEVWRU5UX01PVVNFTEVBVkUgPSAnbW91c2VsZWF2ZSc7XHJcbiAgY29uc3QgQXR0YWNobWVudE1hcCA9IHtcclxuICAgIEFVVE86ICdhdXRvJyxcclxuICAgIFRPUDogJ3RvcCcsXHJcbiAgICBSSUdIVDogaXNSVEwoKSA/ICdsZWZ0JyA6ICdyaWdodCcsXHJcbiAgICBCT1RUT006ICdib3R0b20nLFxyXG4gICAgTEVGVDogaXNSVEwoKSA/ICdyaWdodCcgOiAnbGVmdCdcclxuICB9O1xyXG4gIGNvbnN0IERlZmF1bHQkMyA9IHtcclxuICAgIGFsbG93TGlzdDogRGVmYXVsdEFsbG93bGlzdCxcclxuICAgIGFuaW1hdGlvbjogdHJ1ZSxcclxuICAgIGJvdW5kYXJ5OiAnY2xpcHBpbmdQYXJlbnRzJyxcclxuICAgIGNvbnRhaW5lcjogZmFsc2UsXHJcbiAgICBjdXN0b21DbGFzczogJycsXHJcbiAgICBkZWxheTogMCxcclxuICAgIGZhbGxiYWNrUGxhY2VtZW50czogWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcclxuICAgIGh0bWw6IGZhbHNlLFxyXG4gICAgb2Zmc2V0OiBbMCwgMF0sXHJcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxyXG4gICAgcG9wcGVyQ29uZmlnOiBudWxsLFxyXG4gICAgc2FuaXRpemU6IHRydWUsXHJcbiAgICBzYW5pdGl6ZUZuOiBudWxsLFxyXG4gICAgc2VsZWN0b3I6IGZhbHNlLFxyXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwidG9vbHRpcFwiIHJvbGU9XCJ0b29sdGlwXCI+JyArICc8ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvd1wiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj4nICsgJzwvZGl2PicsXHJcbiAgICB0aXRsZTogJycsXHJcbiAgICB0cmlnZ2VyOiAnaG92ZXIgZm9jdXMnXHJcbiAgfTtcclxuICBjb25zdCBEZWZhdWx0VHlwZSQzID0ge1xyXG4gICAgYWxsb3dMaXN0OiAnb2JqZWN0JyxcclxuICAgIGFuaW1hdGlvbjogJ2Jvb2xlYW4nLFxyXG4gICAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcclxuICAgIGNvbnRhaW5lcjogJyhzdHJpbmd8ZWxlbWVudHxib29sZWFuKScsXHJcbiAgICBjdXN0b21DbGFzczogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcclxuICAgIGRlbGF5OiAnKG51bWJlcnxvYmplY3QpJyxcclxuICAgIGZhbGxiYWNrUGxhY2VtZW50czogJ2FycmF5JyxcclxuICAgIGh0bWw6ICdib29sZWFuJyxcclxuICAgIG9mZnNldDogJyhhcnJheXxzdHJpbmd8ZnVuY3Rpb24pJyxcclxuICAgIHBsYWNlbWVudDogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcclxuICAgIHBvcHBlckNvbmZpZzogJyhudWxsfG9iamVjdHxmdW5jdGlvbiknLFxyXG4gICAgc2FuaXRpemU6ICdib29sZWFuJyxcclxuICAgIHNhbml0aXplRm46ICcobnVsbHxmdW5jdGlvbiknLFxyXG4gICAgc2VsZWN0b3I6ICcoc3RyaW5nfGJvb2xlYW4pJyxcclxuICAgIHRlbXBsYXRlOiAnc3RyaW5nJyxcclxuICAgIHRpdGxlOiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKScsXHJcbiAgICB0cmlnZ2VyOiAnc3RyaW5nJ1xyXG4gIH07XHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBUb29sdGlwIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcclxuICAgICAgaWYgKHR5cGVvZiBQb3BwZXIgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyB0b29sdGlwcyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpOyAvLyBQcml2YXRlXHJcblxyXG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLl90aW1lb3V0ID0gMDtcclxuICAgICAgdGhpcy5faXNIb3ZlcmVkID0gbnVsbDtcclxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IHt9O1xyXG4gICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xyXG4gICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkgPSBudWxsO1xyXG4gICAgICB0aGlzLl9uZXdDb250ZW50ID0gbnVsbDsgLy8gUHJvdGVjdGVkXHJcblxyXG4gICAgICB0aGlzLnRpcCA9IG51bGw7XHJcblxyXG4gICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcclxuXHJcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnNlbGVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5fZml4VGl0bGUoKTtcclxuICAgICAgfVxyXG4gICAgfSAvLyBHZXR0ZXJzXHJcblxyXG5cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHQkMztcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkMztcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJDQ7XHJcbiAgICB9IC8vIFB1YmxpY1xyXG5cclxuXHJcbiAgICBlbmFibGUoKSB7XHJcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZGlzYWJsZSgpIHtcclxuICAgICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdG9nZ2xlRW5hYmxlZCgpIHtcclxuICAgICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcclxuICAgIH1cclxuXHJcbiAgICB0b2dnbGUoKSB7XHJcbiAgICAgIGlmICghdGhpcy5faXNFbmFibGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyLmNsaWNrID0gIXRoaXMuX2FjdGl2ZVRyaWdnZXIuY2xpY2s7XHJcblxyXG4gICAgICBpZiAodGhpcy5faXNTaG93bigpKSB7XHJcbiAgICAgICAgdGhpcy5fbGVhdmUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9lbnRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LmNsb3Nlc3QoU0VMRUNUT1JfTU9EQUwpLCBFVkVOVF9NT0RBTF9ISURFLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScpKSB7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKTtcclxuXHJcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBzaG93KCkge1xyXG4gICAgICBpZiAodGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSB1c2Ugc2hvdyBvbiB2aXNpYmxlIGVsZW1lbnRzJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKHRoaXMuX2lzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9TSE9XJDIpKTtcclxuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGZpbmRTaGFkb3dSb290KHRoaXMuX2VsZW1lbnQpO1xyXG5cclxuICAgICAgY29uc3QgaXNJblRoZURvbSA9IChzaGFkb3dSb290IHx8IHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpO1xyXG5cclxuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFpc0luVGhlRG9tKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9IC8vIHRvZG8gdjYgcmVtb3ZlIHRoaXMgT1IgbWFrZSBpdCBvcHRpb25hbFxyXG5cclxuXHJcbiAgICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKTtcclxuXHJcbiAgICAgIGNvbnN0IHRpcCA9IHRoaXMuX2dldFRpcEVsZW1lbnQoKTtcclxuXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGlwLmdldEF0dHJpYnV0ZSgnaWQnKSk7XHJcblxyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgY29udGFpbmVyXHJcbiAgICAgIH0gPSB0aGlzLl9jb25maWc7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy50aXApKSB7XHJcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZCh0aXApO1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0lOU0VSVEVEKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX3BvcHBlciA9IHRoaXMuX2NyZWF0ZVBvcHBlcih0aXApO1xyXG4gICAgICB0aXAuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckMik7IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcclxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcclxuICAgICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcclxuICAgICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXHJcblxyXG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX1NIT1dOJDIpKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2lzSG92ZXJlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIHRoaXMuX2xlYXZlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgIGlmICghdGhpcy5faXNTaG93bigpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9ISURFJDIpKTtcclxuXHJcbiAgICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGlwRWxlbWVudCgpO1xyXG5cclxuICAgICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDIpOyAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxyXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxyXG5cclxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcclxuICAgICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0NMSUNLXSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfRk9DVVNdID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9IT1ZFUl0gPSBmYWxzZTtcclxuICAgICAgdGhpcy5faXNIb3ZlcmVkID0gbnVsbDsgLy8gaXQgaXMgYSB0cmljayB0byBzdXBwb3J0IG1hbnVhbCB0cmlnZ2VyaW5nXHJcblxyXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX2lzSG92ZXJlZCkge1xyXG4gICAgICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcclxuXHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSElEREVOJDIpKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xyXG4gICAgICAgIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcclxuICAgICAgfVxyXG4gICAgfSAvLyBQcm90ZWN0ZWRcclxuXHJcblxyXG4gICAgX2lzV2l0aENvbnRlbnQoKSB7XHJcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuX2dldFRpdGxlKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIF9nZXRUaXBFbGVtZW50KCkge1xyXG4gICAgICBpZiAoIXRoaXMudGlwKSB7XHJcbiAgICAgICAgdGhpcy50aXAgPSB0aGlzLl9jcmVhdGVUaXBFbGVtZW50KHRoaXMuX25ld0NvbnRlbnQgfHwgdGhpcy5fZ2V0Q29udGVudEZvclRlbXBsYXRlKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy50aXA7XHJcbiAgICB9XHJcblxyXG4gICAgX2NyZWF0ZVRpcEVsZW1lbnQoY29udGVudCkge1xyXG4gICAgICBjb25zdCB0aXAgPSB0aGlzLl9nZXRUZW1wbGF0ZUZhY3RvcnkoY29udGVudCkudG9IdG1sKCk7IC8vIHRvZG86IHJlbW92ZSB0aGlzIGNoZWNrIG9uIHY2XHJcblxyXG5cclxuICAgICAgaWYgKCF0aXApIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9GQURFJDIsIENMQVNTX05BTUVfU0hPVyQyKTsgLy8gdG9kbzogb24gdjYgdGhlIGZvbGxvd2luZyBjYW4gYmUgYWNoaWV2ZWQgd2l0aCBDU1Mgb25seVxyXG5cclxuICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoYGJzLSR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfS1hdXRvYCk7XHJcbiAgICAgIGNvbnN0IHRpcElkID0gZ2V0VUlEKHRoaXMuY29uc3RydWN0b3IuTkFNRSkudG9TdHJpbmcoKTtcclxuICAgICAgdGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aXBJZCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5faXNBbmltYXRlZCgpKSB7XHJcbiAgICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9GQURFJDIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGlwO1xyXG4gICAgfVxyXG5cclxuICAgIHNldENvbnRlbnQoY29udGVudCkge1xyXG4gICAgICB0aGlzLl9uZXdDb250ZW50ID0gY29udGVudDtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKCkpIHtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlUG9wcGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgX2dldFRlbXBsYXRlRmFjdG9yeShjb250ZW50KSB7XHJcbiAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZUZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkuY2hhbmdlQ29udGVudChjb250ZW50KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkgPSBuZXcgVGVtcGxhdGVGYWN0b3J5KHsgLi4udGhpcy5fY29uZmlnLFxyXG4gICAgICAgICAgLy8gdGhlIGBjb250ZW50YCB2YXIgaGFzIHRvIGJlIGFmdGVyIGB0aGlzLl9jb25maWdgXHJcbiAgICAgICAgICAvLyB0byBvdmVycmlkZSBjb25maWcuY29udGVudCBpbiBjYXNlIG9mIHBvcG92ZXJcclxuICAgICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgICBleHRyYUNsYXNzOiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY3VzdG9tQ2xhc3MpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZUZhY3Rvcnk7XHJcbiAgICB9XHJcblxyXG4gICAgX2dldENvbnRlbnRGb3JUZW1wbGF0ZSgpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBbU0VMRUNUT1JfVE9PTFRJUF9JTk5FUl06IHRoaXMuX2dldFRpdGxlKClcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBfZ2V0VGl0bGUoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcudGl0bGUpIHx8IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJyk7XHJcbiAgICB9IC8vIFByaXZhdGVcclxuXHJcblxyXG4gICAgX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5nZXRPckNyZWF0ZUluc3RhbmNlKGV2ZW50LmRlbGVnYXRlVGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcclxuICAgIH1cclxuXHJcbiAgICBfaXNBbmltYXRlZCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gfHwgdGhpcy50aXAgJiYgdGhpcy50aXAuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQyKTtcclxuICAgIH1cclxuXHJcbiAgICBfaXNTaG93bigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudGlwICYmIHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckMik7XHJcbiAgICB9XHJcblxyXG4gICAgX2NyZWF0ZVBvcHBlcih0aXApIHtcclxuICAgICAgY29uc3QgcGxhY2VtZW50ID0gdHlwZW9mIHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9jb25maWcucGxhY2VtZW50LmNhbGwodGhpcywgdGlwLCB0aGlzLl9lbGVtZW50KSA6IHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQ7XHJcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnQgPSBBdHRhY2htZW50TWFwW3BsYWNlbWVudC50b1VwcGVyQ2FzZSgpXTtcclxuICAgICAgcmV0dXJuIGNyZWF0ZVBvcHBlcih0aGlzLl9lbGVtZW50LCB0aXAsIHRoaXMuX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSk7XHJcbiAgICB9XHJcblxyXG4gICAgX2dldE9mZnNldCgpIHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIG9mZnNldFxyXG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldC5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiBOdW1iZXIucGFyc2VJbnQodmFsdWUsIDEwKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIHBvcHBlckRhdGEgPT4gb2Zmc2V0KHBvcHBlckRhdGEsIHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIF9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihhcmcpIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicgPyBhcmcuY2FsbCh0aGlzLl9lbGVtZW50KSA6IGFyZztcclxuICAgIH1cclxuXHJcbiAgICBfZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpIHtcclxuICAgICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xyXG4gICAgICAgIHBsYWNlbWVudDogYXR0YWNobWVudCxcclxuICAgICAgICBtb2RpZmllcnM6IFt7XHJcbiAgICAgICAgICBuYW1lOiAnZmxpcCcsXHJcbiAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogdGhpcy5fY29uZmlnLmZhbGxiYWNrUGxhY2VtZW50c1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxyXG4gICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXHJcbiAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBuYW1lOiAnYXJyb3cnLFxyXG4gICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBlbGVtZW50OiBgLiR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfS1hcnJvd2BcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBuYW1lOiAncHJlU2V0UGxhY2VtZW50JyxcclxuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgICBwaGFzZTogJ2JlZm9yZU1haW4nLFxyXG4gICAgICAgICAgZm46IGRhdGEgPT4ge1xyXG4gICAgICAgICAgICAvLyBQcmUtc2V0IFBvcHBlcidzIHBsYWNlbWVudCBhdHRyaWJ1dGUgaW4gb3JkZXIgdG8gcmVhZCB0aGUgYXJyb3cgc2l6ZXMgcHJvcGVybHkuXHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgUG9wcGVyIG1peGVzIHVwIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGRpbWVuc2lvbnMgc2luY2UgdGhlIGluaXRpYWwgYXJyb3cgc3R5bGUgaXMgZm9yIHRvcCBwbGFjZW1lbnRcclxuICAgICAgICAgICAgdGhpcy5fZ2V0VGlwRWxlbWVudCgpLnNldEF0dHJpYnV0ZSgnZGF0YS1wb3BwZXItcGxhY2VtZW50JywgZGF0YS5zdGF0ZS5wbGFjZW1lbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1dXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiB7IC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcclxuICAgICAgICAuLi4odHlwZW9mIHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKGRlZmF1bHRCc1BvcHBlckNvbmZpZykgOiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIF9zZXRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgIGNvbnN0IHRyaWdnZXJzID0gdGhpcy5fY29uZmlnLnRyaWdnZXIuc3BsaXQoJyAnKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgdHJpZ2dlciBvZiB0cmlnZ2Vycykge1xyXG4gICAgICAgIGlmICh0cmlnZ2VyID09PSAnY2xpY2snKSB7XHJcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfQ0xJQ0skMSksIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQudG9nZ2xlKCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgIT09IFRSSUdHRVJfTUFOVUFMKSB7XHJcbiAgICAgICAgICBjb25zdCBldmVudEluID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX01PVVNFRU5URVIpIDogdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfRk9DVVNJTiQxKTtcclxuICAgICAgICAgIGNvbnN0IGV2ZW50T3V0ID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX01PVVNFTEVBVkUpIDogdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfRk9DVVNPVVQkMSk7XHJcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgZXZlbnRJbiwgdGhpcy5fY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNpbicgPyBUUklHR0VSX0ZPQ1VTIDogVFJJR0dFUl9IT1ZFUl0gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgY29udGV4dC5fZW50ZXIoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50T3V0LCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCk7XHJcblxyXG4gICAgICAgICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW2V2ZW50LnR5cGUgPT09ICdmb2N1c291dCcgPyBUUklHR0VSX0ZPQ1VTIDogVFJJR0dFUl9IT1ZFUl0gPSBjb250ZXh0Ll9lbGVtZW50LmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xyXG5cclxuICAgICAgICAgICAgY29udGV4dC5fbGVhdmUoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xyXG4gICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9NT0RBTCksIEVWRU5UX01PREFMX0hJREUsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIF9maXhUaXRsZSgpIHtcclxuICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKTtcclxuXHJcbiAgICAgIGlmICghdGl0bGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSAmJiAhdGhpcy5fZWxlbWVudC50ZXh0Q29udGVudC50cmltKCkpIHtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRpdGxlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnLCB0aXRsZSk7IC8vIERPIE5PVCBVU0UgSVQuIElzIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblxyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RpdGxlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgX2VudGVyKCkge1xyXG4gICAgICBpZiAodGhpcy5faXNTaG93bigpIHx8IHRoaXMuX2lzSG92ZXJlZCkge1xyXG4gICAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSB0cnVlO1xyXG5cclxuICAgICAgdGhpcy5fc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzSG92ZXJlZCkge1xyXG4gICAgICAgICAgdGhpcy5zaG93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkuc2hvdyk7XHJcbiAgICB9XHJcblxyXG4gICAgX2xlYXZlKCkge1xyXG4gICAgICBpZiAodGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgIHRoaXMuX3NldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGlmICghdGhpcy5faXNIb3ZlcmVkKSB7XHJcbiAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheS5oaWRlKTtcclxuICAgIH1cclxuXHJcbiAgICBfc2V0VGltZW91dChoYW5kbGVyLCB0aW1lb3V0KSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcclxuICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoaGFuZGxlciwgdGltZW91dCk7XHJcbiAgICB9XHJcblxyXG4gICAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XHJcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2FjdGl2ZVRyaWdnZXIpLmluY2x1ZGVzKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIF9nZXRDb25maWcoY29uZmlnKSB7XHJcbiAgICAgIGNvbnN0IGRhdGFBdHRyaWJ1dGVzID0gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGRhdGFBdHRyaWJ1dGUgb2YgT2JqZWN0LmtleXMoZGF0YUF0dHJpYnV0ZXMpKSB7XHJcbiAgICAgICAgaWYgKERJU0FMTE9XRURfQVRUUklCVVRFUy5oYXMoZGF0YUF0dHJpYnV0ZSkpIHtcclxuICAgICAgICAgIGRlbGV0ZSBkYXRhQXR0cmlidXRlc1tkYXRhQXR0cmlidXRlXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbmZpZyA9IHsgLi4uZGF0YUF0dHJpYnV0ZXMsXHJcbiAgICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KVxyXG4gICAgICB9O1xyXG4gICAgICBjb25maWcgPSB0aGlzLl9tZXJnZUNvbmZpZ09iaihjb25maWcpO1xyXG4gICAgICBjb25maWcgPSB0aGlzLl9jb25maWdBZnRlck1lcmdlKGNvbmZpZyk7XHJcblxyXG4gICAgICB0aGlzLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKTtcclxuXHJcbiAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9XHJcblxyXG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XHJcbiAgICAgIGNvbmZpZy5jb250YWluZXIgPSBjb25maWcuY29udGFpbmVyID09PSBmYWxzZSA/IGRvY3VtZW50LmJvZHkgOiBnZXRFbGVtZW50KGNvbmZpZy5jb250YWluZXIpO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgY29uZmlnLmRlbGF5ID0ge1xyXG4gICAgICAgICAgc2hvdzogY29uZmlnLmRlbGF5LFxyXG4gICAgICAgICAgaGlkZTogY29uZmlnLmRlbGF5XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiBjb25maWcudGl0bGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgY29uZmlnLnRpdGxlID0gY29uZmlnLnRpdGxlLnRvU3RyaW5nKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLmNvbnRlbnQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgY29uZmlnLmNvbnRlbnQgPSBjb25maWcuY29udGVudC50b1N0cmluZygpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gY29uZmlnO1xyXG4gICAgfVxyXG5cclxuICAgIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcclxuICAgICAgY29uc3QgY29uZmlnID0ge307XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLl9jb25maWcpIHtcclxuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2tleV0gIT09IHRoaXMuX2NvbmZpZ1trZXldKSB7XHJcbiAgICAgICAgICBjb25maWdba2V5XSA9IHRoaXMuX2NvbmZpZ1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgY29uZmlnLnNlbGVjdG9yID0gZmFsc2U7XHJcbiAgICAgIGNvbmZpZy50cmlnZ2VyID0gJ21hbnVhbCc7IC8vIEluIHRoZSBmdXR1cmUgY2FuIGJlIHJlcGxhY2VkIHdpdGg6XHJcbiAgICAgIC8vIGNvbnN0IGtleXNXaXRoRGlmZmVyZW50VmFsdWVzID0gT2JqZWN0LmVudHJpZXModGhpcy5fY29uZmlnKS5maWx0ZXIoZW50cnkgPT4gdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VudHJ5WzBdXSAhPT0gdGhpcy5fY29uZmlnW2VudHJ5WzBdXSlcclxuICAgICAgLy8gYE9iamVjdC5mcm9tRW50cmllcyhrZXlzV2l0aERpZmZlcmVudFZhbHVlcylgXHJcblxyXG4gICAgICByZXR1cm4gY29uZmlnO1xyXG4gICAgfVxyXG5cclxuICAgIF9kaXNwb3NlUG9wcGVyKCkge1xyXG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XHJcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcclxuXHJcbiAgICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMudGlwKSB7XHJcbiAgICAgICAgdGhpcy50aXAucmVtb3ZlKCk7XHJcbiAgICAgICAgdGhpcy50aXAgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9IC8vIFN0YXRpY1xyXG5cclxuXHJcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gVG9vbHRpcC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGF0YVtjb25maWddKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICB9XHJcbiAgLyoqXHJcbiAgICogalF1ZXJ5XHJcbiAgICovXHJcblxyXG5cclxuICBkZWZpbmVKUXVlcnlQbHVnaW4oVG9vbHRpcCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwICh2NS4yLjMpOiBwb3BvdmVyLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgTkFNRSQzID0gJ3BvcG92ZXInO1xyXG4gIGNvbnN0IFNFTEVDVE9SX1RJVExFID0gJy5wb3BvdmVyLWhlYWRlcic7XHJcbiAgY29uc3QgU0VMRUNUT1JfQ09OVEVOVCA9ICcucG9wb3Zlci1ib2R5JztcclxuICBjb25zdCBEZWZhdWx0JDIgPSB7IC4uLlRvb2x0aXAuRGVmYXVsdCxcclxuICAgIGNvbnRlbnQ6ICcnLFxyXG4gICAgb2Zmc2V0OiBbMCwgOF0sXHJcbiAgICBwbGFjZW1lbnQ6ICdyaWdodCcsXHJcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj4nICsgJzxkaXYgY2xhc3M9XCJwb3BvdmVyLWFycm93XCI+PC9kaXY+JyArICc8aDMgY2xhc3M9XCJwb3BvdmVyLWhlYWRlclwiPjwvaDM+JyArICc8ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5XCI+PC9kaXY+JyArICc8L2Rpdj4nLFxyXG4gICAgdHJpZ2dlcjogJ2NsaWNrJ1xyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkMiA9IHsgLi4uVG9vbHRpcC5EZWZhdWx0VHlwZSxcclxuICAgIGNvbnRlbnQ6ICcobnVsbHxzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknXHJcbiAgfTtcclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIFBvcG92ZXIgZXh0ZW5kcyBUb29sdGlwIHtcclxuICAgIC8vIEdldHRlcnNcclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHQkMjtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkMjtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJDM7XHJcbiAgICB9IC8vIE92ZXJyaWRlc1xyXG5cclxuXHJcbiAgICBfaXNXaXRoQ29udGVudCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2dldFRpdGxlKCkgfHwgdGhpcy5fZ2V0Q29udGVudCgpO1xyXG4gICAgfSAvLyBQcml2YXRlXHJcblxyXG5cclxuICAgIF9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgW1NFTEVDVE9SX1RJVExFXTogdGhpcy5fZ2V0VGl0bGUoKSxcclxuICAgICAgICBbU0VMRUNUT1JfQ09OVEVOVF06IHRoaXMuX2dldENvbnRlbnQoKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIF9nZXRDb250ZW50KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmNvbnRlbnQpO1xyXG4gICAgfSAvLyBTdGF0aWNcclxuXHJcblxyXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IFBvcG92ZXIuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIGpRdWVyeVxyXG4gICAqL1xyXG5cclxuXHJcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKFBvcG92ZXIpO1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogc2Nyb2xsc3B5LmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgTkFNRSQyID0gJ3Njcm9sbHNweSc7XHJcbiAgY29uc3QgREFUQV9LRVkkMiA9ICdicy5zY3JvbGxzcHknO1xyXG4gIGNvbnN0IEVWRU5UX0tFWSQyID0gYC4ke0RBVEFfS0VZJDJ9YDtcclxuICBjb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcclxuICBjb25zdCBFVkVOVF9BQ1RJVkFURSA9IGBhY3RpdmF0ZSR7RVZFTlRfS0VZJDJ9YDtcclxuICBjb25zdCBFVkVOVF9DTElDSyA9IGBjbGljayR7RVZFTlRfS0VZJDJ9YDtcclxuICBjb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDEgPSBgbG9hZCR7RVZFTlRfS0VZJDJ9JHtEQVRBX0FQSV9LRVl9YDtcclxuICBjb25zdCBDTEFTU19OQU1FX0RST1BET1dOX0lURU0gPSAnZHJvcGRvd24taXRlbSc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUkMSA9ICdhY3RpdmUnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfU1BZID0gJ1tkYXRhLWJzLXNweT1cInNjcm9sbFwiXSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfVEFSR0VUX0xJTktTID0gJ1tocmVmXSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAgPSAnLm5hdiwgLmxpc3QtZ3JvdXAnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX05BVl9MSU5LUyA9ICcubmF2LWxpbmsnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX05BVl9JVEVNUyA9ICcubmF2LWl0ZW0nO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0xJU1RfSVRFTVMgPSAnLmxpc3QtZ3JvdXAtaXRlbSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfTElOS19JVEVNUyA9IGAke1NFTEVDVE9SX05BVl9MSU5LU30sICR7U0VMRUNUT1JfTkFWX0lURU1TfSA+ICR7U0VMRUNUT1JfTkFWX0xJTktTfSwgJHtTRUxFQ1RPUl9MSVNUX0lURU1TfWA7XHJcbiAgY29uc3QgU0VMRUNUT1JfRFJPUERPV04gPSAnLmRyb3Bkb3duJztcclxuICBjb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUkMSA9ICcuZHJvcGRvd24tdG9nZ2xlJztcclxuICBjb25zdCBEZWZhdWx0JDEgPSB7XHJcbiAgICBvZmZzZXQ6IG51bGwsXHJcbiAgICAvLyBUT0RPOiB2NiBAZGVwcmVjYXRlZCwga2VlcCBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29uc1xyXG4gICAgcm9vdE1hcmdpbjogJzBweCAwcHggLTI1JScsXHJcbiAgICBzbW9vdGhTY3JvbGw6IGZhbHNlLFxyXG4gICAgdGFyZ2V0OiBudWxsLFxyXG4gICAgdGhyZXNob2xkOiBbMC4xLCAwLjUsIDFdXHJcbiAgfTtcclxuICBjb25zdCBEZWZhdWx0VHlwZSQxID0ge1xyXG4gICAgb2Zmc2V0OiAnKG51bWJlcnxudWxsKScsXHJcbiAgICAvLyBUT0RPIHY2IEBkZXByZWNhdGVkLCBrZWVwIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zXHJcbiAgICByb290TWFyZ2luOiAnc3RyaW5nJyxcclxuICAgIHNtb290aFNjcm9sbDogJ2Jvb2xlYW4nLFxyXG4gICAgdGFyZ2V0OiAnZWxlbWVudCcsXHJcbiAgICB0aHJlc2hvbGQ6ICdhcnJheSdcclxuICB9O1xyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgU2Nyb2xsU3B5IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcclxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTsgLy8gdGhpcy5fZWxlbWVudCBpcyB0aGUgb2JzZXJ2YWJsZXNDb250YWluZXIgYW5kIGNvbmZpZy50YXJnZXQgdGhlIG1lbnUgbGlua3Mgd3JhcHBlclxyXG5cclxuICAgICAgdGhpcy5fdGFyZ2V0TGlua3MgPSBuZXcgTWFwKCk7XHJcbiAgICAgIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpLm92ZXJmbG93WSA9PT0gJ3Zpc2libGUnID8gbnVsbCA6IHRoaXMuX2VsZW1lbnQ7XHJcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcclxuICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhID0ge1xyXG4gICAgICAgIHZpc2libGVFbnRyeVRvcDogMCxcclxuICAgICAgICBwYXJlbnRTY3JvbGxUb3A6IDBcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5yZWZyZXNoKCk7IC8vIGluaXRpYWxpemVcclxuICAgIH0gLy8gR2V0dGVyc1xyXG5cclxuXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0JDE7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDE7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRSQyO1xyXG4gICAgfSAvLyBQdWJsaWNcclxuXHJcblxyXG4gICAgcmVmcmVzaCgpIHtcclxuICAgICAgdGhpcy5faW5pdGlhbGl6ZVRhcmdldHNBbmRPYnNlcnZhYmxlcygpO1xyXG5cclxuICAgICAgdGhpcy5fbWF5YmVFbmFibGVTbW9vdGhTY3JvbGwoKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9vYnNlcnZlcikge1xyXG4gICAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IHRoaXMuX2dldE5ld09ic2VydmVyKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoY29uc3Qgc2VjdGlvbiBvZiB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMudmFsdWVzKCkpIHtcclxuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHNlY3Rpb24pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG5cclxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gICAgfSAvLyBQcml2YXRlXHJcblxyXG5cclxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xyXG4gICAgICAvLyBUT0RPOiBvbiB2NiB0YXJnZXQgc2hvdWxkIGJlIGdpdmVuIGV4cGxpY2l0bHkgJiByZW1vdmUgdGhlIHt0YXJnZXQ6ICdzcy10YXJnZXQnfSBjYXNlXHJcbiAgICAgIGNvbmZpZy50YXJnZXQgPSBnZXRFbGVtZW50KGNvbmZpZy50YXJnZXQpIHx8IGRvY3VtZW50LmJvZHk7IC8vIFRPRE86IHY2IE9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnMuIFVzZSByb290TWFyZ2luIG9ubHlcclxuXHJcbiAgICAgIGNvbmZpZy5yb290TWFyZ2luID0gY29uZmlnLm9mZnNldCA/IGAke2NvbmZpZy5vZmZzZXR9cHggMHB4IC0zMCVgIDogY29uZmlnLnJvb3RNYXJnaW47XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy50aHJlc2hvbGQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY29uZmlnLnRocmVzaG9sZCA9IGNvbmZpZy50aHJlc2hvbGQuc3BsaXQoJywnKS5tYXAodmFsdWUgPT4gTnVtYmVyLnBhcnNlRmxvYXQodmFsdWUpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxuXHJcbiAgICBfbWF5YmVFbmFibGVTbW9vdGhTY3JvbGwoKSB7XHJcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnNtb290aFNjcm9sbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSAvLyB1bnJlZ2lzdGVyIGFueSBwcmV2aW91cyBsaXN0ZW5lcnNcclxuXHJcblxyXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2NvbmZpZy50YXJnZXQsIEVWRU5UX0NMSUNLKTtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2NvbmZpZy50YXJnZXQsIEVWRU5UX0NMSUNLLCBTRUxFQ1RPUl9UQVJHRVRfTElOS1MsIGV2ZW50ID0+IHtcclxuICAgICAgICBjb25zdCBvYnNlcnZhYmxlU2VjdGlvbiA9IHRoaXMuX29ic2VydmFibGVTZWN0aW9ucy5nZXQoZXZlbnQudGFyZ2V0Lmhhc2gpO1xyXG5cclxuICAgICAgICBpZiAob2JzZXJ2YWJsZVNlY3Rpb24pIHtcclxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICBjb25zdCByb290ID0gdGhpcy5fcm9vdEVsZW1lbnQgfHwgd2luZG93O1xyXG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gb2JzZXJ2YWJsZVNlY3Rpb24ub2Zmc2V0VG9wIC0gdGhpcy5fZWxlbWVudC5vZmZzZXRUb3A7XHJcblxyXG4gICAgICAgICAgaWYgKHJvb3Quc2Nyb2xsVG8pIHtcclxuICAgICAgICAgICAgcm9vdC5zY3JvbGxUbyh7XHJcbiAgICAgICAgICAgICAgdG9wOiBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9IC8vIENocm9tZSA2MCBkb2Vzbid0IHN1cHBvcnQgYHNjcm9sbFRvYFxyXG5cclxuXHJcbiAgICAgICAgICByb290LnNjcm9sbFRvcCA9IGhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIF9nZXROZXdPYnNlcnZlcigpIHtcclxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICByb290OiB0aGlzLl9yb290RWxlbWVudCxcclxuICAgICAgICB0aHJlc2hvbGQ6IHRoaXMuX2NvbmZpZy50aHJlc2hvbGQsXHJcbiAgICAgICAgcm9vdE1hcmdpbjogdGhpcy5fY29uZmlnLnJvb3RNYXJnaW5cclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHRoaXMuX29ic2VydmVyQ2FsbGJhY2soZW50cmllcyksIG9wdGlvbnMpO1xyXG4gICAgfSAvLyBUaGUgbG9naWMgb2Ygc2VsZWN0aW9uXHJcblxyXG5cclxuICAgIF9vYnNlcnZlckNhbGxiYWNrKGVudHJpZXMpIHtcclxuICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGVudHJ5ID0+IHRoaXMuX3RhcmdldExpbmtzLmdldChgIyR7ZW50cnkudGFyZ2V0LmlkfWApO1xyXG5cclxuICAgICAgY29uc3QgYWN0aXZhdGUgPSBlbnRyeSA9PiB7XHJcbiAgICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnZpc2libGVFbnRyeVRvcCA9IGVudHJ5LnRhcmdldC5vZmZzZXRUb3A7XHJcblxyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3ModGFyZ2V0RWxlbWVudChlbnRyeSkpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3QgcGFyZW50U2Nyb2xsVG9wID0gKHRoaXMuX3Jvb3RFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuc2Nyb2xsVG9wO1xyXG4gICAgICBjb25zdCB1c2VyU2Nyb2xsc0Rvd24gPSBwYXJlbnRTY3JvbGxUb3AgPj0gdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnBhcmVudFNjcm9sbFRvcDtcclxuICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnBhcmVudFNjcm9sbFRvcCA9IHBhcmVudFNjcm9sbFRvcDtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xyXG4gICAgICAgIGlmICghZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcclxuICAgICAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgdGhpcy5fY2xlYXJBY3RpdmVDbGFzcyh0YXJnZXRFbGVtZW50KGVudHJ5KSk7XHJcblxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMgPSBlbnRyeS50YXJnZXQub2Zmc2V0VG9wID49IHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS52aXNpYmxlRW50cnlUb3A7IC8vIGlmIHdlIGFyZSBzY3JvbGxpbmcgZG93biwgcGljayB0aGUgYmlnZ2VyIG9mZnNldFRvcFxyXG5cclxuICAgICAgICBpZiAodXNlclNjcm9sbHNEb3duICYmIGVudHJ5SXNMb3dlclRoYW5QcmV2aW91cykge1xyXG4gICAgICAgICAgYWN0aXZhdGUoZW50cnkpOyAvLyBpZiBwYXJlbnQgaXNuJ3Qgc2Nyb2xsZWQsIGxldCdzIGtlZXAgdGhlIGZpcnN0IHZpc2libGUgaXRlbSwgYnJlYWtpbmcgdGhlIGl0ZXJhdGlvblxyXG5cclxuICAgICAgICAgIGlmICghcGFyZW50U2Nyb2xsVG9wKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IC8vIGlmIHdlIGFyZSBzY3JvbGxpbmcgdXAsIHBpY2sgdGhlIHNtYWxsZXN0IG9mZnNldFRvcFxyXG5cclxuXHJcbiAgICAgICAgaWYgKCF1c2VyU2Nyb2xsc0Rvd24gJiYgIWVudHJ5SXNMb3dlclRoYW5QcmV2aW91cykge1xyXG4gICAgICAgICAgYWN0aXZhdGUoZW50cnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9pbml0aWFsaXplVGFyZ2V0c0FuZE9ic2VydmFibGVzKCkge1xyXG4gICAgICB0aGlzLl90YXJnZXRMaW5rcyA9IG5ldyBNYXAoKTtcclxuICAgICAgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgICBjb25zdCB0YXJnZXRMaW5rcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfVEFSR0VUX0xJTktTLCB0aGlzLl9jb25maWcudGFyZ2V0KTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgYW5jaG9yIG9mIHRhcmdldExpbmtzKSB7XHJcbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIGFuY2hvciBoYXMgYW4gaWQgYW5kIGlzIG5vdCBkaXNhYmxlZFxyXG4gICAgICAgIGlmICghYW5jaG9yLmhhc2ggfHwgaXNEaXNhYmxlZChhbmNob3IpKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IG9ic2VydmFibGVTZWN0aW9uID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShhbmNob3IuaGFzaCwgdGhpcy5fZWxlbWVudCk7IC8vIGVuc3VyZSB0aGF0IHRoZSBvYnNlcnZhYmxlU2VjdGlvbiBleGlzdHMgJiBpcyB2aXNpYmxlXHJcblxyXG4gICAgICAgIGlmIChpc1Zpc2libGUob2JzZXJ2YWJsZVNlY3Rpb24pKSB7XHJcbiAgICAgICAgICB0aGlzLl90YXJnZXRMaW5rcy5zZXQoYW5jaG9yLmhhc2gsIGFuY2hvcik7XHJcblxyXG4gICAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zLnNldChhbmNob3IuaGFzaCwgb2JzZXJ2YWJsZVNlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9wcm9jZXNzKHRhcmdldCkge1xyXG4gICAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ID09PSB0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2NsZWFyQWN0aXZlQ2xhc3ModGhpcy5fY29uZmlnLnRhcmdldCk7XHJcblxyXG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xyXG5cclxuICAgICAgdGhpcy5fYWN0aXZhdGVQYXJlbnRzKHRhcmdldCk7XHJcblxyXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9BQ1RJVkFURSwge1xyXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRhcmdldFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBfYWN0aXZhdGVQYXJlbnRzKHRhcmdldCkge1xyXG4gICAgICAvLyBBY3RpdmF0ZSBkcm9wZG93biBwYXJlbnRzXHJcbiAgICAgIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUERPV05fSVRFTSkpIHtcclxuICAgICAgICBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxLCB0YXJnZXQuY2xvc2VzdChTRUxFQ1RPUl9EUk9QRE9XTikpLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGxpc3RHcm91cCBvZiBTZWxlY3RvckVuZ2luZS5wYXJlbnRzKHRhcmdldCwgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVApKSB7XHJcbiAgICAgICAgLy8gU2V0IHRyaWdnZXJlZCBsaW5rcyBwYXJlbnRzIGFzIGFjdGl2ZVxyXG4gICAgICAgIC8vIFdpdGggYm90aCA8dWw+IGFuZCA8bmF2PiBtYXJrdXAgYSBwYXJlbnQgaXMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYW55IG5hdiBhbmNlc3RvclxyXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBTZWxlY3RvckVuZ2luZS5wcmV2KGxpc3RHcm91cCwgU0VMRUNUT1JfTElOS19JVEVNUykpIHtcclxuICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfY2xlYXJBY3RpdmVDbGFzcyhwYXJlbnQpIHtcclxuICAgICAgcGFyZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XHJcbiAgICAgIGNvbnN0IGFjdGl2ZU5vZGVzID0gU2VsZWN0b3JFbmdpbmUuZmluZChgJHtTRUxFQ1RPUl9UQVJHRVRfTElOS1N9LiR7Q0xBU1NfTkFNRV9BQ1RJVkUkMX1gLCBwYXJlbnQpO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBub2RlIG9mIGFjdGl2ZU5vZGVzKSB7XHJcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDEpO1xyXG4gICAgICB9XHJcbiAgICB9IC8vIFN0YXRpY1xyXG5cclxuXHJcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gU2Nyb2xsU3B5LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gIH1cclxuICAvKipcclxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxyXG4gICAqL1xyXG5cclxuXHJcbiAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQxLCAoKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IHNweSBvZiBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfU1BZKSkge1xyXG4gICAgICBTY3JvbGxTcHkuZ2V0T3JDcmVhdGVJbnN0YW5jZShzcHkpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIC8qKlxyXG4gICAqIGpRdWVyeVxyXG4gICAqL1xyXG5cclxuICBkZWZpbmVKUXVlcnlQbHVnaW4oU2Nyb2xsU3B5KTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IHRhYi5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUkMSA9ICd0YWInO1xyXG4gIGNvbnN0IERBVEFfS0VZJDEgPSAnYnMudGFiJztcclxuICBjb25zdCBFVkVOVF9LRVkkMSA9IGAuJHtEQVRBX0tFWSQxfWA7XHJcbiAgY29uc3QgRVZFTlRfSElERSQxID0gYGhpZGUke0VWRU5UX0tFWSQxfWA7XHJcbiAgY29uc3QgRVZFTlRfSElEREVOJDEgPSBgaGlkZGVuJHtFVkVOVF9LRVkkMX1gO1xyXG4gIGNvbnN0IEVWRU5UX1NIT1ckMSA9IGBzaG93JHtFVkVOVF9LRVkkMX1gO1xyXG4gIGNvbnN0IEVWRU5UX1NIT1dOJDEgPSBgc2hvd24ke0VWRU5UX0tFWSQxfWA7XHJcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkgPSBgY2xpY2ske0VWRU5UX0tFWSQxfWA7XHJcbiAgY29uc3QgRVZFTlRfS0VZRE9XTiA9IGBrZXlkb3duJHtFVkVOVF9LRVkkMX1gO1xyXG4gIGNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkgPSBgbG9hZCR7RVZFTlRfS0VZJDF9YDtcclxuICBjb25zdCBBUlJPV19MRUZUX0tFWSA9ICdBcnJvd0xlZnQnO1xyXG4gIGNvbnN0IEFSUk9XX1JJR0hUX0tFWSA9ICdBcnJvd1JpZ2h0JztcclxuICBjb25zdCBBUlJPV19VUF9LRVkgPSAnQXJyb3dVcCc7XHJcbiAgY29uc3QgQVJST1dfRE9XTl9LRVkgPSAnQXJyb3dEb3duJztcclxuICBjb25zdCBDTEFTU19OQU1FX0FDVElWRSA9ICdhY3RpdmUnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQxID0gJ2ZhZGUnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQxID0gJ3Nob3cnO1xyXG4gIGNvbnN0IENMQVNTX0RST1BET1dOID0gJ2Ryb3Bkb3duJztcclxuICBjb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUgPSAnLmRyb3Bkb3duLXRvZ2dsZSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfRFJPUERPV05fTUVOVSA9ICcuZHJvcGRvd24tbWVudSc7XHJcbiAgY29uc3QgTk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRSA9ICc6bm90KC5kcm9wZG93bi10b2dnbGUpJztcclxuICBjb25zdCBTRUxFQ1RPUl9UQUJfUEFORUwgPSAnLmxpc3QtZ3JvdXAsIC5uYXYsIFtyb2xlPVwidGFibGlzdFwiXSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfT1VURVIgPSAnLm5hdi1pdGVtLCAubGlzdC1ncm91cC1pdGVtJztcclxuICBjb25zdCBTRUxFQ1RPUl9JTk5FUiA9IGAubmF2LWxpbmske05PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9LCAubGlzdC1ncm91cC1pdGVtJHtOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFfSwgW3JvbGU9XCJ0YWJcIl0ke05PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9YDtcclxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS1icy10b2dnbGU9XCJ0YWJcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cInBpbGxcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cImxpc3RcIl0nOyAvLyB0b2RvOnY2OiBjb3VsZCBiZSBvbmx5IGB0YWJgXHJcblxyXG4gIGNvbnN0IFNFTEVDVE9SX0lOTkVSX0VMRU0gPSBgJHtTRUxFQ1RPUl9JTk5FUn0sICR7U0VMRUNUT1JfREFUQV9UT0dHTEV9YDtcclxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUgPSBgLiR7Q0xBU1NfTkFNRV9BQ1RJVkV9W2RhdGEtYnMtdG9nZ2xlPVwidGFiXCJdLCAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJwaWxsXCJdLCAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJsaXN0XCJdYDtcclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIFRhYiBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCkge1xyXG4gICAgICBzdXBlcihlbGVtZW50KTtcclxuICAgICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX1RBQl9QQU5FTCk7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuX3BhcmVudCkge1xyXG4gICAgICAgIHJldHVybjsgLy8gdG9kbzogc2hvdWxkIFRocm93IGV4Y2VwdGlvbiBvbiB2NlxyXG4gICAgICAgIC8vIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZWxlbWVudC5vdXRlckhUTUx9IGhhcyBub3QgYSB2YWxpZCBwYXJlbnQgJHtTRUxFQ1RPUl9JTk5FUl9FTEVNfWApXHJcbiAgICAgIH0gLy8gU2V0IHVwIGluaXRpYWwgYXJpYSBhdHRyaWJ1dGVzXHJcblxyXG5cclxuICAgICAgdGhpcy5fc2V0SW5pdGlhbEF0dHJpYnV0ZXModGhpcy5fcGFyZW50LCB0aGlzLl9nZXRDaGlsZHJlbigpKTtcclxuXHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOLCBldmVudCA9PiB0aGlzLl9rZXlkb3duKGV2ZW50KSk7XHJcbiAgICB9IC8vIEdldHRlcnNcclxuXHJcblxyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRSQxO1xyXG4gICAgfSAvLyBQdWJsaWNcclxuXHJcblxyXG4gICAgc2hvdygpIHtcclxuICAgICAgLy8gU2hvd3MgdGhpcyBlbGVtIGFuZCBkZWFjdGl2YXRlIHRoZSBhY3RpdmUgc2libGluZyBpZiBleGlzdHNcclxuICAgICAgY29uc3QgaW5uZXJFbGVtID0gdGhpcy5fZWxlbWVudDtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9lbGVtSXNBY3RpdmUoaW5uZXJFbGVtKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSAvLyBTZWFyY2ggZm9yIGFjdGl2ZSB0YWIgb24gc2FtZSBwYXJlbnQgdG8gZGVhY3RpdmF0ZSBpdFxyXG5cclxuXHJcbiAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW0oKTtcclxuXHJcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IGFjdGl2ZSA/IEV2ZW50SGFuZGxlci50cmlnZ2VyKGFjdGl2ZSwgRVZFTlRfSElERSQxLCB7XHJcbiAgICAgICAgcmVsYXRlZFRhcmdldDogaW5uZXJFbGVtXHJcbiAgICAgIH0pIDogbnVsbDtcclxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIoaW5uZXJFbGVtLCBFVkVOVF9TSE9XJDEsIHtcclxuICAgICAgICByZWxhdGVkVGFyZ2V0OiBhY3RpdmVcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgaGlkZUV2ZW50ICYmIGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9kZWFjdGl2YXRlKGFjdGl2ZSwgaW5uZXJFbGVtKTtcclxuXHJcbiAgICAgIHRoaXMuX2FjdGl2YXRlKGlubmVyRWxlbSwgYWN0aXZlKTtcclxuICAgIH0gLy8gUHJpdmF0ZVxyXG5cclxuXHJcbiAgICBfYWN0aXZhdGUoZWxlbWVudCwgcmVsYXRlZEVsZW0pIHtcclxuICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xyXG5cclxuICAgICAgdGhpcy5fYWN0aXZhdGUoZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSk7IC8vIFNlYXJjaCBhbmQgYWN0aXZhdGUvc2hvdyB0aGUgcHJvcGVyIHNlY3Rpb25cclxuXHJcblxyXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcclxuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckMSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHRydWUpO1xyXG5cclxuICAgICAgICB0aGlzLl90b2dnbGVEcm9wRG93bihlbGVtZW50LCB0cnVlKTtcclxuXHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIoZWxlbWVudCwgRVZFTlRfU0hPV04kMSwge1xyXG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZEVsZW1cclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIGVsZW1lbnQsIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQxKSk7XHJcbiAgICB9XHJcblxyXG4gICAgX2RlYWN0aXZhdGUoZWxlbWVudCwgcmVsYXRlZEVsZW0pIHtcclxuICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xyXG4gICAgICBlbGVtZW50LmJsdXIoKTtcclxuXHJcbiAgICAgIHRoaXMuX2RlYWN0aXZhdGUoZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSk7IC8vIFNlYXJjaCBhbmQgZGVhY3RpdmF0ZSB0aGUgc2hvd24gc2VjdGlvbiB0b29cclxuXHJcblxyXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcclxuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckMSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcclxuXHJcbiAgICAgICAgdGhpcy5fdG9nZ2xlRHJvcERvd24oZWxlbWVudCwgZmFsc2UpO1xyXG5cclxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcihlbGVtZW50LCBFVkVOVF9ISURERU4kMSwge1xyXG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZEVsZW1cclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIGVsZW1lbnQsIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQxKSk7XHJcbiAgICB9XHJcblxyXG4gICAgX2tleWRvd24oZXZlbnQpIHtcclxuICAgICAgaWYgKCFbQVJST1dfTEVGVF9LRVksIEFSUk9XX1JJR0hUX0tFWSwgQVJST1dfVVBfS0VZLCBBUlJPV19ET1dOX0tFWV0uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIHN0b3BQcm9wYWdhdGlvbi9wcmV2ZW50RGVmYXVsdCBib3RoIGFkZGVkIHRvIHN1cHBvcnQgdXAvZG93biBrZXlzIHdpdGhvdXQgc2Nyb2xsaW5nIHRoZSBwYWdlXHJcblxyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBjb25zdCBpc05leHQgPSBbQVJST1dfUklHSFRfS0VZLCBBUlJPV19ET1dOX0tFWV0uaW5jbHVkZXMoZXZlbnQua2V5KTtcclxuICAgICAgY29uc3QgbmV4dEFjdGl2ZUVsZW1lbnQgPSBnZXROZXh0QWN0aXZlRWxlbWVudCh0aGlzLl9nZXRDaGlsZHJlbigpLmZpbHRlcihlbGVtZW50ID0+ICFpc0Rpc2FibGVkKGVsZW1lbnQpKSwgZXZlbnQudGFyZ2V0LCBpc05leHQsIHRydWUpO1xyXG5cclxuICAgICAgaWYgKG5leHRBY3RpdmVFbGVtZW50KSB7XHJcbiAgICAgICAgbmV4dEFjdGl2ZUVsZW1lbnQuZm9jdXMoe1xyXG4gICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKG5leHRBY3RpdmVFbGVtZW50KS5zaG93KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfZ2V0Q2hpbGRyZW4oKSB7XHJcbiAgICAgIC8vIGNvbGxlY3Rpb24gb2YgaW5uZXIgZWxlbWVudHNcclxuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSU5ORVJfRUxFTSwgdGhpcy5fcGFyZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBfZ2V0QWN0aXZlRWxlbSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2dldENoaWxkcmVuKCkuZmluZChjaGlsZCA9PiB0aGlzLl9lbGVtSXNBY3RpdmUoY2hpbGQpKSB8fCBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIF9zZXRJbml0aWFsQXR0cmlidXRlcyhwYXJlbnQsIGNoaWxkcmVuKSB7XHJcbiAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKHBhcmVudCwgJ3JvbGUnLCAndGFibGlzdCcpO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xyXG4gICAgICAgIHRoaXMuX3NldEluaXRpYWxBdHRyaWJ1dGVzT25DaGlsZChjaGlsZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPbkNoaWxkKGNoaWxkKSB7XHJcbiAgICAgIGNoaWxkID0gdGhpcy5fZ2V0SW5uZXJFbGVtZW50KGNoaWxkKTtcclxuXHJcbiAgICAgIGNvbnN0IGlzQWN0aXZlID0gdGhpcy5fZWxlbUlzQWN0aXZlKGNoaWxkKTtcclxuXHJcbiAgICAgIGNvbnN0IG91dGVyRWxlbSA9IHRoaXMuX2dldE91dGVyRWxlbWVudChjaGlsZCk7XHJcblxyXG4gICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBpc0FjdGl2ZSk7XHJcblxyXG4gICAgICBpZiAob3V0ZXJFbGVtICE9PSBjaGlsZCkge1xyXG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKG91dGVyRWxlbSwgJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghaXNBY3RpdmUpIHtcclxuICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKGNoaWxkLCAncm9sZScsICd0YWInKTsgLy8gc2V0IGF0dHJpYnV0ZXMgdG8gdGhlIHJlbGF0ZWQgcGFuZWwgdG9vXHJcblxyXG5cclxuICAgICAgdGhpcy5fc2V0SW5pdGlhbEF0dHJpYnV0ZXNPblRhcmdldFBhbmVsKGNoaWxkKTtcclxuICAgIH1cclxuXHJcbiAgICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPblRhcmdldFBhbmVsKGNoaWxkKSB7XHJcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IoY2hpbGQpO1xyXG5cclxuICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKHRhcmdldCwgJ3JvbGUnLCAndGFicGFuZWwnKTtcclxuXHJcbiAgICAgIGlmIChjaGlsZC5pZCkge1xyXG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKHRhcmdldCwgJ2FyaWEtbGFiZWxsZWRieScsIGAjJHtjaGlsZC5pZH1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF90b2dnbGVEcm9wRG93bihlbGVtZW50LCBvcGVuKSB7XHJcbiAgICAgIGNvbnN0IG91dGVyRWxlbSA9IHRoaXMuX2dldE91dGVyRWxlbWVudChlbGVtZW50KTtcclxuXHJcbiAgICAgIGlmICghb3V0ZXJFbGVtLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19EUk9QRE9XTikpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHRvZ2dsZSA9IChzZWxlY3RvciwgY2xhc3NOYW1lKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoc2VsZWN0b3IsIG91dGVyRWxlbSk7XHJcblxyXG4gICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lLCBvcGVuKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0b2dnbGUoU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFLCBDTEFTU19OQU1FX0FDVElWRSk7XHJcbiAgICAgIHRvZ2dsZShTRUxFQ1RPUl9EUk9QRE9XTl9NRU5VLCBDTEFTU19OQU1FX1NIT1ckMSk7XHJcbiAgICAgIG91dGVyRWxlbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBvcGVuKTtcclxuICAgIH1cclxuXHJcbiAgICBfc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xyXG4gICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF9lbGVtSXNBY3RpdmUoZWxlbSkge1xyXG4gICAgICByZXR1cm4gZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xyXG4gICAgfSAvLyBUcnkgdG8gZ2V0IHRoZSBpbm5lciBlbGVtZW50ICh1c3VhbGx5IHRoZSAubmF2LWxpbmspXHJcblxyXG5cclxuICAgIF9nZXRJbm5lckVsZW1lbnQoZWxlbSkge1xyXG4gICAgICByZXR1cm4gZWxlbS5tYXRjaGVzKFNFTEVDVE9SX0lOTkVSX0VMRU0pID8gZWxlbSA6IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfSU5ORVJfRUxFTSwgZWxlbSk7XHJcbiAgICB9IC8vIFRyeSB0byBnZXQgdGhlIG91dGVyIGVsZW1lbnQgKHVzdWFsbHkgdGhlIC5uYXYtaXRlbSlcclxuXHJcblxyXG4gICAgX2dldE91dGVyRWxlbWVudChlbGVtKSB7XHJcbiAgICAgIHJldHVybiBlbGVtLmNsb3Nlc3QoU0VMRUNUT1JfT1VURVIpIHx8IGVsZW07XHJcbiAgICB9IC8vIFN0YXRpY1xyXG5cclxuXHJcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGF0YVtjb25maWddKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICB9XHJcbiAgLyoqXHJcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cclxuICAgKi9cclxuXHJcblxyXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykuc2hvdygpO1xyXG4gIH0pO1xyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgb24gZm9jdXNcclxuICAgKi9cclxuXHJcbiAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSwgKCkgPT4ge1xyXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEVfQUNUSVZFKSkge1xyXG4gICAgICBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50KTtcclxuICAgIH1cclxuICB9KTtcclxuICAvKipcclxuICAgKiBqUXVlcnlcclxuICAgKi9cclxuXHJcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKFRhYik7XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwICh2NS4yLjMpOiB0b2FzdC5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUgPSAndG9hc3QnO1xyXG4gIGNvbnN0IERBVEFfS0VZID0gJ2JzLnRvYXN0JztcclxuICBjb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YDtcclxuICBjb25zdCBFVkVOVF9NT1VTRU9WRVIgPSBgbW91c2VvdmVyJHtFVkVOVF9LRVl9YDtcclxuICBjb25zdCBFVkVOVF9NT1VTRU9VVCA9IGBtb3VzZW91dCR7RVZFTlRfS0VZfWA7XHJcbiAgY29uc3QgRVZFTlRfRk9DVVNJTiA9IGBmb2N1c2luJHtFVkVOVF9LRVl9YDtcclxuICBjb25zdCBFVkVOVF9GT0NVU09VVCA9IGBmb2N1c291dCR7RVZFTlRfS0VZfWA7XHJcbiAgY29uc3QgRVZFTlRfSElERSA9IGBoaWRlJHtFVkVOVF9LRVl9YDtcclxuICBjb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YDtcclxuICBjb25zdCBFVkVOVF9TSE9XID0gYHNob3cke0VWRU5UX0tFWX1gO1xyXG4gIGNvbnN0IEVWRU5UX1NIT1dOID0gYHNob3duJHtFVkVOVF9LRVl9YDtcclxuICBjb25zdCBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9ISURFID0gJ2hpZGUnOyAvLyBAZGVwcmVjYXRlZCAtIGtlcHQgaGVyZSBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cclxuICBjb25zdCBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdyc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XSU5HID0gJ3Nob3dpbmcnO1xyXG4gIGNvbnN0IERlZmF1bHRUeXBlID0ge1xyXG4gICAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXHJcbiAgICBhdXRvaGlkZTogJ2Jvb2xlYW4nLFxyXG4gICAgZGVsYXk6ICdudW1iZXInXHJcbiAgfTtcclxuICBjb25zdCBEZWZhdWx0ID0ge1xyXG4gICAgYW5pbWF0aW9uOiB0cnVlLFxyXG4gICAgYXV0b2hpZGU6IHRydWUsXHJcbiAgICBkZWxheTogNTAwMFxyXG4gIH07XHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBUb2FzdCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XHJcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XHJcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xyXG4gICAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBmYWxzZTtcclxuXHJcbiAgICAgIHRoaXMuX3NldExpc3RlbmVycygpO1xyXG4gICAgfSAvLyBHZXR0ZXJzXHJcblxyXG5cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgICAgcmV0dXJuIE5BTUU7XHJcbiAgICB9IC8vIFB1YmxpY1xyXG5cclxuXHJcbiAgICBzaG93KCkge1xyXG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XKTtcclxuXHJcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XSU5HKTtcclxuXHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04pO1xyXG5cclxuICAgICAgICB0aGlzLl9tYXliZVNjaGVkdWxlSGlkZSgpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfSElERSk7IC8vIEBkZXByZWNhdGVkXHJcblxyXG5cclxuICAgICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVywgQ0xBU1NfTkFNRV9TSE9XSU5HKTtcclxuXHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgIGlmICghdGhpcy5pc1Nob3duKCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUpO1xyXG5cclxuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9ISURFKTsgLy8gQGRlcHJlY2F0ZWRcclxuXHJcblxyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkcsIENMQVNTX05BTUVfU0hPVyk7XHJcblxyXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTik7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XSU5HKTtcclxuXHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuaXNTaG93bigpKSB7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBpc1Nob3duKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKTtcclxuICAgIH0gLy8gUHJpdmF0ZVxyXG5cclxuXHJcbiAgICBfbWF5YmVTY2hlZHVsZUhpZGUoKSB7XHJcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLmF1dG9oaWRlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiB8fCB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheSk7XHJcbiAgICB9XHJcblxyXG4gICAgX29uSW50ZXJhY3Rpb24oZXZlbnQsIGlzSW50ZXJhY3RpbmcpIHtcclxuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAnbW91c2VvdmVyJzpcclxuICAgICAgICBjYXNlICdtb3VzZW91dCc6XHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBpc0ludGVyYWN0aW5nO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgY2FzZSAnZm9jdXNpbic6XHJcbiAgICAgICAgY2FzZSAnZm9jdXNvdXQnOlxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uID0gaXNJbnRlcmFjdGluZztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc0ludGVyYWN0aW5nKSB7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbmV4dEVsZW1lbnQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQgPT09IG5leHRFbGVtZW50IHx8IHRoaXMuX2VsZW1lbnQuY29udGFpbnMobmV4dEVsZW1lbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9tYXliZVNjaGVkdWxlSGlkZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIF9zZXRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRU9WRVIsIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIHRydWUpKTtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFT1VULCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCBmYWxzZSkpO1xyXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfRk9DVVNJTiwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgdHJ1ZSkpO1xyXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfRk9DVVNPVVQsIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIGZhbHNlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgX2NsZWFyVGltZW91dCgpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xyXG4gICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcclxuICAgIH0gLy8gU3RhdGljXHJcblxyXG5cclxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBUb2FzdC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gIH1cclxuICAvKipcclxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxyXG4gICAqL1xyXG5cclxuXHJcbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoVG9hc3QpO1xyXG4gIC8qKlxyXG4gICAqIGpRdWVyeVxyXG4gICAqL1xyXG5cclxuICBkZWZpbmVKUXVlcnlQbHVnaW4oVG9hc3QpO1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogaW5kZXgudW1kLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuICBjb25zdCBpbmRleF91bWQgPSB7XHJcbiAgICBBbGVydCxcclxuICAgIEJ1dHRvbixcclxuICAgIENhcm91c2VsLFxyXG4gICAgQ29sbGFwc2UsXHJcbiAgICBEcm9wZG93bixcclxuICAgIE1vZGFsLFxyXG4gICAgT2ZmY2FudmFzLFxyXG4gICAgUG9wb3ZlcixcclxuICAgIFNjcm9sbFNweSxcclxuICAgIFRhYixcclxuICAgIFRvYXN0LFxyXG4gICAgVG9vbHRpcFxyXG4gIH07XHJcblxyXG4gIHJldHVybiBpbmRleF91bWQ7XHJcblxyXG59KSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb3RzdHJhcC5idW5kbGUuanMubWFwXHJcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImdsb2JhbFRoaXMiLCJzZWxmIiwiYm9vdHN0cmFwIiwiTUFYX1VJRCIsIk1JTExJU0VDT05EU19NVUxUSVBMSUVSIiwiVFJBTlNJVElPTl9FTkQiLCJ0b1R5cGUiLCJvYmplY3QiLCJ1bmRlZmluZWQiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJtYXRjaCIsInRvTG93ZXJDYXNlIiwiZ2V0VUlEIiwicHJlZml4IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImdldFNlbGVjdG9yIiwiZWxlbWVudCIsInNlbGVjdG9yIiwiZ2V0QXR0cmlidXRlIiwiaHJlZkF0dHJpYnV0ZSIsImluY2x1ZGVzIiwic3RhcnRzV2l0aCIsInNwbGl0IiwidHJpbSIsImdldFNlbGVjdG9yRnJvbUVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiZ2V0RWxlbWVudEZyb21TZWxlY3RvciIsImdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50Iiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25EZWxheSIsImZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uIiwiTnVtYmVyIiwicGFyc2VGbG9hdCIsImZsb2F0VHJhbnNpdGlvbkRlbGF5IiwidHJpZ2dlclRyYW5zaXRpb25FbmQiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJpc0VsZW1lbnQkMSIsImpxdWVyeSIsIm5vZGVUeXBlIiwiZ2V0RWxlbWVudCIsImxlbmd0aCIsImlzVmlzaWJsZSIsImdldENsaWVudFJlY3RzIiwiZWxlbWVudElzVmlzaWJsZSIsImdldFByb3BlcnR5VmFsdWUiLCJjbG9zZWREZXRhaWxzIiwiY2xvc2VzdCIsInN1bW1hcnkiLCJwYXJlbnROb2RlIiwiaXNEaXNhYmxlZCIsIk5vZGUiLCJFTEVNRU5UX05PREUiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImRpc2FibGVkIiwiaGFzQXR0cmlidXRlIiwiZmluZFNoYWRvd1Jvb3QiLCJkb2N1bWVudEVsZW1lbnQiLCJhdHRhY2hTaGFkb3ciLCJnZXRSb290Tm9kZSIsInJvb3QiLCJTaGFkb3dSb290Iiwibm9vcCIsInJlZmxvdyIsIm9mZnNldEhlaWdodCIsImdldGpRdWVyeSIsImpRdWVyeSIsImJvZHkiLCJET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzIiwib25ET01Db250ZW50TG9hZGVkIiwiY2FsbGJhY2siLCJyZWFkeVN0YXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInB1c2giLCJpc1JUTCIsImRpciIsImRlZmluZUpRdWVyeVBsdWdpbiIsInBsdWdpbiIsIiQiLCJuYW1lIiwiTkFNRSIsIkpRVUVSWV9OT19DT05GTElDVCIsImZuIiwialF1ZXJ5SW50ZXJmYWNlIiwiQ29uc3RydWN0b3IiLCJub0NvbmZsaWN0IiwiZXhlY3V0ZSIsImV4ZWN1dGVBZnRlclRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uRWxlbWVudCIsIndhaXRGb3JUcmFuc2l0aW9uIiwiZHVyYXRpb25QYWRkaW5nIiwiZW11bGF0ZWREdXJhdGlvbiIsImNhbGxlZCIsImhhbmRsZXIiLCJ0YXJnZXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2V0VGltZW91dCIsImdldE5leHRBY3RpdmVFbGVtZW50IiwibGlzdCIsImFjdGl2ZUVsZW1lbnQiLCJzaG91bGRHZXROZXh0IiwiaXNDeWNsZUFsbG93ZWQiLCJsaXN0TGVuZ3RoIiwiaW5kZXgiLCJpbmRleE9mIiwibWF4IiwibWluIiwibmFtZXNwYWNlUmVnZXgiLCJzdHJpcE5hbWVSZWdleCIsInN0cmlwVWlkUmVnZXgiLCJldmVudFJlZ2lzdHJ5IiwidWlkRXZlbnQiLCJjdXN0b21FdmVudHMiLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsIm5hdGl2ZUV2ZW50cyIsIlNldCIsIm1ha2VFdmVudFVpZCIsInVpZCIsImdldEVsZW1lbnRFdmVudHMiLCJib290c3RyYXBIYW5kbGVyIiwiZXZlbnQiLCJoeWRyYXRlT2JqIiwiZGVsZWdhdGVUYXJnZXQiLCJvbmVPZmYiLCJFdmVudEhhbmRsZXIiLCJvZmYiLCJ0eXBlIiwiYXBwbHkiLCJib290c3RyYXBEZWxlZ2F0aW9uSGFuZGxlciIsImRvbUVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImRvbUVsZW1lbnQiLCJmaW5kSGFuZGxlciIsImV2ZW50cyIsImNhbGxhYmxlIiwiZGVsZWdhdGlvblNlbGVjdG9yIiwidmFsdWVzIiwiZmluZCIsIm5vcm1hbGl6ZVBhcmFtZXRlcnMiLCJvcmlnaW5hbFR5cGVFdmVudCIsImRlbGVnYXRpb25GdW5jdGlvbiIsImlzRGVsZWdhdGVkIiwidHlwZUV2ZW50IiwiZ2V0VHlwZUV2ZW50IiwiaGFzIiwiYWRkSGFuZGxlciIsIndyYXBGdW5jdGlvbiIsInJlbGF0ZWRUYXJnZXQiLCJoYW5kbGVycyIsInByZXZpb3VzRnVuY3Rpb24iLCJyZXBsYWNlIiwicmVtb3ZlSGFuZGxlciIsIkJvb2xlYW4iLCJyZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMiLCJuYW1lc3BhY2UiLCJzdG9yZUVsZW1lbnRFdmVudCIsImtleXMiLCJoYW5kbGVyS2V5Iiwib24iLCJvbmUiLCJpbk5hbWVzcGFjZSIsImlzTmFtZXNwYWNlIiwiZWxlbWVudEV2ZW50Iiwic2xpY2UiLCJrZXlIYW5kbGVycyIsInRyaWdnZXIiLCJhcmdzIiwialF1ZXJ5RXZlbnQiLCJidWJibGVzIiwibmF0aXZlRGlzcGF0Y2giLCJkZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCIsImlzRGVmYXVsdFByZXZlbnRlZCIsImV2dCIsImNhbmNlbGFibGUiLCJwcmV2ZW50RGVmYXVsdCIsIm9iaiIsIm1ldGEiLCJrZXkiLCJ2YWx1ZSIsIl91bnVzZWQiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImdldCIsImVudHJpZXMiLCJlbGVtZW50TWFwIiwiTWFwIiwiRGF0YSIsInNldCIsImluc3RhbmNlIiwiaW5zdGFuY2VNYXAiLCJzaXplIiwiY29uc29sZSIsImVycm9yIiwiQXJyYXkiLCJmcm9tIiwicmVtb3ZlIiwibm9ybWFsaXplRGF0YSIsIkpTT04iLCJwYXJzZSIsImRlY29kZVVSSUNvbXBvbmVudCIsIm5vcm1hbGl6ZURhdGFLZXkiLCJjaHIiLCJNYW5pcHVsYXRvciIsInNldERhdGFBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVEYXRhQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiZ2V0RGF0YUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwiYnNLZXlzIiwiZGF0YXNldCIsImZpbHRlciIsInB1cmVLZXkiLCJjaGFyQXQiLCJnZXREYXRhQXR0cmlidXRlIiwiQ29uZmlnIiwiY29uZmlnIiwiX21lcmdlQ29uZmlnT2JqIiwiX2NvbmZpZ0FmdGVyTWVyZ2UiLCJfdHlwZUNoZWNrQ29uZmlnIiwianNvbkNvbmZpZyIsImNvbnN0cnVjdG9yIiwiRGVmYXVsdCIsImNvbmZpZ1R5cGVzIiwiRGVmYXVsdFR5cGUiLCJwcm9wZXJ0eSIsImV4cGVjdGVkVHlwZXMiLCJ2YWx1ZVR5cGUiLCJSZWdFeHAiLCJ0ZXN0IiwiVHlwZUVycm9yIiwidG9VcHBlckNhc2UiLCJFcnJvciIsIlZFUlNJT04iLCJCYXNlQ29tcG9uZW50IiwiX2VsZW1lbnQiLCJfY29uZmlnIiwiX2dldENvbmZpZyIsIkRBVEFfS0VZIiwiRVZFTlRfS0VZIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInByb3BlcnR5TmFtZSIsImlzQW5pbWF0ZWQiLCJnZXRJbnN0YW5jZSIsImVuYWJsZURpc21pc3NUcmlnZ2VyIiwiY29tcG9uZW50IiwibWV0aG9kIiwiY2xpY2tFdmVudCIsInRhZ05hbWUiLCJnZXRPckNyZWF0ZUluc3RhbmNlIiwiTkFNRSRmIiwiREFUQV9LRVkkYSIsIkVWRU5UX0tFWSRiIiwiRVZFTlRfQ0xPU0UiLCJFVkVOVF9DTE9TRUQiLCJDTEFTU19OQU1FX0ZBREUkNSIsIkNMQVNTX05BTUVfU0hPVyQ4IiwiQWxlcnQiLCJjbG9zZUV2ZW50IiwiX3F1ZXVlQ2FsbGJhY2siLCJfZGVzdHJveUVsZW1lbnQiLCJkaXNwb3NlIiwiZWFjaCIsImRhdGEiLCJOQU1FJGUiLCJEQVRBX0tFWSQ5IiwiRVZFTlRfS0VZJGEiLCJEQVRBX0FQSV9LRVkkNiIsIkNMQVNTX05BTUVfQUNUSVZFJDMiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1IiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNiIsIkJ1dHRvbiIsInRvZ2dsZSIsImJ1dHRvbiIsIlNlbGVjdG9yRW5naW5lIiwiY29uY2F0IiwiRWxlbWVudCIsImZpbmRPbmUiLCJjaGlsZHJlbiIsImNoaWxkIiwibWF0Y2hlcyIsInBhcmVudHMiLCJhbmNlc3RvciIsInByZXYiLCJwcmV2aW91cyIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJuZXh0IiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiZm9jdXNhYmxlQ2hpbGRyZW4iLCJmb2N1c2FibGVzIiwibWFwIiwiam9pbiIsImVsIiwiTkFNRSRkIiwiRVZFTlRfS0VZJDkiLCJFVkVOVF9UT1VDSFNUQVJUIiwiRVZFTlRfVE9VQ0hNT1ZFIiwiRVZFTlRfVE9VQ0hFTkQiLCJFVkVOVF9QT0lOVEVSRE9XTiIsIkVWRU5UX1BPSU5URVJVUCIsIlBPSU5URVJfVFlQRV9UT1VDSCIsIlBPSU5URVJfVFlQRV9QRU4iLCJDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQiLCJTV0lQRV9USFJFU0hPTEQiLCJEZWZhdWx0JGMiLCJlbmRDYWxsYmFjayIsImxlZnRDYWxsYmFjayIsInJpZ2h0Q2FsbGJhY2siLCJEZWZhdWx0VHlwZSRjIiwiU3dpcGUiLCJpc1N1cHBvcnRlZCIsIl9kZWx0YVgiLCJfc3VwcG9ydFBvaW50ZXJFdmVudHMiLCJQb2ludGVyRXZlbnQiLCJfaW5pdEV2ZW50cyIsInRvdWNoZXMiLCJjbGllbnRYIiwiX2V2ZW50SXNQb2ludGVyUGVuVG91Y2giLCJfaGFuZGxlU3dpcGUiLCJhYnNEZWx0YVgiLCJhYnMiLCJkaXJlY3Rpb24iLCJfc3RhcnQiLCJfZW5kIiwiYWRkIiwiX21vdmUiLCJwb2ludGVyVHlwZSIsIm5hdmlnYXRvciIsIm1heFRvdWNoUG9pbnRzIiwiTkFNRSRjIiwiREFUQV9LRVkkOCIsIkVWRU5UX0tFWSQ4IiwiREFUQV9BUElfS0VZJDUiLCJBUlJPV19MRUZUX0tFWSQxIiwiQVJST1dfUklHSFRfS0VZJDEiLCJUT1VDSEVWRU5UX0NPTVBBVF9XQUlUIiwiT1JERVJfTkVYVCIsIk9SREVSX1BSRVYiLCJESVJFQ1RJT05fTEVGVCIsIkRJUkVDVElPTl9SSUdIVCIsIkVWRU5UX1NMSURFIiwiRVZFTlRfU0xJRCIsIkVWRU5UX0tFWURPV04kMSIsIkVWRU5UX01PVVNFRU5URVIkMSIsIkVWRU5UX01PVVNFTEVBVkUkMSIsIkVWRU5UX0RSQUdfU1RBUlQiLCJFVkVOVF9MT0FEX0RBVEFfQVBJJDMiLCJFVkVOVF9DTElDS19EQVRBX0FQSSQ1IiwiQ0xBU1NfTkFNRV9DQVJPVVNFTCIsIkNMQVNTX05BTUVfQUNUSVZFJDIiLCJDTEFTU19OQU1FX1NMSURFIiwiQ0xBU1NfTkFNRV9FTkQiLCJDTEFTU19OQU1FX1NUQVJUIiwiQ0xBU1NfTkFNRV9ORVhUIiwiQ0xBU1NfTkFNRV9QUkVWIiwiU0VMRUNUT1JfQUNUSVZFIiwiU0VMRUNUT1JfSVRFTSIsIlNFTEVDVE9SX0FDVElWRV9JVEVNIiwiU0VMRUNUT1JfSVRFTV9JTUciLCJTRUxFQ1RPUl9JTkRJQ0FUT1JTIiwiU0VMRUNUT1JfREFUQV9TTElERSIsIlNFTEVDVE9SX0RBVEFfUklERSIsIktFWV9UT19ESVJFQ1RJT04iLCJEZWZhdWx0JGIiLCJpbnRlcnZhbCIsImtleWJvYXJkIiwicGF1c2UiLCJyaWRlIiwidG91Y2giLCJ3cmFwIiwiRGVmYXVsdFR5cGUkYiIsIkNhcm91c2VsIiwiX2ludGVydmFsIiwiX2FjdGl2ZUVsZW1lbnQiLCJfaXNTbGlkaW5nIiwidG91Y2hUaW1lb3V0IiwiX3N3aXBlSGVscGVyIiwiX2luZGljYXRvcnNFbGVtZW50IiwiX2FkZEV2ZW50TGlzdGVuZXJzIiwiY3ljbGUiLCJfc2xpZGUiLCJoaWRkZW4iLCJfY2xlYXJJbnRlcnZhbCIsIl91cGRhdGVJbnRlcnZhbCIsInNldEludGVydmFsIiwibmV4dFdoZW5WaXNpYmxlIiwiaXRlbXMiLCJfZ2V0SXRlbXMiLCJ0byIsImFjdGl2ZUluZGV4IiwiX2dldEl0ZW1JbmRleCIsIl9nZXRBY3RpdmUiLCJvcmRlciIsImRlZmF1bHRJbnRlcnZhbCIsIl9rZXlkb3duIiwiX21heWJlRW5hYmxlQ3ljbGUiLCJfYWRkVG91Y2hFdmVudExpc3RlbmVycyIsImltZyIsImVuZENhbGxCYWNrIiwiY2xlYXJUaW1lb3V0Iiwic3dpcGVDb25maWciLCJfZGlyZWN0aW9uVG9PcmRlciIsImFjdGl2ZUluZGljYXRvciIsIm5ld0FjdGl2ZUluZGljYXRvciIsImVsZW1lbnRJbnRlcnZhbCIsInBhcnNlSW50IiwiaXNOZXh0IiwibmV4dEVsZW1lbnQiLCJuZXh0RWxlbWVudEluZGV4IiwidHJpZ2dlckV2ZW50IiwiZXZlbnROYW1lIiwiX29yZGVyVG9EaXJlY3Rpb24iLCJzbGlkZUV2ZW50IiwiaXNDeWNsaW5nIiwiX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQiLCJkaXJlY3Rpb25hbENsYXNzTmFtZSIsIm9yZGVyQ2xhc3NOYW1lIiwiY29tcGxldGVDYWxsQmFjayIsIl9pc0FuaW1hdGVkIiwiY2xlYXJJbnRlcnZhbCIsImNhcm91c2VsIiwic2xpZGVJbmRleCIsImNhcm91c2VscyIsIk5BTUUkYiIsIkRBVEFfS0VZJDciLCJFVkVOVF9LRVkkNyIsIkRBVEFfQVBJX0tFWSQ0IiwiRVZFTlRfU0hPVyQ2IiwiRVZFTlRfU0hPV04kNiIsIkVWRU5UX0hJREUkNiIsIkVWRU5UX0hJRERFTiQ2IiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCIsIkNMQVNTX05BTUVfU0hPVyQ3IiwiQ0xBU1NfTkFNRV9DT0xMQVBTRSIsIkNMQVNTX05BTUVfQ09MTEFQU0lORyIsIkNMQVNTX05BTUVfQ09MTEFQU0VEIiwiQ0xBU1NfTkFNRV9ERUVQRVJfQ0hJTERSRU4iLCJDTEFTU19OQU1FX0hPUklaT05UQUwiLCJXSURUSCIsIkhFSUdIVCIsIlNFTEVDVE9SX0FDVElWRVMiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0IiwiRGVmYXVsdCRhIiwicGFyZW50IiwiRGVmYXVsdFR5cGUkYSIsIkNvbGxhcHNlIiwiX2lzVHJhbnNpdGlvbmluZyIsIl90cmlnZ2VyQXJyYXkiLCJ0b2dnbGVMaXN0IiwiZWxlbSIsImZpbHRlckVsZW1lbnQiLCJmb3VuZEVsZW1lbnQiLCJfaW5pdGlhbGl6ZUNoaWxkcmVuIiwiX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyIsIl9pc1Nob3duIiwiaGlkZSIsInNob3ciLCJhY3RpdmVDaGlsZHJlbiIsIl9nZXRGaXJzdExldmVsQ2hpbGRyZW4iLCJzdGFydEV2ZW50IiwiYWN0aXZlSW5zdGFuY2UiLCJkaW1lbnNpb24iLCJfZ2V0RGltZW5zaW9uIiwic3R5bGUiLCJjb21wbGV0ZSIsImNhcGl0YWxpemVkRGltZW5zaW9uIiwic2Nyb2xsU2l6ZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNlbGVjdGVkIiwidHJpZ2dlckFycmF5IiwiaXNPcGVuIiwic2VsZWN0b3JFbGVtZW50cyIsInRvcCIsImJvdHRvbSIsInJpZ2h0IiwibGVmdCIsImF1dG8iLCJiYXNlUGxhY2VtZW50cyIsInN0YXJ0IiwiZW5kIiwiY2xpcHBpbmdQYXJlbnRzIiwidmlld3BvcnQiLCJwb3BwZXIiLCJyZWZlcmVuY2UiLCJ2YXJpYXRpb25QbGFjZW1lbnRzIiwicmVkdWNlIiwiYWNjIiwicGxhY2VtZW50IiwicGxhY2VtZW50cyIsImJlZm9yZVJlYWQiLCJyZWFkIiwiYWZ0ZXJSZWFkIiwiYmVmb3JlTWFpbiIsIm1haW4iLCJhZnRlck1haW4iLCJiZWZvcmVXcml0ZSIsIndyaXRlIiwiYWZ0ZXJXcml0ZSIsIm1vZGlmaWVyUGhhc2VzIiwiZ2V0Tm9kZU5hbWUiLCJub2RlTmFtZSIsImdldFdpbmRvdyIsIm5vZGUiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJpc0VsZW1lbnQiLCJPd25FbGVtZW50IiwiaXNIVE1MRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNTaGFkb3dSb290IiwiYXBwbHlTdHlsZXMiLCJfcmVmIiwic3RhdGUiLCJlbGVtZW50cyIsImZvckVhY2giLCJzdHlsZXMiLCJhc3NpZ24iLCJlZmZlY3QkMiIsIl9yZWYyIiwiaW5pdGlhbFN0eWxlcyIsInBvc2l0aW9uIiwib3B0aW9ucyIsInN0cmF0ZWd5IiwibWFyZ2luIiwiYXJyb3ciLCJzdHlsZVByb3BlcnRpZXMiLCJoYXNPd25Qcm9wZXJ0eSIsImF0dHJpYnV0ZSIsImFwcGx5U3R5bGVzJDEiLCJlbmFibGVkIiwicGhhc2UiLCJlZmZlY3QiLCJyZXF1aXJlcyIsImdldEJhc2VQbGFjZW1lbnQiLCJyb3VuZCIsImdldFVBU3RyaW5nIiwidWFEYXRhIiwidXNlckFnZW50RGF0YSIsImJyYW5kcyIsIml0ZW0iLCJicmFuZCIsInZlcnNpb24iLCJ1c2VyQWdlbnQiLCJpc0xheW91dFZpZXdwb3J0IiwiaW5jbHVkZVNjYWxlIiwiaXNGaXhlZFN0cmF0ZWd5IiwiY2xpZW50UmVjdCIsInNjYWxlWCIsInNjYWxlWSIsIm9mZnNldFdpZHRoIiwid2lkdGgiLCJoZWlnaHQiLCJ2aXN1YWxWaWV3cG9ydCIsImFkZFZpc3VhbE9mZnNldHMiLCJ4Iiwib2Zmc2V0TGVmdCIsInkiLCJvZmZzZXRUb3AiLCJnZXRMYXlvdXRSZWN0Iiwicm9vdE5vZGUiLCJpc1NhbWVOb2RlIiwiaG9zdCIsImdldENvbXB1dGVkU3R5bGUkMSIsImlzVGFibGVFbGVtZW50IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiZ2V0UGFyZW50Tm9kZSIsImFzc2lnbmVkU2xvdCIsImdldFRydWVPZmZzZXRQYXJlbnQiLCJvZmZzZXRQYXJlbnQiLCJnZXRDb250YWluaW5nQmxvY2siLCJpc0ZpcmVmb3giLCJpc0lFIiwiZWxlbWVudENzcyIsImN1cnJlbnROb2RlIiwiY3NzIiwidHJhbnNmb3JtIiwicGVyc3BlY3RpdmUiLCJjb250YWluIiwid2lsbENoYW5nZSIsImdldE9mZnNldFBhcmVudCIsImdldE1haW5BeGlzRnJvbVBsYWNlbWVudCIsIndpdGhpbiIsIm1pbiQxIiwibWF4JDEiLCJ3aXRoaW5NYXhDbGFtcCIsInYiLCJnZXRGcmVzaFNpZGVPYmplY3QiLCJtZXJnZVBhZGRpbmdPYmplY3QiLCJwYWRkaW5nT2JqZWN0IiwiZXhwYW5kVG9IYXNoTWFwIiwiaGFzaE1hcCIsInRvUGFkZGluZ09iamVjdCIsInBhZGRpbmciLCJyZWN0cyIsIl9zdGF0ZSRtb2RpZmllcnNEYXRhJCIsImFycm93RWxlbWVudCIsInBvcHBlck9mZnNldHMiLCJtb2RpZmllcnNEYXRhIiwiYmFzZVBsYWNlbWVudCIsImF4aXMiLCJpc1ZlcnRpY2FsIiwibGVuIiwiYXJyb3dSZWN0IiwibWluUHJvcCIsIm1heFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiYXJyb3dPZmZzZXRQYXJlbnQiLCJjbGllbnRTaXplIiwiY2xpZW50SGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJjZW50ZXJUb1JlZmVyZW5jZSIsImNlbnRlciIsIm9mZnNldCIsImF4aXNQcm9wIiwiY2VudGVyT2Zmc2V0IiwiZWZmZWN0JDEiLCJfb3B0aW9ucyRlbGVtZW50IiwiYXJyb3ckMSIsInJlcXVpcmVzSWZFeGlzdHMiLCJnZXRWYXJpYXRpb24iLCJ1bnNldFNpZGVzIiwicm91bmRPZmZzZXRzQnlEUFIiLCJ3aW4iLCJkcHIiLCJkZXZpY2VQaXhlbFJhdGlvIiwibWFwVG9TdHlsZXMiLCJfT2JqZWN0JGFzc2lnbjIiLCJwb3BwZXJSZWN0IiwidmFyaWF0aW9uIiwib2Zmc2V0cyIsImdwdUFjY2VsZXJhdGlvbiIsImFkYXB0aXZlIiwicm91bmRPZmZzZXRzIiwiaXNGaXhlZCIsIl9vZmZzZXRzJHgiLCJfb2Zmc2V0cyR5IiwiX3JlZjMiLCJoYXNYIiwiaGFzWSIsInNpZGVYIiwic2lkZVkiLCJoZWlnaHRQcm9wIiwid2lkdGhQcm9wIiwib2Zmc2V0WSIsIm9mZnNldFgiLCJjb21tb25TdHlsZXMiLCJfcmVmNCIsIl9PYmplY3QkYXNzaWduIiwiY29tcHV0ZVN0eWxlcyIsIl9yZWY1IiwiX29wdGlvbnMkZ3B1QWNjZWxlcmF0IiwiX29wdGlvbnMkYWRhcHRpdmUiLCJfb3B0aW9ucyRyb3VuZE9mZnNldHMiLCJjb21wdXRlU3R5bGVzJDEiLCJwYXNzaXZlIiwiX29wdGlvbnMkc2Nyb2xsIiwic2Nyb2xsIiwiX29wdGlvbnMkcmVzaXplIiwicmVzaXplIiwic2Nyb2xsUGFyZW50cyIsInNjcm9sbFBhcmVudCIsInVwZGF0ZSIsImV2ZW50TGlzdGVuZXJzIiwiaGFzaCQxIiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJtYXRjaGVkIiwiaGFzaCIsImdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IiwiZ2V0V2luZG93U2Nyb2xsIiwic2Nyb2xsTGVmdCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsVG9wIiwicGFnZVlPZmZzZXQiLCJnZXRXaW5kb3dTY3JvbGxCYXJYIiwiZ2V0Vmlld3BvcnRSZWN0IiwiaHRtbCIsImxheW91dFZpZXdwb3J0IiwiZ2V0RG9jdW1lbnRSZWN0IiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwid2luU2Nyb2xsIiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJpc1Njcm9sbFBhcmVudCIsIl9nZXRDb21wdXRlZFN0eWxlIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJnZXRTY3JvbGxQYXJlbnQiLCJsaXN0U2Nyb2xsUGFyZW50cyIsImlzQm9keSIsInVwZGF0ZWRMaXN0IiwicmVjdFRvQ2xpZW50UmVjdCIsInJlY3QiLCJnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFRvcCIsImNsaWVudExlZnQiLCJnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZSIsImNsaXBwaW5nUGFyZW50IiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwiY2FuRXNjYXBlQ2xpcHBpbmciLCJjbGlwcGVyRWxlbWVudCIsImdldENsaXBwaW5nUmVjdCIsImJvdW5kYXJ5Iiwicm9vdEJvdW5kYXJ5IiwibWFpbkNsaXBwaW5nUGFyZW50cyIsImZpcnN0Q2xpcHBpbmdQYXJlbnQiLCJjbGlwcGluZ1JlY3QiLCJhY2NSZWN0IiwiY29tcHV0ZU9mZnNldHMiLCJjb21tb25YIiwiY29tbW9uWSIsIm1haW5BeGlzIiwiZGV0ZWN0T3ZlcmZsb3ciLCJfb3B0aW9ucyIsIl9vcHRpb25zJHBsYWNlbWVudCIsIl9vcHRpb25zJHN0cmF0ZWd5IiwiX29wdGlvbnMkYm91bmRhcnkiLCJfb3B0aW9ucyRyb290Qm91bmRhcnkiLCJfb3B0aW9ucyRlbGVtZW50Q29udGUiLCJlbGVtZW50Q29udGV4dCIsIl9vcHRpb25zJGFsdEJvdW5kYXJ5IiwiYWx0Qm91bmRhcnkiLCJfb3B0aW9ucyRwYWRkaW5nIiwiYWx0Q29udGV4dCIsImNsaXBwaW5nQ2xpZW50UmVjdCIsImNvbnRleHRFbGVtZW50IiwicmVmZXJlbmNlQ2xpZW50UmVjdCIsInBvcHBlckNsaWVudFJlY3QiLCJlbGVtZW50Q2xpZW50UmVjdCIsIm92ZXJmbG93T2Zmc2V0cyIsIm9mZnNldERhdGEiLCJtdWx0aXBseSIsImNvbXB1dGVBdXRvUGxhY2VtZW50IiwiZmxpcFZhcmlhdGlvbnMiLCJfb3B0aW9ucyRhbGxvd2VkQXV0b1AiLCJhbGxvd2VkQXV0b1BsYWNlbWVudHMiLCJwbGFjZW1lbnRzJDEiLCJhbGxvd2VkUGxhY2VtZW50cyIsIm92ZXJmbG93cyIsInNvcnQiLCJhIiwiYiIsImdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzIiwib3Bwb3NpdGVQbGFjZW1lbnQiLCJmbGlwIiwiX3NraXAiLCJfb3B0aW9ucyRtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJfb3B0aW9ucyRhbHRBeGlzIiwiYWx0QXhpcyIsImNoZWNrQWx0QXhpcyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrUGxhY2VtZW50cyIsIl9vcHRpb25zJGZsaXBWYXJpYXRpbyIsInByZWZlcnJlZFBsYWNlbWVudCIsImlzQmFzZVBsYWNlbWVudCIsInJlZmVyZW5jZVJlY3QiLCJjaGVja3NNYXAiLCJtYWtlRmFsbGJhY2tDaGVja3MiLCJmaXJzdEZpdHRpbmdQbGFjZW1lbnQiLCJpIiwiX2Jhc2VQbGFjZW1lbnQiLCJpc1N0YXJ0VmFyaWF0aW9uIiwibWFpblZhcmlhdGlvblNpZGUiLCJhbHRWYXJpYXRpb25TaWRlIiwiY2hlY2tzIiwiZXZlcnkiLCJjaGVjayIsIm51bWJlck9mQ2hlY2tzIiwiX2xvb3AiLCJfaSIsImZpdHRpbmdQbGFjZW1lbnQiLCJfcmV0IiwicmVzZXQiLCJmbGlwJDEiLCJnZXRTaWRlT2Zmc2V0cyIsInByZXZlbnRlZE9mZnNldHMiLCJpc0FueVNpZGVGdWxseUNsaXBwZWQiLCJzb21lIiwic2lkZSIsInByZXZlbnRPdmVyZmxvdyIsInJlZmVyZW5jZU92ZXJmbG93IiwicG9wcGVyQWx0T3ZlcmZsb3ciLCJyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMiLCJwb3BwZXJFc2NhcGVPZmZzZXRzIiwiaXNSZWZlcmVuY2VIaWRkZW4iLCJoYXNQb3BwZXJFc2NhcGVkIiwiaGlkZSQxIiwiZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkiLCJpbnZlcnREaXN0YW5jZSIsInNraWRkaW5nIiwiZGlzdGFuY2UiLCJfb3B0aW9ucyRvZmZzZXQiLCJfZGF0YSRzdGF0ZSRwbGFjZW1lbnQiLCJvZmZzZXQkMSIsInBvcHBlck9mZnNldHMkMSIsImdldEFsdEF4aXMiLCJfb3B0aW9ucyR0ZXRoZXIiLCJ0ZXRoZXIiLCJfb3B0aW9ucyR0ZXRoZXJPZmZzZXQiLCJ0ZXRoZXJPZmZzZXQiLCJ0ZXRoZXJPZmZzZXRWYWx1ZSIsIm5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSIsIm9mZnNldE1vZGlmaWVyU3RhdGUiLCJfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQiLCJtYWluU2lkZSIsImFsdFNpZGUiLCJhZGRpdGl2ZSIsIm1pbkxlbiIsIm1heExlbiIsImFycm93UGFkZGluZ09iamVjdCIsImFycm93UGFkZGluZ01pbiIsImFycm93UGFkZGluZ01heCIsImFycm93TGVuIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiY2xpZW50T2Zmc2V0Iiwib2Zmc2V0TW9kaWZpZXJWYWx1ZSIsInRldGhlck1pbiIsInRldGhlck1heCIsInByZXZlbnRlZE9mZnNldCIsIl9vZmZzZXRNb2RpZmllclN0YXRlJDIiLCJfbWFpblNpZGUiLCJfYWx0U2lkZSIsIl9vZmZzZXQiLCJfbGVuIiwiX21pbiIsIl9tYXgiLCJpc09yaWdpblNpZGUiLCJfb2Zmc2V0TW9kaWZpZXJWYWx1ZSIsIl90ZXRoZXJNaW4iLCJfdGV0aGVyTWF4IiwiX3ByZXZlbnRlZE9mZnNldCIsInByZXZlbnRPdmVyZmxvdyQxIiwiZ2V0SFRNTEVsZW1lbnRTY3JvbGwiLCJnZXROb2RlU2Nyb2xsIiwiaXNFbGVtZW50U2NhbGVkIiwiZ2V0Q29tcG9zaXRlUmVjdCIsImVsZW1lbnRPclZpcnR1YWxFbGVtZW50IiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJvZmZzZXRQYXJlbnRJc1NjYWxlZCIsIm1vZGlmaWVycyIsInZpc2l0ZWQiLCJyZXN1bHQiLCJtb2RpZmllciIsImRlcCIsImRlcE1vZGlmaWVyIiwib3JkZXJNb2RpZmllcnMiLCJvcmRlcmVkTW9kaWZpZXJzIiwiZGVib3VuY2UiLCJwZW5kaW5nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwibWVyZ2VCeU5hbWUiLCJtZXJnZWQiLCJjdXJyZW50IiwiZXhpc3RpbmciLCJERUZBVUxUX09QVElPTlMiLCJhcmVWYWxpZEVsZW1lbnRzIiwiYXJndW1lbnRzIiwiX2tleSIsInBvcHBlckdlbmVyYXRvciIsImdlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZiIsImRlZmF1bHRNb2RpZmllcnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyIiwiZGVmYXVsdE9wdGlvbnMiLCJjcmVhdGVQb3BwZXIiLCJlZmZlY3RDbGVhbnVwRm5zIiwiaXNEZXN0cm95ZWQiLCJzZXRPcHRpb25zIiwic2V0T3B0aW9uc0FjdGlvbiIsImNsZWFudXBNb2RpZmllckVmZmVjdHMiLCJtIiwicnVuTW9kaWZpZXJFZmZlY3RzIiwiZm9yY2VVcGRhdGUiLCJfc3RhdGUkZWxlbWVudHMiLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUiLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUyIiwiZGVzdHJveSIsIm9uRmlyc3RVcGRhdGUiLCJfcmVmMyRvcHRpb25zIiwiY2xlYW51cEZuIiwibm9vcEZuIiwiY3JlYXRlUG9wcGVyJDIiLCJkZWZhdWx0TW9kaWZpZXJzJDEiLCJjcmVhdGVQb3BwZXIkMSIsIlBvcHBlciIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsImNyZWF0ZVBvcHBlckJhc2UiLCJjcmVhdGVQb3BwZXJMaXRlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJOQU1FJGEiLCJEQVRBX0tFWSQ2IiwiRVZFTlRfS0VZJDYiLCJEQVRBX0FQSV9LRVkkMyIsIkVTQ0FQRV9LRVkkMiIsIlRBQl9LRVkkMSIsIkFSUk9XX1VQX0tFWSQxIiwiQVJST1dfRE9XTl9LRVkkMSIsIlJJR0hUX01PVVNFX0JVVFRPTiIsIkVWRU5UX0hJREUkNSIsIkVWRU5UX0hJRERFTiQ1IiwiRVZFTlRfU0hPVyQ1IiwiRVZFTlRfU0hPV04kNSIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJJDMiLCJFVkVOVF9LRVlET1dOX0RBVEFfQVBJIiwiRVZFTlRfS0VZVVBfREFUQV9BUEkiLCJDTEFTU19OQU1FX1NIT1ckNiIsIkNMQVNTX05BTUVfRFJPUFVQIiwiQ0xBU1NfTkFNRV9EUk9QRU5EIiwiQ0xBU1NfTkFNRV9EUk9QU1RBUlQiLCJDTEFTU19OQU1FX0RST1BVUF9DRU5URVIiLCJDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUiIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFJDMiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRV9TSE9XTiIsIlNFTEVDVE9SX01FTlUiLCJTRUxFQ1RPUl9OQVZCQVIiLCJTRUxFQ1RPUl9OQVZCQVJfTkFWIiwiU0VMRUNUT1JfVklTSUJMRV9JVEVNUyIsIlBMQUNFTUVOVF9UT1AiLCJQTEFDRU1FTlRfVE9QRU5EIiwiUExBQ0VNRU5UX0JPVFRPTSIsIlBMQUNFTUVOVF9CT1RUT01FTkQiLCJQTEFDRU1FTlRfUklHSFQiLCJQTEFDRU1FTlRfTEVGVCIsIlBMQUNFTUVOVF9UT1BDRU5URVIiLCJQTEFDRU1FTlRfQk9UVE9NQ0VOVEVSIiwiRGVmYXVsdCQ5IiwiYXV0b0Nsb3NlIiwiZGlzcGxheSIsInBvcHBlckNvbmZpZyIsIkRlZmF1bHRUeXBlJDkiLCJEcm9wZG93biIsIl9wb3BwZXIiLCJfcGFyZW50IiwiX21lbnUiLCJfaW5OYXZiYXIiLCJfZGV0ZWN0TmF2YmFyIiwic2hvd0V2ZW50IiwiX2NyZWF0ZVBvcHBlciIsImZvY3VzIiwiX2NvbXBsZXRlSGlkZSIsImhpZGVFdmVudCIsInJlZmVyZW5jZUVsZW1lbnQiLCJfZ2V0UG9wcGVyQ29uZmlnIiwicGFyZW50RHJvcGRvd24iLCJpc0VuZCIsInBvcHBlckRhdGEiLCJkZWZhdWx0QnNQb3BwZXJDb25maWciLCJfZ2V0UGxhY2VtZW50IiwiX2dldE9mZnNldCIsIm9wZW5Ub2dnbGVzIiwiY29udGV4dCIsImNvbXBvc2VkUGF0aCIsImlzTWVudVRhcmdldCIsImlzSW5wdXQiLCJpc0VzY2FwZUV2ZW50IiwiaXNVcE9yRG93bkV2ZW50IiwiZ2V0VG9nZ2xlQnV0dG9uIiwic3RvcFByb3BhZ2F0aW9uIiwiX3NlbGVjdE1lbnVJdGVtIiwiZGF0YUFwaUtleWRvd25IYW5kbGVyIiwiY2xlYXJNZW51cyIsIlNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQiLCJTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCIsIlBST1BFUlRZX1BBRERJTkciLCJQUk9QRVJUWV9NQVJHSU4iLCJTY3JvbGxCYXJIZWxwZXIiLCJkb2N1bWVudFdpZHRoIiwiaW5uZXJXaWR0aCIsImdldFdpZHRoIiwiX2Rpc2FibGVPdmVyRmxvdyIsIl9zZXRFbGVtZW50QXR0cmlidXRlcyIsImNhbGN1bGF0ZWRWYWx1ZSIsIl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzIiwiX3NhdmVJbml0aWFsQXR0cmlidXRlIiwic3R5bGVQcm9wZXJ0eSIsInNjcm9sbGJhcldpZHRoIiwibWFuaXB1bGF0aW9uQ2FsbEJhY2siLCJzZXRQcm9wZXJ0eSIsIl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrIiwiYWN0dWFsVmFsdWUiLCJyZW1vdmVQcm9wZXJ0eSIsImNhbGxCYWNrIiwic2VsIiwiTkFNRSQ5IiwiQ0xBU1NfTkFNRV9GQURFJDQiLCJDTEFTU19OQU1FX1NIT1ckNSIsIkVWRU5UX01PVVNFRE9XTiIsIkRlZmF1bHQkOCIsImNsYXNzTmFtZSIsImNsaWNrQ2FsbGJhY2siLCJyb290RWxlbWVudCIsIkRlZmF1bHRUeXBlJDgiLCJCYWNrZHJvcCIsIl9pc0FwcGVuZGVkIiwiX2FwcGVuZCIsIl9nZXRFbGVtZW50IiwiX2VtdWxhdGVBbmltYXRpb24iLCJiYWNrZHJvcCIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmQiLCJOQU1FJDgiLCJEQVRBX0tFWSQ1IiwiRVZFTlRfS0VZJDUiLCJFVkVOVF9GT0NVU0lOJDIiLCJFVkVOVF9LRVlET1dOX1RBQiIsIlRBQl9LRVkiLCJUQUJfTkFWX0ZPUldBUkQiLCJUQUJfTkFWX0JBQ0tXQVJEIiwiRGVmYXVsdCQ3IiwiYXV0b2ZvY3VzIiwidHJhcEVsZW1lbnQiLCJEZWZhdWx0VHlwZSQ3IiwiRm9jdXNUcmFwIiwiX2lzQWN0aXZlIiwiX2xhc3RUYWJOYXZEaXJlY3Rpb24iLCJfaGFuZGxlRm9jdXNpbiIsIl9oYW5kbGVLZXlkb3duIiwic2hpZnRLZXkiLCJOQU1FJDciLCJEQVRBX0tFWSQ0IiwiRVZFTlRfS0VZJDQiLCJEQVRBX0FQSV9LRVkkMiIsIkVTQ0FQRV9LRVkkMSIsIkVWRU5UX0hJREUkNCIsIkVWRU5UX0hJREVfUFJFVkVOVEVEJDEiLCJFVkVOVF9ISURERU4kNCIsIkVWRU5UX1NIT1ckNCIsIkVWRU5UX1NIT1dOJDQiLCJFVkVOVF9SRVNJWkUkMSIsIkVWRU5UX0NMSUNLX0RJU01JU1MiLCJFVkVOVF9NT1VTRURPV05fRElTTUlTUyIsIkVWRU5UX0tFWURPV05fRElTTUlTUyQxIiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMiIsIkNMQVNTX05BTUVfT1BFTiIsIkNMQVNTX05BTUVfRkFERSQzIiwiQ0xBU1NfTkFNRV9TSE9XJDQiLCJDTEFTU19OQU1FX1NUQVRJQyIsIk9QRU5fU0VMRUNUT1IkMSIsIlNFTEVDVE9SX0RJQUxPRyIsIlNFTEVDVE9SX01PREFMX0JPRFkiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyIiwiRGVmYXVsdCQ2IiwiRGVmYXVsdFR5cGUkNiIsIk1vZGFsIiwiX2RpYWxvZyIsIl9iYWNrZHJvcCIsIl9pbml0aWFsaXplQmFja0Ryb3AiLCJfZm9jdXN0cmFwIiwiX2luaXRpYWxpemVGb2N1c1RyYXAiLCJfc2Nyb2xsQmFyIiwiX2FkanVzdERpYWxvZyIsIl9zaG93RWxlbWVudCIsImRlYWN0aXZhdGUiLCJfaGlkZU1vZGFsIiwiaHRtbEVsZW1lbnQiLCJtb2RhbEJvZHkiLCJ0cmFuc2l0aW9uQ29tcGxldGUiLCJhY3RpdmF0ZSIsIl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uIiwiZXZlbnQyIiwiX3Jlc2V0QWRqdXN0bWVudHMiLCJpc01vZGFsT3ZlcmZsb3dpbmciLCJpbml0aWFsT3ZlcmZsb3dZIiwiaXNCb2R5T3ZlcmZsb3dpbmciLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImFscmVhZHlPcGVuIiwiTkFNRSQ2IiwiREFUQV9LRVkkMyIsIkVWRU5UX0tFWSQzIiwiREFUQV9BUElfS0VZJDEiLCJFVkVOVF9MT0FEX0RBVEFfQVBJJDIiLCJFU0NBUEVfS0VZIiwiQ0xBU1NfTkFNRV9TSE9XJDMiLCJDTEFTU19OQU1FX1NIT1dJTkckMSIsIkNMQVNTX05BTUVfSElESU5HIiwiQ0xBU1NfTkFNRV9CQUNLRFJPUCIsIk9QRU5fU0VMRUNUT1IiLCJFVkVOVF9TSE9XJDMiLCJFVkVOVF9TSE9XTiQzIiwiRVZFTlRfSElERSQzIiwiRVZFTlRfSElERV9QUkVWRU5URUQiLCJFVkVOVF9ISURERU4kMyIsIkVWRU5UX1JFU0laRSIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJJDEiLCJFVkVOVF9LRVlET1dOX0RJU01JU1MiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxIiwiRGVmYXVsdCQ1IiwiRGVmYXVsdFR5cGUkNSIsIk9mZmNhbnZhcyIsImJsdXIiLCJjb21wbGV0ZUNhbGxiYWNrIiwidXJpQXR0cmlidXRlcyIsIkFSSUFfQVRUUklCVVRFX1BBVFRFUk4iLCJTQUZFX1VSTF9QQVRURVJOIiwiREFUQV9VUkxfUEFUVEVSTiIsImFsbG93ZWRBdHRyaWJ1dGUiLCJhbGxvd2VkQXR0cmlidXRlTGlzdCIsImF0dHJpYnV0ZU5hbWUiLCJub2RlVmFsdWUiLCJhdHRyaWJ1dGVSZWdleCIsInJlZ2V4IiwiRGVmYXVsdEFsbG93bGlzdCIsImFyZWEiLCJiciIsImNvbCIsImNvZGUiLCJkaXYiLCJlbSIsImhyIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwibGkiLCJvbCIsInAiLCJwcmUiLCJzIiwic21hbGwiLCJzcGFuIiwic3ViIiwic3VwIiwic3Ryb25nIiwidSIsInVsIiwic2FuaXRpemVIdG1sIiwidW5zYWZlSHRtbCIsImFsbG93TGlzdCIsInNhbml0aXplRnVuY3Rpb24iLCJkb21QYXJzZXIiLCJET01QYXJzZXIiLCJjcmVhdGVkRG9jdW1lbnQiLCJwYXJzZUZyb21TdHJpbmciLCJlbGVtZW50TmFtZSIsImF0dHJpYnV0ZUxpc3QiLCJhbGxvd2VkQXR0cmlidXRlcyIsImlubmVySFRNTCIsIk5BTUUkNSIsIkRlZmF1bHQkNCIsImNvbnRlbnQiLCJleHRyYUNsYXNzIiwic2FuaXRpemUiLCJzYW5pdGl6ZUZuIiwidGVtcGxhdGUiLCJEZWZhdWx0VHlwZSQ0IiwiRGVmYXVsdENvbnRlbnRUeXBlIiwiZW50cnkiLCJUZW1wbGF0ZUZhY3RvcnkiLCJfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24iLCJnZXRDb250ZW50IiwiX2NoZWNrQ29udGVudCIsInRlbXBsYXRlV3JhcHBlciIsIl9tYXliZVNhbml0aXplIiwidGV4dCIsIl9zZXRDb250ZW50IiwiYXJnIiwidGVtcGxhdGVFbGVtZW50IiwiX3B1dEVsZW1lbnRJblRlbXBsYXRlIiwidGV4dENvbnRlbnQiLCJOQU1FJDQiLCJESVNBTExPV0VEX0FUVFJJQlVURVMiLCJDTEFTU19OQU1FX0ZBREUkMiIsIkNMQVNTX05BTUVfTU9EQUwiLCJDTEFTU19OQU1FX1NIT1ckMiIsIlNFTEVDVE9SX1RPT0xUSVBfSU5ORVIiLCJTRUxFQ1RPUl9NT0RBTCIsIkVWRU5UX01PREFMX0hJREUiLCJUUklHR0VSX0hPVkVSIiwiVFJJR0dFUl9GT0NVUyIsIlRSSUdHRVJfQ0xJQ0siLCJUUklHR0VSX01BTlVBTCIsIkVWRU5UX0hJREUkMiIsIkVWRU5UX0hJRERFTiQyIiwiRVZFTlRfU0hPVyQyIiwiRVZFTlRfU0hPV04kMiIsIkVWRU5UX0lOU0VSVEVEIiwiRVZFTlRfQ0xJQ0skMSIsIkVWRU5UX0ZPQ1VTSU4kMSIsIkVWRU5UX0ZPQ1VTT1VUJDEiLCJFVkVOVF9NT1VTRUVOVEVSIiwiRVZFTlRfTU9VU0VMRUFWRSIsIkF0dGFjaG1lbnRNYXAiLCJBVVRPIiwiVE9QIiwiUklHSFQiLCJCT1RUT00iLCJMRUZUIiwiRGVmYXVsdCQzIiwiYW5pbWF0aW9uIiwiY29udGFpbmVyIiwiY3VzdG9tQ2xhc3MiLCJkZWxheSIsInRpdGxlIiwiRGVmYXVsdFR5cGUkMyIsIlRvb2x0aXAiLCJfaXNFbmFibGVkIiwiX3RpbWVvdXQiLCJfaXNIb3ZlcmVkIiwiX2FjdGl2ZVRyaWdnZXIiLCJfdGVtcGxhdGVGYWN0b3J5IiwiX25ld0NvbnRlbnQiLCJ0aXAiLCJfc2V0TGlzdGVuZXJzIiwiX2ZpeFRpdGxlIiwiY2xpY2siLCJfbGVhdmUiLCJfZW50ZXIiLCJfaGlkZU1vZGFsSGFuZGxlciIsIl9kaXNwb3NlUG9wcGVyIiwiX2lzV2l0aENvbnRlbnQiLCJzaGFkb3dSb290IiwiaXNJblRoZURvbSIsIl9nZXRUaXBFbGVtZW50IiwiX2lzV2l0aEFjdGl2ZVRyaWdnZXIiLCJfZ2V0VGl0bGUiLCJfY3JlYXRlVGlwRWxlbWVudCIsIl9nZXRDb250ZW50Rm9yVGVtcGxhdGUiLCJfZ2V0VGVtcGxhdGVGYWN0b3J5IiwidG9IdG1sIiwidGlwSWQiLCJjaGFuZ2VDb250ZW50IiwiX2dldERlbGVnYXRlQ29uZmlnIiwiYXR0YWNobWVudCIsInRyaWdnZXJzIiwiX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCIsImV2ZW50SW4iLCJldmVudE91dCIsIl9zZXRUaW1lb3V0IiwidGltZW91dCIsImRhdGFBdHRyaWJ1dGVzIiwiZGF0YUF0dHJpYnV0ZSIsIk5BTUUkMyIsIlNFTEVDVE9SX1RJVExFIiwiU0VMRUNUT1JfQ09OVEVOVCIsIkRlZmF1bHQkMiIsIkRlZmF1bHRUeXBlJDIiLCJQb3BvdmVyIiwiX2dldENvbnRlbnQiLCJOQU1FJDIiLCJEQVRBX0tFWSQyIiwiRVZFTlRfS0VZJDIiLCJEQVRBX0FQSV9LRVkiLCJFVkVOVF9BQ1RJVkFURSIsIkVWRU5UX0NMSUNLIiwiRVZFTlRfTE9BRF9EQVRBX0FQSSQxIiwiQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNIiwiQ0xBU1NfTkFNRV9BQ1RJVkUkMSIsIlNFTEVDVE9SX0RBVEFfU1BZIiwiU0VMRUNUT1JfVEFSR0VUX0xJTktTIiwiU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAiLCJTRUxFQ1RPUl9OQVZfTElOS1MiLCJTRUxFQ1RPUl9OQVZfSVRFTVMiLCJTRUxFQ1RPUl9MSVNUX0lURU1TIiwiU0VMRUNUT1JfTElOS19JVEVNUyIsIlNFTEVDVE9SX0RST1BET1dOIiwiU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEiLCJEZWZhdWx0JDEiLCJyb290TWFyZ2luIiwic21vb3RoU2Nyb2xsIiwidGhyZXNob2xkIiwiRGVmYXVsdFR5cGUkMSIsIlNjcm9sbFNweSIsIl90YXJnZXRMaW5rcyIsIl9vYnNlcnZhYmxlU2VjdGlvbnMiLCJfcm9vdEVsZW1lbnQiLCJfYWN0aXZlVGFyZ2V0IiwiX29ic2VydmVyIiwiX3ByZXZpb3VzU2Nyb2xsRGF0YSIsInZpc2libGVFbnRyeVRvcCIsInBhcmVudFNjcm9sbFRvcCIsInJlZnJlc2giLCJfaW5pdGlhbGl6ZVRhcmdldHNBbmRPYnNlcnZhYmxlcyIsIl9tYXliZUVuYWJsZVNtb290aFNjcm9sbCIsImRpc2Nvbm5lY3QiLCJfZ2V0TmV3T2JzZXJ2ZXIiLCJzZWN0aW9uIiwib2JzZXJ2ZSIsIm9ic2VydmFibGVTZWN0aW9uIiwic2Nyb2xsVG8iLCJiZWhhdmlvciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiX29ic2VydmVyQ2FsbGJhY2siLCJ0YXJnZXRFbGVtZW50IiwiaWQiLCJfcHJvY2VzcyIsInVzZXJTY3JvbGxzRG93biIsImlzSW50ZXJzZWN0aW5nIiwiX2NsZWFyQWN0aXZlQ2xhc3MiLCJlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMiLCJ0YXJnZXRMaW5rcyIsImFuY2hvciIsIl9hY3RpdmF0ZVBhcmVudHMiLCJsaXN0R3JvdXAiLCJhY3RpdmVOb2RlcyIsInNweSIsIk5BTUUkMSIsIkRBVEFfS0VZJDEiLCJFVkVOVF9LRVkkMSIsIkVWRU5UX0hJREUkMSIsIkVWRU5UX0hJRERFTiQxIiwiRVZFTlRfU0hPVyQxIiwiRVZFTlRfU0hPV04kMSIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJIiwiRVZFTlRfS0VZRE9XTiIsIkVWRU5UX0xPQURfREFUQV9BUEkiLCJBUlJPV19MRUZUX0tFWSIsIkFSUk9XX1JJR0hUX0tFWSIsIkFSUk9XX1VQX0tFWSIsIkFSUk9XX0RPV05fS0VZIiwiQ0xBU1NfTkFNRV9BQ1RJVkUiLCJDTEFTU19OQU1FX0ZBREUkMSIsIkNMQVNTX05BTUVfU0hPVyQxIiwiQ0xBU1NfRFJPUERPV04iLCJTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUiLCJTRUxFQ1RPUl9EUk9QRE9XTl9NRU5VIiwiTk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRSIsIlNFTEVDVE9SX1RBQl9QQU5FTCIsIlNFTEVDVE9SX09VVEVSIiwiU0VMRUNUT1JfSU5ORVIiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSIsIlNFTEVDVE9SX0lOTkVSX0VMRU0iLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUiLCJUYWIiLCJfc2V0SW5pdGlhbEF0dHJpYnV0ZXMiLCJfZ2V0Q2hpbGRyZW4iLCJpbm5lckVsZW0iLCJfZWxlbUlzQWN0aXZlIiwiYWN0aXZlIiwiX2dldEFjdGl2ZUVsZW0iLCJfZGVhY3RpdmF0ZSIsIl9hY3RpdmF0ZSIsInJlbGF0ZWRFbGVtIiwiX3RvZ2dsZURyb3BEb3duIiwibmV4dEFjdGl2ZUVsZW1lbnQiLCJwcmV2ZW50U2Nyb2xsIiwiX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzIiwiX3NldEluaXRpYWxBdHRyaWJ1dGVzT25DaGlsZCIsIl9nZXRJbm5lckVsZW1lbnQiLCJpc0FjdGl2ZSIsIm91dGVyRWxlbSIsIl9nZXRPdXRlckVsZW1lbnQiLCJfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPblRhcmdldFBhbmVsIiwib3BlbiIsIkVWRU5UX01PVVNFT1ZFUiIsIkVWRU5UX01PVVNFT1VUIiwiRVZFTlRfRk9DVVNJTiIsIkVWRU5UX0ZPQ1VTT1VUIiwiRVZFTlRfSElERSIsIkVWRU5UX0hJRERFTiIsIkVWRU5UX1NIT1ciLCJFVkVOVF9TSE9XTiIsIkNMQVNTX05BTUVfRkFERSIsIkNMQVNTX05BTUVfSElERSIsIkNMQVNTX05BTUVfU0hPVyIsIkNMQVNTX05BTUVfU0hPV0lORyIsImF1dG9oaWRlIiwiVG9hc3QiLCJfaGFzTW91c2VJbnRlcmFjdGlvbiIsIl9oYXNLZXlib2FyZEludGVyYWN0aW9uIiwiX2NsZWFyVGltZW91dCIsIl9tYXliZVNjaGVkdWxlSGlkZSIsImlzU2hvd24iLCJpc0ludGVyYWN0aW5nIiwiX29uSW50ZXJhY3Rpb24iLCJpbmRleF91bWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/user/bootstrap.bundle.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/js/user/app.js");
/******/ 	
/******/ })()
;