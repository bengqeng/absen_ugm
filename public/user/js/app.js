/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/bootstrap.bundle.js":
/*!******************************************!*\
  !*** ./resources/js/bootstrap.bundle.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*!\n  * Bootstrap v5.2.3 (https://getbootstrap.com/)\n  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function () {\n  'use strict';\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): util/index.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  var _KEY_TO_DIRECTION;\n  var MAX_UID = 1000000;\n  var MILLISECONDS_MULTIPLIER = 1000;\n  var TRANSITION_END = 'transitionend'; // Shout-out Angus Croll (https://goo.gl/pxwQGp)\n\n  var toType = function toType(object) {\n    if (object === null || object === undefined) {\n      return \"\".concat(object);\n    }\n    return Object.prototype.toString.call(object).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  };\n  /**\n   * Public Util API\n   */\n\n  var getUID = function getUID(prefix) {\n    do {\n      prefix += Math.floor(Math.random() * MAX_UID);\n    } while (document.getElementById(prefix));\n    return prefix;\n  };\n  var getSelector = function getSelector(element) {\n    var selector = element.getAttribute('data-bs-target');\n    if (!selector || selector === '#') {\n      var hrefAttribute = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,\n      // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n      // `document.querySelector` will rightfully complain it is invalid.\n      // See https://github.com/twbs/bootstrap/issues/32273\n\n      if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {\n        return null;\n      } // Just in case some CMS puts out a full URL with the anchor appended\n\n      if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {\n        hrefAttribute = \"#\".concat(hrefAttribute.split('#')[1]);\n      }\n      selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;\n    }\n    return selector;\n  };\n  var getSelectorFromElement = function getSelectorFromElement(element) {\n    var selector = getSelector(element);\n    if (selector) {\n      return document.querySelector(selector) ? selector : null;\n    }\n    return null;\n  };\n  var getElementFromSelector = function getElementFromSelector(element) {\n    var selector = getSelector(element);\n    return selector ? document.querySelector(selector) : null;\n  };\n  var getTransitionDurationFromElement = function getTransitionDurationFromElement(element) {\n    if (!element) {\n      return 0;\n    } // Get transition-duration of the element\n\n    var _window$getComputedSt = window.getComputedStyle(element),\n      transitionDuration = _window$getComputedSt.transitionDuration,\n      transitionDelay = _window$getComputedSt.transitionDelay;\n    var floatTransitionDuration = Number.parseFloat(transitionDuration);\n    var floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found\n\n    if (!floatTransitionDuration && !floatTransitionDelay) {\n      return 0;\n    } // If multiple durations are defined, take the first\n\n    transitionDuration = transitionDuration.split(',')[0];\n    transitionDelay = transitionDelay.split(',')[0];\n    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n  };\n  var triggerTransitionEnd = function triggerTransitionEnd(element) {\n    element.dispatchEvent(new Event(TRANSITION_END));\n  };\n  var isElement$1 = function isElement$1(object) {\n    if (!object || _typeof(object) !== 'object') {\n      return false;\n    }\n    if (typeof object.jquery !== 'undefined') {\n      object = object[0];\n    }\n    return typeof object.nodeType !== 'undefined';\n  };\n  var getElement = function getElement(object) {\n    // it's a jQuery object or a node element\n    if (isElement$1(object)) {\n      return object.jquery ? object[0] : object;\n    }\n    if (typeof object === 'string' && object.length > 0) {\n      return document.querySelector(object);\n    }\n    return null;\n  };\n  var isVisible = function isVisible(element) {\n    if (!isElement$1(element) || element.getClientRects().length === 0) {\n      return false;\n    }\n    var elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible'; // Handle `details` element as its content may falsie appear visible when it is closed\n\n    var closedDetails = element.closest('details:not([open])');\n    if (!closedDetails) {\n      return elementIsVisible;\n    }\n    if (closedDetails !== element) {\n      var summary = element.closest('summary');\n      if (summary && summary.parentNode !== closedDetails) {\n        return false;\n      }\n      if (summary === null) {\n        return false;\n      }\n    }\n    return elementIsVisible;\n  };\n  var isDisabled = function isDisabled(element) {\n    if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n      return true;\n    }\n    if (element.classList.contains('disabled')) {\n      return true;\n    }\n    if (typeof element.disabled !== 'undefined') {\n      return element.disabled;\n    }\n    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';\n  };\n  var findShadowRoot = function findShadowRoot(element) {\n    if (!document.documentElement.attachShadow) {\n      return null;\n    } // Can find the shadow root otherwise it'll return the document\n\n    if (typeof element.getRootNode === 'function') {\n      var root = element.getRootNode();\n      return root instanceof ShadowRoot ? root : null;\n    }\n    if (element instanceof ShadowRoot) {\n      return element;\n    } // when we don't find a shadow root\n\n    if (!element.parentNode) {\n      return null;\n    }\n    return findShadowRoot(element.parentNode);\n  };\n  var noop = function noop() {};\n  /**\n   * Trick to restart an element's animation\n   *\n   * @param {HTMLElement} element\n   * @return void\n   *\n   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation\n   */\n\n  var reflow = function reflow(element) {\n    element.offsetHeight; // eslint-disable-line no-unused-expressions\n  };\n\n  var getjQuery = function getjQuery() {\n    if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {\n      return window.jQuery;\n    }\n    return null;\n  };\n  var DOMContentLoadedCallbacks = [];\n  var onDOMContentLoaded = function onDOMContentLoaded(callback) {\n    if (document.readyState === 'loading') {\n      // add listener on the first call when the document is in loading state\n      if (!DOMContentLoadedCallbacks.length) {\n        document.addEventListener('DOMContentLoaded', function () {\n          var _iterator = _createForOfIteratorHelper(DOMContentLoadedCallbacks),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _callback = _step.value;\n              _callback();\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        });\n      }\n      DOMContentLoadedCallbacks.push(callback);\n    } else {\n      callback();\n    }\n  };\n  var isRTL = function isRTL() {\n    return document.documentElement.dir === 'rtl';\n  };\n  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {\n    onDOMContentLoaded(function () {\n      var $ = getjQuery();\n      /* istanbul ignore if */\n\n      if ($) {\n        var name = plugin.NAME;\n        var JQUERY_NO_CONFLICT = $.fn[name];\n        $.fn[name] = plugin.jQueryInterface;\n        $.fn[name].Constructor = plugin;\n        $.fn[name].noConflict = function () {\n          $.fn[name] = JQUERY_NO_CONFLICT;\n          return plugin.jQueryInterface;\n        };\n      }\n    });\n  };\n  var execute = function execute(callback) {\n    if (typeof callback === 'function') {\n      callback();\n    }\n  };\n  var executeAfterTransition = function executeAfterTransition(callback, transitionElement) {\n    var waitForTransition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (!waitForTransition) {\n      execute(callback);\n      return;\n    }\n    var durationPadding = 5;\n    var emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;\n    var called = false;\n    var handler = function handler(_ref6) {\n      var target = _ref6.target;\n      if (target !== transitionElement) {\n        return;\n      }\n      called = true;\n      transitionElement.removeEventListener(TRANSITION_END, handler);\n      execute(callback);\n    };\n    transitionElement.addEventListener(TRANSITION_END, handler);\n    setTimeout(function () {\n      if (!called) {\n        triggerTransitionEnd(transitionElement);\n      }\n    }, emulatedDuration);\n  };\n  /**\n   * Return the previous/next element of a list.\n   *\n   * @param {array} list    The list of elements\n   * @param activeElement   The active element\n   * @param shouldGetNext   Choose to get next or previous element\n   * @param isCycleAllowed\n   * @return {Element|elem} The proper element\n   */\n\n  var getNextActiveElement = function getNextActiveElement(list, activeElement, shouldGetNext, isCycleAllowed) {\n    var listLength = list.length;\n    var index = list.indexOf(activeElement); // if the element does not exist in the list return an element\n    // depending on the direction and if cycle is allowed\n\n    if (index === -1) {\n      return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];\n    }\n    index += shouldGetNext ? 1 : -1;\n    if (isCycleAllowed) {\n      index = (index + listLength) % listLength;\n    }\n    return list[Math.max(0, Math.min(index, listLength - 1))];\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): dom/event-handler.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  var namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\n  var stripNameRegex = /\\..*/;\n  var stripUidRegex = /::\\d+$/;\n  var eventRegistry = {}; // Events storage\n\n  var uidEvent = 1;\n  var customEvents = {\n    mouseenter: 'mouseover',\n    mouseleave: 'mouseout'\n  };\n  var nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);\n  /**\n   * Private methods\n   */\n\n  function makeEventUid(element, uid) {\n    return uid && \"\".concat(uid, \"::\").concat(uidEvent++) || element.uidEvent || uidEvent++;\n  }\n  function getElementEvents(element) {\n    var uid = makeEventUid(element);\n    element.uidEvent = uid;\n    eventRegistry[uid] = eventRegistry[uid] || {};\n    return eventRegistry[uid];\n  }\n  function bootstrapHandler(element, fn) {\n    return function handler(event) {\n      hydrateObj(event, {\n        delegateTarget: element\n      });\n      if (handler.oneOff) {\n        EventHandler.off(element, event.type, fn);\n      }\n      return fn.apply(element, [event]);\n    };\n  }\n  function bootstrapDelegationHandler(element, selector, fn) {\n    return function handler(event) {\n      var domElements = element.querySelectorAll(selector);\n      for (var target = event.target; target && target !== this; target = target.parentNode) {\n        var _iterator2 = _createForOfIteratorHelper(domElements),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var domElement = _step2.value;\n            if (domElement !== target) {\n              continue;\n            }\n            hydrateObj(event, {\n              delegateTarget: target\n            });\n            if (handler.oneOff) {\n              EventHandler.off(element, event.type, selector, fn);\n            }\n            return fn.apply(target, [event]);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    };\n  }\n  function findHandler(events, callable) {\n    var delegationSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return Object.values(events).find(function (event) {\n      return event.callable === callable && event.delegationSelector === delegationSelector;\n    });\n  }\n  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {\n    var isDelegated = typeof handler === 'string'; // todo: tooltip passes `false` instead of selector, so we need to check\n\n    var callable = isDelegated ? delegationFunction : handler || delegationFunction;\n    var typeEvent = getTypeEvent(originalTypeEvent);\n    if (!nativeEvents.has(typeEvent)) {\n      typeEvent = originalTypeEvent;\n    }\n    return [isDelegated, callable, typeEvent];\n  }\n  function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {\n    if (typeof originalTypeEvent !== 'string' || !element) {\n      return;\n    }\n    var _normalizeParameters = normalizeParameters(originalTypeEvent, handler, delegationFunction),\n      _normalizeParameters2 = _slicedToArray(_normalizeParameters, 3),\n      isDelegated = _normalizeParameters2[0],\n      callable = _normalizeParameters2[1],\n      typeEvent = _normalizeParameters2[2]; // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\n    // this prevents the handler from being dispatched the same way as mouseover or mouseout does\n\n    if (originalTypeEvent in customEvents) {\n      var wrapFunction = function wrapFunction(fn) {\n        return function (event) {\n          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\n            return fn.call(this, event);\n          }\n        };\n      };\n      callable = wrapFunction(callable);\n    }\n    var events = getElementEvents(element);\n    var handlers = events[typeEvent] || (events[typeEvent] = {});\n    var previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);\n    if (previousFunction) {\n      previousFunction.oneOff = previousFunction.oneOff && oneOff;\n      return;\n    }\n    var uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));\n    var fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);\n    fn.delegationSelector = isDelegated ? handler : null;\n    fn.callable = callable;\n    fn.oneOff = oneOff;\n    fn.uidEvent = uid;\n    handlers[uid] = fn;\n    element.addEventListener(typeEvent, fn, isDelegated);\n  }\n  function removeHandler(element, events, typeEvent, handler, delegationSelector) {\n    var fn = findHandler(events[typeEvent], handler, delegationSelector);\n    if (!fn) {\n      return;\n    }\n    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\n    delete events[typeEvent][fn.uidEvent];\n  }\n  function removeNamespacedHandlers(element, events, typeEvent, namespace) {\n    var storeElementEvent = events[typeEvent] || {};\n    for (var _i2 = 0, _Object$keys = Object.keys(storeElementEvent); _i2 < _Object$keys.length; _i2++) {\n      var handlerKey = _Object$keys[_i2];\n      if (handlerKey.includes(namespace)) {\n        var event = storeElementEvent[handlerKey];\n        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n      }\n    }\n  }\n  function getTypeEvent(event) {\n    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')\n    event = event.replace(stripNameRegex, '');\n    return customEvents[event] || event;\n  }\n  var EventHandler = {\n    on: function on(element, event, handler, delegationFunction) {\n      addHandler(element, event, handler, delegationFunction, false);\n    },\n    one: function one(element, event, handler, delegationFunction) {\n      addHandler(element, event, handler, delegationFunction, true);\n    },\n    off: function off(element, originalTypeEvent, handler, delegationFunction) {\n      if (typeof originalTypeEvent !== 'string' || !element) {\n        return;\n      }\n      var _normalizeParameters3 = normalizeParameters(originalTypeEvent, handler, delegationFunction),\n        _normalizeParameters4 = _slicedToArray(_normalizeParameters3, 3),\n        isDelegated = _normalizeParameters4[0],\n        callable = _normalizeParameters4[1],\n        typeEvent = _normalizeParameters4[2];\n      var inNamespace = typeEvent !== originalTypeEvent;\n      var events = getElementEvents(element);\n      var storeElementEvent = events[typeEvent] || {};\n      var isNamespace = originalTypeEvent.startsWith('.');\n      if (typeof callable !== 'undefined') {\n        // Simplest case: handler is passed, remove that listener ONLY.\n        if (!Object.keys(storeElementEvent).length) {\n          return;\n        }\n        removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);\n        return;\n      }\n      if (isNamespace) {\n        for (var _i3 = 0, _Object$keys2 = Object.keys(events); _i3 < _Object$keys2.length; _i3++) {\n          var elementEvent = _Object$keys2[_i3];\n          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\n        }\n      }\n      for (var _i4 = 0, _Object$keys3 = Object.keys(storeElementEvent); _i4 < _Object$keys3.length; _i4++) {\n        var keyHandlers = _Object$keys3[_i4];\n        var handlerKey = keyHandlers.replace(stripUidRegex, '');\n        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\n          var event = storeElementEvent[keyHandlers];\n          removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n        }\n      }\n    },\n    trigger: function trigger(element, event, args) {\n      if (typeof event !== 'string' || !element) {\n        return null;\n      }\n      var $ = getjQuery();\n      var typeEvent = getTypeEvent(event);\n      var inNamespace = event !== typeEvent;\n      var jQueryEvent = null;\n      var bubbles = true;\n      var nativeDispatch = true;\n      var defaultPrevented = false;\n      if (inNamespace && $) {\n        jQueryEvent = $.Event(event, args);\n        $(element).trigger(jQueryEvent);\n        bubbles = !jQueryEvent.isPropagationStopped();\n        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\n        defaultPrevented = jQueryEvent.isDefaultPrevented();\n      }\n      var evt = new Event(event, {\n        bubbles: bubbles,\n        cancelable: true\n      });\n      evt = hydrateObj(evt, args);\n      if (defaultPrevented) {\n        evt.preventDefault();\n      }\n      if (nativeDispatch) {\n        element.dispatchEvent(evt);\n      }\n      if (evt.defaultPrevented && jQueryEvent) {\n        jQueryEvent.preventDefault();\n      }\n      return evt;\n    }\n  };\n  function hydrateObj(obj, meta) {\n    var _loop2 = function _loop2() {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i5], 2),\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n      try {\n        obj[key] = value;\n      } catch (_unused) {\n        Object.defineProperty(obj, key, {\n          configurable: true,\n          get: function get() {\n            return value;\n          }\n        });\n      }\n    };\n    for (var _i5 = 0, _Object$entries = Object.entries(meta || {}); _i5 < _Object$entries.length; _i5++) {\n      _loop2();\n    }\n    return obj;\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): dom/data.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n\n  /**\n   * Constants\n   */\n  var elementMap = new Map();\n  var Data = {\n    set: function set(element, key, instance) {\n      if (!elementMap.has(element)) {\n        elementMap.set(element, new Map());\n      }\n      var instanceMap = elementMap.get(element); // make it clear we only want one instance per element\n      // can be removed later when multiple key/instances are fine to be used\n\n      if (!instanceMap.has(key) && instanceMap.size !== 0) {\n        // eslint-disable-next-line no-console\n        console.error(\"Bootstrap doesn't allow more than one instance per element. Bound instance: \".concat(Array.from(instanceMap.keys())[0], \".\"));\n        return;\n      }\n      instanceMap.set(key, instance);\n    },\n    get: function get(element, key) {\n      if (elementMap.has(element)) {\n        return elementMap.get(element).get(key) || null;\n      }\n      return null;\n    },\n    remove: function remove(element, key) {\n      if (!elementMap.has(element)) {\n        return;\n      }\n      var instanceMap = elementMap.get(element);\n      instanceMap[\"delete\"](key); // free up element references if there are no instances left for an element\n\n      if (instanceMap.size === 0) {\n        elementMap[\"delete\"](element);\n      }\n    }\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): dom/manipulator.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  function normalizeData(value) {\n    if (value === 'true') {\n      return true;\n    }\n    if (value === 'false') {\n      return false;\n    }\n    if (value === Number(value).toString()) {\n      return Number(value);\n    }\n    if (value === '' || value === 'null') {\n      return null;\n    }\n    if (typeof value !== 'string') {\n      return value;\n    }\n    try {\n      return JSON.parse(decodeURIComponent(value));\n    } catch (_unused) {\n      return value;\n    }\n  }\n  function normalizeDataKey(key) {\n    return key.replace(/[A-Z]/g, function (chr) {\n      return \"-\".concat(chr.toLowerCase());\n    });\n  }\n  var Manipulator = {\n    setDataAttribute: function setDataAttribute(element, key, value) {\n      element.setAttribute(\"data-bs-\".concat(normalizeDataKey(key)), value);\n    },\n    removeDataAttribute: function removeDataAttribute(element, key) {\n      element.removeAttribute(\"data-bs-\".concat(normalizeDataKey(key)));\n    },\n    getDataAttributes: function getDataAttributes(element) {\n      if (!element) {\n        return {};\n      }\n      var attributes = {};\n      var bsKeys = Object.keys(element.dataset).filter(function (key) {\n        return key.startsWith('bs') && !key.startsWith('bsConfig');\n      });\n      var _iterator3 = _createForOfIteratorHelper(bsKeys),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var key = _step3.value;\n          var pureKey = key.replace(/^bs/, '');\n          pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\n          attributes[pureKey] = normalizeData(element.dataset[key]);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return attributes;\n    },\n    getDataAttribute: function getDataAttribute(element, key) {\n      return normalizeData(element.getAttribute(\"data-bs-\".concat(normalizeDataKey(key))));\n    }\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): util/config.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Class definition\n   */\n  var Config = /*#__PURE__*/function () {\n    function Config() {\n      _classCallCheck(this, Config);\n    }\n    _createClass(Config, [{\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        config = this._mergeConfigObj(config);\n        config = this._configAfterMerge(config);\n        this._typeCheckConfig(config);\n        return config;\n      }\n    }, {\n      key: \"_configAfterMerge\",\n      value: function _configAfterMerge(config) {\n        return config;\n      }\n    }, {\n      key: \"_mergeConfigObj\",\n      value: function _mergeConfigObj(config, element) {\n        var jsonConfig = isElement$1(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse\n\n        return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, this.constructor.Default), _typeof(jsonConfig) === 'object' ? jsonConfig : {}), isElement$1(element) ? Manipulator.getDataAttributes(element) : {}), _typeof(config) === 'object' ? config : {});\n      }\n    }, {\n      key: \"_typeCheckConfig\",\n      value: function _typeCheckConfig(config) {\n        var configTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.constructor.DefaultType;\n        for (var _i6 = 0, _Object$keys4 = Object.keys(configTypes); _i6 < _Object$keys4.length; _i6++) {\n          var property = _Object$keys4[_i6];\n          var expectedTypes = configTypes[property];\n          var value = config[property];\n          var valueType = isElement$1(value) ? 'element' : toType(value);\n          if (!new RegExp(expectedTypes).test(valueType)) {\n            throw new TypeError(\"\".concat(this.constructor.NAME.toUpperCase(), \": Option \\\"\").concat(property, \"\\\" provided type \\\"\").concat(valueType, \"\\\" but expected type \\\"\").concat(expectedTypes, \"\\\".\"));\n          }\n        }\n      }\n    }], [{\n      key: \"Default\",\n      get:\n      // Getters\n      function get() {\n        return {};\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return {};\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        throw new Error('You have to implement the static method \"NAME\", for each component!');\n      }\n    }]);\n    return Config;\n  }();\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): base-component.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n  var VERSION = '5.2.3';\n  /**\n   * Class definition\n   */\n  var BaseComponent = /*#__PURE__*/function (_Config) {\n    _inherits(BaseComponent, _Config);\n    var _super = _createSuper(BaseComponent);\n    function BaseComponent(element, config) {\n      var _this;\n      _classCallCheck(this, BaseComponent);\n      _this = _super.call(this);\n      element = getElement(element);\n      if (!element) {\n        return _possibleConstructorReturn(_this);\n      }\n      _this._element = element;\n      _this._config = _this._getConfig(config);\n      Data.set(_this._element, _this.constructor.DATA_KEY, _assertThisInitialized(_this));\n      return _this;\n    } // Public\n    _createClass(BaseComponent, [{\n      key: \"dispose\",\n      value: function dispose() {\n        Data.remove(this._element, this.constructor.DATA_KEY);\n        EventHandler.off(this._element, this.constructor.EVENT_KEY);\n        var _iterator4 = _createForOfIteratorHelper(Object.getOwnPropertyNames(this)),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var propertyName = _step4.value;\n            this[propertyName] = null;\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    }, {\n      key: \"_queueCallback\",\n      value: function _queueCallback(callback, element) {\n        var isAnimated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        executeAfterTransition(callback, element, isAnimated);\n      }\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        config = this._mergeConfigObj(config, this._element);\n        config = this._configAfterMerge(config);\n        this._typeCheckConfig(config);\n        return config;\n      } // Static\n    }], [{\n      key: \"getInstance\",\n      value: function getInstance(element) {\n        return Data.get(getElement(element), this.DATA_KEY);\n      }\n    }, {\n      key: \"getOrCreateInstance\",\n      value: function getOrCreateInstance(element) {\n        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return this.getInstance(element) || new this(element, _typeof(config) === 'object' ? config : null);\n      }\n    }, {\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return \"bs.\".concat(this.NAME);\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return \".\".concat(this.DATA_KEY);\n      }\n    }, {\n      key: \"eventName\",\n      value: function eventName(name) {\n        return \"\".concat(name).concat(this.EVENT_KEY);\n      }\n    }]);\n    return BaseComponent;\n  }(Config);\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): util/component-functions.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  var enableDismissTrigger = function enableDismissTrigger(component) {\n    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hide';\n    var clickEvent = \"click.dismiss\".concat(component.EVENT_KEY);\n    var name = component.NAME;\n    EventHandler.on(document, clickEvent, \"[data-bs-dismiss=\\\"\".concat(name, \"\\\"]\"), function (event) {\n      if (['A', 'AREA'].includes(this.tagName)) {\n        event.preventDefault();\n      }\n      if (isDisabled(this)) {\n        return;\n      }\n      var target = getElementFromSelector(this) || this.closest(\".\".concat(name));\n      var instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method\n\n      instance[method]();\n    });\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): alert.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  var NAME$f = 'alert';\n  var DATA_KEY$a = 'bs.alert';\n  var EVENT_KEY$b = \".\".concat(DATA_KEY$a);\n  var EVENT_CLOSE = \"close\".concat(EVENT_KEY$b);\n  var EVENT_CLOSED = \"closed\".concat(EVENT_KEY$b);\n  var CLASS_NAME_FADE$5 = 'fade';\n  var CLASS_NAME_SHOW$8 = 'show';\n  /**\n   * Class definition\n   */\n  var Alert = /*#__PURE__*/function (_BaseComponent) {\n    _inherits(Alert, _BaseComponent);\n    var _super2 = _createSuper(Alert);\n    function Alert() {\n      _classCallCheck(this, Alert);\n      return _super2.apply(this, arguments);\n    }\n    _createClass(Alert, [{\n      key: \"close\",\n      value:\n      // Public\n\n      function close() {\n        var _this2 = this;\n        var closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\n        if (closeEvent.defaultPrevented) {\n          return;\n        }\n        this._element.classList.remove(CLASS_NAME_SHOW$8);\n        var isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);\n        this._queueCallback(function () {\n          return _this2._destroyElement();\n        }, this._element, isAnimated);\n      } // Private\n    }, {\n      key: \"_destroyElement\",\n      value: function _destroyElement() {\n        this._element.remove();\n        EventHandler.trigger(this._element, EVENT_CLOSED);\n        this.dispose();\n      } // Static\n    }], [{\n      key: \"NAME\",\n      get:\n      // Getters\n      function get() {\n        return NAME$f;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Alert.getOrCreateInstance(this);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config](this);\n        });\n      }\n    }]);\n    return Alert;\n  }(BaseComponent);\n  /**\n   * Data API implementation\n   */\n  enableDismissTrigger(Alert, 'close');\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Alert);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): button.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  var NAME$e = 'button';\n  var DATA_KEY$9 = 'bs.button';\n  var EVENT_KEY$a = \".\".concat(DATA_KEY$9);\n  var DATA_API_KEY$6 = '.data-api';\n  var CLASS_NAME_ACTIVE$3 = 'active';\n  var SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\"button\"]';\n  var EVENT_CLICK_DATA_API$6 = \"click\".concat(EVENT_KEY$a).concat(DATA_API_KEY$6);\n  /**\n   * Class definition\n   */\n  var Button = /*#__PURE__*/function (_BaseComponent2) {\n    _inherits(Button, _BaseComponent2);\n    var _super3 = _createSuper(Button);\n    function Button() {\n      _classCallCheck(this, Button);\n      return _super3.apply(this, arguments);\n    }\n    _createClass(Button, [{\n      key: \"toggle\",\n      value:\n      // Public\n\n      function toggle() {\n        // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\n        this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\n      } // Static\n    }], [{\n      key: \"NAME\",\n      get:\n      // Getters\n      function get() {\n        return NAME$e;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Button.getOrCreateInstance(this);\n          if (config === 'toggle') {\n            data[config]();\n          }\n        });\n      }\n    }]);\n    return Button;\n  }(BaseComponent);\n  /**\n   * Data API implementation\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, function (event) {\n    event.preventDefault();\n    var button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\n    var data = Button.getOrCreateInstance(button);\n    data.toggle();\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Button);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): dom/selector-engine.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  var SelectorEngine = {\n    find: function find(selector) {\n      var _ref7;\n      var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;\n      return (_ref7 = []).concat.apply(_ref7, _toConsumableArray(Element.prototype.querySelectorAll.call(element, selector)));\n    },\n    findOne: function findOne(selector) {\n      var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;\n      return Element.prototype.querySelector.call(element, selector);\n    },\n    children: function children(element, selector) {\n      var _ref8;\n      return (_ref8 = []).concat.apply(_ref8, _toConsumableArray(element.children)).filter(function (child) {\n        return child.matches(selector);\n      });\n    },\n    parents: function parents(element, selector) {\n      var parents = [];\n      var ancestor = element.parentNode.closest(selector);\n      while (ancestor) {\n        parents.push(ancestor);\n        ancestor = ancestor.parentNode.closest(selector);\n      }\n      return parents;\n    },\n    prev: function prev(element, selector) {\n      var previous = element.previousElementSibling;\n      while (previous) {\n        if (previous.matches(selector)) {\n          return [previous];\n        }\n        previous = previous.previousElementSibling;\n      }\n      return [];\n    },\n    // TODO: this is now unused; remove later along with prev()\n    next: function next(element, selector) {\n      var next = element.nextElementSibling;\n      while (next) {\n        if (next.matches(selector)) {\n          return [next];\n        }\n        next = next.nextElementSibling;\n      }\n      return [];\n    },\n    focusableChildren: function focusableChildren(element) {\n      var focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable=\"true\"]'].map(function (selector) {\n        return \"\".concat(selector, \":not([tabindex^=\\\"-\\\"])\");\n      }).join(',');\n      return this.find(focusables, element).filter(function (el) {\n        return !isDisabled(el) && isVisible(el);\n      });\n    }\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): util/swipe.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  var NAME$d = 'swipe';\n  var EVENT_KEY$9 = '.bs.swipe';\n  var EVENT_TOUCHSTART = \"touchstart\".concat(EVENT_KEY$9);\n  var EVENT_TOUCHMOVE = \"touchmove\".concat(EVENT_KEY$9);\n  var EVENT_TOUCHEND = \"touchend\".concat(EVENT_KEY$9);\n  var EVENT_POINTERDOWN = \"pointerdown\".concat(EVENT_KEY$9);\n  var EVENT_POINTERUP = \"pointerup\".concat(EVENT_KEY$9);\n  var POINTER_TYPE_TOUCH = 'touch';\n  var POINTER_TYPE_PEN = 'pen';\n  var CLASS_NAME_POINTER_EVENT = 'pointer-event';\n  var SWIPE_THRESHOLD = 40;\n  var Default$c = {\n    endCallback: null,\n    leftCallback: null,\n    rightCallback: null\n  };\n  var DefaultType$c = {\n    endCallback: '(function|null)',\n    leftCallback: '(function|null)',\n    rightCallback: '(function|null)'\n  };\n  /**\n   * Class definition\n   */\n  var Swipe = /*#__PURE__*/function (_Config2) {\n    _inherits(Swipe, _Config2);\n    var _super4 = _createSuper(Swipe);\n    function Swipe(element, config) {\n      var _this3;\n      _classCallCheck(this, Swipe);\n      _this3 = _super4.call(this);\n      _this3._element = element;\n      if (!element || !Swipe.isSupported()) {\n        return _possibleConstructorReturn(_this3);\n      }\n      _this3._config = _this3._getConfig(config);\n      _this3._deltaX = 0;\n      _this3._supportPointerEvents = Boolean(window.PointerEvent);\n      _this3._initEvents();\n      return _this3;\n    } // Getters\n    _createClass(Swipe, [{\n      key: \"dispose\",\n      value:\n      // Public\n\n      function dispose() {\n        EventHandler.off(this._element, EVENT_KEY$9);\n      } // Private\n    }, {\n      key: \"_start\",\n      value: function _start(event) {\n        if (!this._supportPointerEvents) {\n          this._deltaX = event.touches[0].clientX;\n          return;\n        }\n        if (this._eventIsPointerPenTouch(event)) {\n          this._deltaX = event.clientX;\n        }\n      }\n    }, {\n      key: \"_end\",\n      value: function _end(event) {\n        if (this._eventIsPointerPenTouch(event)) {\n          this._deltaX = event.clientX - this._deltaX;\n        }\n        this._handleSwipe();\n        execute(this._config.endCallback);\n      }\n    }, {\n      key: \"_move\",\n      value: function _move(event) {\n        this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;\n      }\n    }, {\n      key: \"_handleSwipe\",\n      value: function _handleSwipe() {\n        var absDeltaX = Math.abs(this._deltaX);\n        if (absDeltaX <= SWIPE_THRESHOLD) {\n          return;\n        }\n        var direction = absDeltaX / this._deltaX;\n        this._deltaX = 0;\n        if (!direction) {\n          return;\n        }\n        execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);\n      }\n    }, {\n      key: \"_initEvents\",\n      value: function _initEvents() {\n        var _this4 = this;\n        if (this._supportPointerEvents) {\n          EventHandler.on(this._element, EVENT_POINTERDOWN, function (event) {\n            return _this4._start(event);\n          });\n          EventHandler.on(this._element, EVENT_POINTERUP, function (event) {\n            return _this4._end(event);\n          });\n          this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n        } else {\n          EventHandler.on(this._element, EVENT_TOUCHSTART, function (event) {\n            return _this4._start(event);\n          });\n          EventHandler.on(this._element, EVENT_TOUCHMOVE, function (event) {\n            return _this4._move(event);\n          });\n          EventHandler.on(this._element, EVENT_TOUCHEND, function (event) {\n            return _this4._end(event);\n          });\n        }\n      }\n    }, {\n      key: \"_eventIsPointerPenTouch\",\n      value: function _eventIsPointerPenTouch(event) {\n        return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$c;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$c;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$d;\n      }\n    }, {\n      key: \"isSupported\",\n      value: function isSupported() {\n        return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\n      }\n    }]);\n    return Swipe;\n  }(Config);\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): carousel.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n  var NAME$c = 'carousel';\n  var DATA_KEY$8 = 'bs.carousel';\n  var EVENT_KEY$8 = \".\".concat(DATA_KEY$8);\n  var DATA_API_KEY$5 = '.data-api';\n  var ARROW_LEFT_KEY$1 = 'ArrowLeft';\n  var ARROW_RIGHT_KEY$1 = 'ArrowRight';\n  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\n  var ORDER_NEXT = 'next';\n  var ORDER_PREV = 'prev';\n  var DIRECTION_LEFT = 'left';\n  var DIRECTION_RIGHT = 'right';\n  var EVENT_SLIDE = \"slide\".concat(EVENT_KEY$8);\n  var EVENT_SLID = \"slid\".concat(EVENT_KEY$8);\n  var EVENT_KEYDOWN$1 = \"keydown\".concat(EVENT_KEY$8);\n  var EVENT_MOUSEENTER$1 = \"mouseenter\".concat(EVENT_KEY$8);\n  var EVENT_MOUSELEAVE$1 = \"mouseleave\".concat(EVENT_KEY$8);\n  var EVENT_DRAG_START = \"dragstart\".concat(EVENT_KEY$8);\n  var EVENT_LOAD_DATA_API$3 = \"load\".concat(EVENT_KEY$8).concat(DATA_API_KEY$5);\n  var EVENT_CLICK_DATA_API$5 = \"click\".concat(EVENT_KEY$8).concat(DATA_API_KEY$5);\n  var CLASS_NAME_CAROUSEL = 'carousel';\n  var CLASS_NAME_ACTIVE$2 = 'active';\n  var CLASS_NAME_SLIDE = 'slide';\n  var CLASS_NAME_END = 'carousel-item-end';\n  var CLASS_NAME_START = 'carousel-item-start';\n  var CLASS_NAME_NEXT = 'carousel-item-next';\n  var CLASS_NAME_PREV = 'carousel-item-prev';\n  var SELECTOR_ACTIVE = '.active';\n  var SELECTOR_ITEM = '.carousel-item';\n  var SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;\n  var SELECTOR_ITEM_IMG = '.carousel-item img';\n  var SELECTOR_INDICATORS = '.carousel-indicators';\n  var SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';\n  var SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\n  var KEY_TO_DIRECTION = (_KEY_TO_DIRECTION = {}, _defineProperty(_KEY_TO_DIRECTION, ARROW_LEFT_KEY$1, DIRECTION_RIGHT), _defineProperty(_KEY_TO_DIRECTION, ARROW_RIGHT_KEY$1, DIRECTION_LEFT), _KEY_TO_DIRECTION);\n  var Default$b = {\n    interval: 5000,\n    keyboard: true,\n    pause: 'hover',\n    ride: false,\n    touch: true,\n    wrap: true\n  };\n  var DefaultType$b = {\n    interval: '(number|boolean)',\n    // TODO:v6 remove boolean support\n    keyboard: 'boolean',\n    pause: '(string|boolean)',\n    ride: '(boolean|string)',\n    touch: 'boolean',\n    wrap: 'boolean'\n  };\n  /**\n   * Class definition\n   */\n  var Carousel = /*#__PURE__*/function (_BaseComponent3) {\n    _inherits(Carousel, _BaseComponent3);\n    var _super5 = _createSuper(Carousel);\n    function Carousel(element, config) {\n      var _this5;\n      _classCallCheck(this, Carousel);\n      _this5 = _super5.call(this, element, config);\n      _this5._interval = null;\n      _this5._activeElement = null;\n      _this5._isSliding = false;\n      _this5.touchTimeout = null;\n      _this5._swipeHelper = null;\n      _this5._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, _this5._element);\n      _this5._addEventListeners();\n      if (_this5._config.ride === CLASS_NAME_CAROUSEL) {\n        _this5.cycle();\n      }\n      return _this5;\n    } // Getters\n    _createClass(Carousel, [{\n      key: \"next\",\n      value:\n      // Public\n\n      function next() {\n        this._slide(ORDER_NEXT);\n      }\n    }, {\n      key: \"nextWhenVisible\",\n      value: function nextWhenVisible() {\n        // FIXME TODO use `document.visibilityState`\n        // Don't call next when the page isn't visible\n        // or the carousel or its parent isn't visible\n        if (!document.hidden && isVisible(this._element)) {\n          this.next();\n        }\n      }\n    }, {\n      key: \"prev\",\n      value: function prev() {\n        this._slide(ORDER_PREV);\n      }\n    }, {\n      key: \"pause\",\n      value: function pause() {\n        if (this._isSliding) {\n          triggerTransitionEnd(this._element);\n        }\n        this._clearInterval();\n      }\n    }, {\n      key: \"cycle\",\n      value: function cycle() {\n        var _this6 = this;\n        this._clearInterval();\n        this._updateInterval();\n        this._interval = setInterval(function () {\n          return _this6.nextWhenVisible();\n        }, this._config.interval);\n      }\n    }, {\n      key: \"_maybeEnableCycle\",\n      value: function _maybeEnableCycle() {\n        var _this7 = this;\n        if (!this._config.ride) {\n          return;\n        }\n        if (this._isSliding) {\n          EventHandler.one(this._element, EVENT_SLID, function () {\n            return _this7.cycle();\n          });\n          return;\n        }\n        this.cycle();\n      }\n    }, {\n      key: \"to\",\n      value: function to(index) {\n        var _this8 = this;\n        var items = this._getItems();\n        if (index > items.length - 1 || index < 0) {\n          return;\n        }\n        if (this._isSliding) {\n          EventHandler.one(this._element, EVENT_SLID, function () {\n            return _this8.to(index);\n          });\n          return;\n        }\n        var activeIndex = this._getItemIndex(this._getActive());\n        if (activeIndex === index) {\n          return;\n        }\n        var order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n        this._slide(order, items[index]);\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        if (this._swipeHelper) {\n          this._swipeHelper.dispose();\n        }\n        _get(_getPrototypeOf(Carousel.prototype), \"dispose\", this).call(this);\n      } // Private\n    }, {\n      key: \"_configAfterMerge\",\n      value: function _configAfterMerge(config) {\n        config.defaultInterval = config.interval;\n        return config;\n      }\n    }, {\n      key: \"_addEventListeners\",\n      value: function _addEventListeners() {\n        var _this9 = this;\n        if (this._config.keyboard) {\n          EventHandler.on(this._element, EVENT_KEYDOWN$1, function (event) {\n            return _this9._keydown(event);\n          });\n        }\n        if (this._config.pause === 'hover') {\n          EventHandler.on(this._element, EVENT_MOUSEENTER$1, function () {\n            return _this9.pause();\n          });\n          EventHandler.on(this._element, EVENT_MOUSELEAVE$1, function () {\n            return _this9._maybeEnableCycle();\n          });\n        }\n        if (this._config.touch && Swipe.isSupported()) {\n          this._addTouchEventListeners();\n        }\n      }\n    }, {\n      key: \"_addTouchEventListeners\",\n      value: function _addTouchEventListeners() {\n        var _this10 = this;\n        var _iterator5 = _createForOfIteratorHelper(SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var img = _step5.value;\n            EventHandler.on(img, EVENT_DRAG_START, function (event) {\n              return event.preventDefault();\n            });\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        var endCallBack = function endCallBack() {\n          if (_this10._config.pause !== 'hover') {\n            return;\n          } // If it's a touch-enabled device, mouseenter/leave are fired as\n          // part of the mouse compatibility events on first tap - the carousel\n          // would stop cycling until user tapped out of it;\n          // here, we listen for touchend, explicitly pause the carousel\n          // (as if it's the second time we tap on it, mouseenter compat event\n          // is NOT fired) and after a timeout (to allow for mouse compatibility\n          // events to fire) we explicitly restart cycling\n\n          _this10.pause();\n          if (_this10.touchTimeout) {\n            clearTimeout(_this10.touchTimeout);\n          }\n          _this10.touchTimeout = setTimeout(function () {\n            return _this10._maybeEnableCycle();\n          }, TOUCHEVENT_COMPAT_WAIT + _this10._config.interval);\n        };\n        var swipeConfig = {\n          leftCallback: function leftCallback() {\n            return _this10._slide(_this10._directionToOrder(DIRECTION_LEFT));\n          },\n          rightCallback: function rightCallback() {\n            return _this10._slide(_this10._directionToOrder(DIRECTION_RIGHT));\n          },\n          endCallback: endCallBack\n        };\n        this._swipeHelper = new Swipe(this._element, swipeConfig);\n      }\n    }, {\n      key: \"_keydown\",\n      value: function _keydown(event) {\n        if (/input|textarea/i.test(event.target.tagName)) {\n          return;\n        }\n        var direction = KEY_TO_DIRECTION[event.key];\n        if (direction) {\n          event.preventDefault();\n          this._slide(this._directionToOrder(direction));\n        }\n      }\n    }, {\n      key: \"_getItemIndex\",\n      value: function _getItemIndex(element) {\n        return this._getItems().indexOf(element);\n      }\n    }, {\n      key: \"_setActiveIndicatorElement\",\n      value: function _setActiveIndicatorElement(index) {\n        if (!this._indicatorsElement) {\n          return;\n        }\n        var activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);\n        activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\n        activeIndicator.removeAttribute('aria-current');\n        var newActiveIndicator = SelectorEngine.findOne(\"[data-bs-slide-to=\\\"\".concat(index, \"\\\"]\"), this._indicatorsElement);\n        if (newActiveIndicator) {\n          newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);\n          newActiveIndicator.setAttribute('aria-current', 'true');\n        }\n      }\n    }, {\n      key: \"_updateInterval\",\n      value: function _updateInterval() {\n        var element = this._activeElement || this._getActive();\n        if (!element) {\n          return;\n        }\n        var elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);\n        this._config.interval = elementInterval || this._config.defaultInterval;\n      }\n    }, {\n      key: \"_slide\",\n      value: function _slide(order) {\n        var _this11 = this;\n        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        if (this._isSliding) {\n          return;\n        }\n        var activeElement = this._getActive();\n        var isNext = order === ORDER_NEXT;\n        var nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);\n        if (nextElement === activeElement) {\n          return;\n        }\n        var nextElementIndex = this._getItemIndex(nextElement);\n        var triggerEvent = function triggerEvent(eventName) {\n          return EventHandler.trigger(_this11._element, eventName, {\n            relatedTarget: nextElement,\n            direction: _this11._orderToDirection(order),\n            from: _this11._getItemIndex(activeElement),\n            to: nextElementIndex\n          });\n        };\n        var slideEvent = triggerEvent(EVENT_SLIDE);\n        if (slideEvent.defaultPrevented) {\n          return;\n        }\n        if (!activeElement || !nextElement) {\n          // Some weirdness is happening, so we bail\n          // todo: change tests that use empty divs to avoid this check\n          return;\n        }\n        var isCycling = Boolean(this._interval);\n        this.pause();\n        this._isSliding = true;\n        this._setActiveIndicatorElement(nextElementIndex);\n        this._activeElement = nextElement;\n        var directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n        var orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n        nextElement.classList.add(orderClassName);\n        reflow(nextElement);\n        activeElement.classList.add(directionalClassName);\n        nextElement.classList.add(directionalClassName);\n        var completeCallBack = function completeCallBack() {\n          nextElement.classList.remove(directionalClassName, orderClassName);\n          nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n          activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\n          _this11._isSliding = false;\n          triggerEvent(EVENT_SLID);\n        };\n        this._queueCallback(completeCallBack, activeElement, this._isAnimated());\n        if (isCycling) {\n          this.cycle();\n        }\n      }\n    }, {\n      key: \"_isAnimated\",\n      value: function _isAnimated() {\n        return this._element.classList.contains(CLASS_NAME_SLIDE);\n      }\n    }, {\n      key: \"_getActive\",\n      value: function _getActive() {\n        return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n      }\n    }, {\n      key: \"_getItems\",\n      value: function _getItems() {\n        return SelectorEngine.find(SELECTOR_ITEM, this._element);\n      }\n    }, {\n      key: \"_clearInterval\",\n      value: function _clearInterval() {\n        if (this._interval) {\n          clearInterval(this._interval);\n          this._interval = null;\n        }\n      }\n    }, {\n      key: \"_directionToOrder\",\n      value: function _directionToOrder(direction) {\n        if (isRTL()) {\n          return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n        }\n        return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n      }\n    }, {\n      key: \"_orderToDirection\",\n      value: function _orderToDirection(order) {\n        if (isRTL()) {\n          return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        }\n        return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$b;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$b;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$c;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Carousel.getOrCreateInstance(this, config);\n          if (typeof config === 'number') {\n            data.to(config);\n            return;\n          }\n          if (typeof config === 'string') {\n            if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n              throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n            }\n            data[config]();\n          }\n        });\n      }\n    }]);\n    return Carousel;\n  }(BaseComponent);\n  /**\n   * Data API implementation\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {\n    var target = getElementFromSelector(this);\n    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n      return;\n    }\n    event.preventDefault();\n    var carousel = Carousel.getOrCreateInstance(target);\n    var slideIndex = this.getAttribute('data-bs-slide-to');\n    if (slideIndex) {\n      carousel.to(slideIndex);\n      carousel._maybeEnableCycle();\n      return;\n    }\n    if (Manipulator.getDataAttribute(this, 'slide') === 'next') {\n      carousel.next();\n      carousel._maybeEnableCycle();\n      return;\n    }\n    carousel.prev();\n    carousel._maybeEnableCycle();\n  });\n  EventHandler.on(window, EVENT_LOAD_DATA_API$3, function () {\n    var carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\n    var _iterator6 = _createForOfIteratorHelper(carousels),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var carousel = _step6.value;\n        Carousel.getOrCreateInstance(carousel);\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Carousel);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): collapse.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  var NAME$b = 'collapse';\n  var DATA_KEY$7 = 'bs.collapse';\n  var EVENT_KEY$7 = \".\".concat(DATA_KEY$7);\n  var DATA_API_KEY$4 = '.data-api';\n  var EVENT_SHOW$6 = \"show\".concat(EVENT_KEY$7);\n  var EVENT_SHOWN$6 = \"shown\".concat(EVENT_KEY$7);\n  var EVENT_HIDE$6 = \"hide\".concat(EVENT_KEY$7);\n  var EVENT_HIDDEN$6 = \"hidden\".concat(EVENT_KEY$7);\n  var EVENT_CLICK_DATA_API$4 = \"click\".concat(EVENT_KEY$7).concat(DATA_API_KEY$4);\n  var CLASS_NAME_SHOW$7 = 'show';\n  var CLASS_NAME_COLLAPSE = 'collapse';\n  var CLASS_NAME_COLLAPSING = 'collapsing';\n  var CLASS_NAME_COLLAPSED = 'collapsed';\n  var CLASS_NAME_DEEPER_CHILDREN = \":scope .\".concat(CLASS_NAME_COLLAPSE, \" .\").concat(CLASS_NAME_COLLAPSE);\n  var CLASS_NAME_HORIZONTAL = 'collapse-horizontal';\n  var WIDTH = 'width';\n  var HEIGHT = 'height';\n  var SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';\n  var SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\"collapse\"]';\n  var Default$a = {\n    parent: null,\n    toggle: true\n  };\n  var DefaultType$a = {\n    parent: '(null|element)',\n    toggle: 'boolean'\n  };\n  /**\n   * Class definition\n   */\n  var Collapse = /*#__PURE__*/function (_BaseComponent4) {\n    _inherits(Collapse, _BaseComponent4);\n    var _super6 = _createSuper(Collapse);\n    function Collapse(element, config) {\n      var _this12;\n      _classCallCheck(this, Collapse);\n      _this12 = _super6.call(this, element, config);\n      _this12._isTransitioning = false;\n      _this12._triggerArray = [];\n      var toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\n      var _iterator7 = _createForOfIteratorHelper(toggleList),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var elem = _step7.value;\n          var selector = getSelectorFromElement(elem);\n          var filterElement = SelectorEngine.find(selector).filter(function (foundElement) {\n            return foundElement === _this12._element;\n          });\n          if (selector !== null && filterElement.length) {\n            _this12._triggerArray.push(elem);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      _this12._initializeChildren();\n      if (!_this12._config.parent) {\n        _this12._addAriaAndCollapsedClass(_this12._triggerArray, _this12._isShown());\n      }\n      if (_this12._config.toggle) {\n        _this12.toggle();\n      }\n      return _this12;\n    } // Getters\n    _createClass(Collapse, [{\n      key: \"toggle\",\n      value:\n      // Public\n\n      function toggle() {\n        if (this._isShown()) {\n          this.hide();\n        } else {\n          this.show();\n        }\n      }\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this13 = this;\n        if (this._isTransitioning || this._isShown()) {\n          return;\n        }\n        var activeChildren = []; // find active children\n\n        if (this._config.parent) {\n          activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(function (element) {\n            return element !== _this13._element;\n          }).map(function (element) {\n            return Collapse.getOrCreateInstance(element, {\n              toggle: false\n            });\n          });\n        }\n        if (activeChildren.length && activeChildren[0]._isTransitioning) {\n          return;\n        }\n        var startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);\n        if (startEvent.defaultPrevented) {\n          return;\n        }\n        var _iterator8 = _createForOfIteratorHelper(activeChildren),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var activeInstance = _step8.value;\n            activeInstance.hide();\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n        var dimension = this._getDimension();\n        this._element.classList.remove(CLASS_NAME_COLLAPSE);\n        this._element.classList.add(CLASS_NAME_COLLAPSING);\n        this._element.style[dimension] = 0;\n        this._addAriaAndCollapsedClass(this._triggerArray, true);\n        this._isTransitioning = true;\n        var complete = function complete() {\n          _this13._isTransitioning = false;\n          _this13._element.classList.remove(CLASS_NAME_COLLAPSING);\n          _this13._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n          _this13._element.style[dimension] = '';\n          EventHandler.trigger(_this13._element, EVENT_SHOWN$6);\n        };\n        var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n        var scrollSize = \"scroll\".concat(capitalizedDimension);\n        this._queueCallback(complete, this._element, true);\n        this._element.style[dimension] = \"\".concat(this._element[scrollSize], \"px\");\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var _this14 = this;\n        if (this._isTransitioning || !this._isShown()) {\n          return;\n        }\n        var startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);\n        if (startEvent.defaultPrevented) {\n          return;\n        }\n        var dimension = this._getDimension();\n        this._element.style[dimension] = \"\".concat(this._element.getBoundingClientRect()[dimension], \"px\");\n        reflow(this._element);\n        this._element.classList.add(CLASS_NAME_COLLAPSING);\n        this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n        var _iterator9 = _createForOfIteratorHelper(this._triggerArray),\n          _step9;\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var trigger = _step9.value;\n            var element = getElementFromSelector(trigger);\n            if (element && !this._isShown(element)) {\n              this._addAriaAndCollapsedClass([trigger], false);\n            }\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n        this._isTransitioning = true;\n        var complete = function complete() {\n          _this14._isTransitioning = false;\n          _this14._element.classList.remove(CLASS_NAME_COLLAPSING);\n          _this14._element.classList.add(CLASS_NAME_COLLAPSE);\n          EventHandler.trigger(_this14._element, EVENT_HIDDEN$6);\n        };\n        this._element.style[dimension] = '';\n        this._queueCallback(complete, this._element, true);\n      }\n    }, {\n      key: \"_isShown\",\n      value: function _isShown() {\n        var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._element;\n        return element.classList.contains(CLASS_NAME_SHOW$7);\n      } // Private\n    }, {\n      key: \"_configAfterMerge\",\n      value: function _configAfterMerge(config) {\n        config.toggle = Boolean(config.toggle); // Coerce string values\n\n        config.parent = getElement(config.parent);\n        return config;\n      }\n    }, {\n      key: \"_getDimension\",\n      value: function _getDimension() {\n        return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;\n      }\n    }, {\n      key: \"_initializeChildren\",\n      value: function _initializeChildren() {\n        if (!this._config.parent) {\n          return;\n        }\n        var children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);\n        var _iterator10 = _createForOfIteratorHelper(children),\n          _step10;\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var element = _step10.value;\n            var selected = getElementFromSelector(element);\n            if (selected) {\n              this._addAriaAndCollapsedClass([element], this._isShown(selected));\n            }\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n    }, {\n      key: \"_getFirstLevelChildren\",\n      value: function _getFirstLevelChildren(selector) {\n        var children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent); // remove children if greater depth\n\n        return SelectorEngine.find(selector, this._config.parent).filter(function (element) {\n          return !children.includes(element);\n        });\n      }\n    }, {\n      key: \"_addAriaAndCollapsedClass\",\n      value: function _addAriaAndCollapsedClass(triggerArray, isOpen) {\n        if (!triggerArray.length) {\n          return;\n        }\n        var _iterator11 = _createForOfIteratorHelper(triggerArray),\n          _step11;\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var element = _step11.value;\n            element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);\n            element.setAttribute('aria-expanded', isOpen);\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$a;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$a;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$b;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        var _config = {};\n        if (typeof config === 'string' && /show|hide/.test(config)) {\n          _config.toggle = false;\n        }\n        return this.each(function () {\n          var data = Collapse.getOrCreateInstance(this, _config);\n          if (typeof config === 'string') {\n            if (typeof data[config] === 'undefined') {\n              throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n            }\n            data[config]();\n          }\n        });\n      }\n    }]);\n    return Collapse;\n  }(BaseComponent);\n  /**\n   * Data API implementation\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {\n    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n    if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {\n      event.preventDefault();\n    }\n    var selector = getSelectorFromElement(this);\n    var selectorElements = SelectorEngine.find(selector);\n    var _iterator12 = _createForOfIteratorHelper(selectorElements),\n      _step12;\n    try {\n      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n        var element = _step12.value;\n        Collapse.getOrCreateInstance(element, {\n          toggle: false\n        }).toggle();\n      }\n    } catch (err) {\n      _iterator12.e(err);\n    } finally {\n      _iterator12.f();\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Collapse);\n  var top = 'top';\n  var bottom = 'bottom';\n  var right = 'right';\n  var left = 'left';\n  var auto = 'auto';\n  var basePlacements = [top, bottom, right, left];\n  var start = 'start';\n  var end = 'end';\n  var clippingParents = 'clippingParents';\n  var viewport = 'viewport';\n  var popper = 'popper';\n  var reference = 'reference';\n  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n    return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n  }, []);\n  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n    return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n  }, []); // modifiers that need to read the DOM\n\n  var beforeRead = 'beforeRead';\n  var read = 'read';\n  var afterRead = 'afterRead'; // pure-logic modifiers\n\n  var beforeMain = 'beforeMain';\n  var main = 'main';\n  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\n  var beforeWrite = 'beforeWrite';\n  var write = 'write';\n  var afterWrite = 'afterWrite';\n  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n  function getNodeName(element) {\n    return element ? (element.nodeName || '').toLowerCase() : null;\n  }\n  function getWindow(node) {\n    if (node == null) {\n      return window;\n    }\n    if (node.toString() !== '[object Window]') {\n      var ownerDocument = node.ownerDocument;\n      return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n    return node;\n  }\n  function isElement(node) {\n    var OwnElement = getWindow(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n  }\n  function isHTMLElement(node) {\n    var OwnElement = getWindow(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n  }\n  function isShadowRoot(node) {\n    // IE 11 has no ShadowRoot\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n  }\n\n  // and applies them to the HTMLElements such as popper and arrow\n\n  function applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function (name) {\n      var style = state.styles[name] || {};\n      var attributes = state.attributes[name] || {};\n      var element = state.elements[name]; // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      } // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe[cannot-write]\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (name) {\n        var value = attributes[name];\n        if (value === false) {\n          element.removeAttribute(name);\n        } else {\n          element.setAttribute(name, value === true ? '' : value);\n        }\n      });\n    });\n  }\n  function effect$2(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: '0',\n        top: '0',\n        margin: '0'\n      },\n      arrow: {\n        position: 'absolute'\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n    return function () {\n      Object.keys(state.elements).forEach(function (name) {\n        var element = state.elements[name];\n        var attributes = state.attributes[name] || {};\n        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n        var style = styleProperties.reduce(function (style, property) {\n          style[property] = '';\n          return style;\n        }, {}); // arrow is optional + virtual elements\n\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n          return;\n        }\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function (attribute) {\n          element.removeAttribute(attribute);\n        });\n      });\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var applyStyles$1 = {\n    name: 'applyStyles',\n    enabled: true,\n    phase: 'write',\n    fn: applyStyles,\n    effect: effect$2,\n    requires: ['computeStyles']\n  };\n  function getBasePlacement(placement) {\n    return placement.split('-')[0];\n  }\n  var max = Math.max;\n  var min = Math.min;\n  var round = Math.round;\n  function getUAString() {\n    var uaData = navigator.userAgentData;\n    if (uaData != null && uaData.brands) {\n      return uaData.brands.map(function (item) {\n        return item.brand + \"/\" + item.version;\n      }).join(' ');\n    }\n    return navigator.userAgent;\n  }\n  function isLayoutViewport() {\n    return !/^((?!chrome|android).)*safari/i.test(getUAString());\n  }\n  function getBoundingClientRect(element, includeScale, isFixedStrategy) {\n    if (includeScale === void 0) {\n      includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n      isFixedStrategy = false;\n    }\n    var clientRect = element.getBoundingClientRect();\n    var scaleX = 1;\n    var scaleY = 1;\n    if (includeScale && isHTMLElement(element)) {\n      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n    }\n    var _ref = isElement(element) ? getWindow(element) : window,\n      visualViewport = _ref.visualViewport;\n    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n    var width = clientRect.width / scaleX;\n    var height = clientRect.height / scaleY;\n    return {\n      width: width,\n      height: height,\n      top: y,\n      right: x + width,\n      bottom: y + height,\n      left: x,\n      x: x,\n      y: y\n    };\n  }\n\n  // means it doesn't take into account transforms.\n\n  function getLayoutRect(element) {\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n    if (Math.abs(clientRect.width - width) <= 1) {\n      width = clientRect.width;\n    }\n    if (Math.abs(clientRect.height - height) <= 1) {\n      height = clientRect.height;\n    }\n    return {\n      x: element.offsetLeft,\n      y: element.offsetTop,\n      width: width,\n      height: height\n    };\n  }\n  function contains(parent, child) {\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n    if (parent.contains(child)) {\n      return true;\n    } // then fallback to custom implementation with Shadow DOM support\n    else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n    return false;\n  }\n  function getComputedStyle$1(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n  }\n  function getDocumentElement(element) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return ((isElement(element) ? element.ownerDocument :\n    // $FlowFixMe[prop-missing]\n    element.document) || window.document).documentElement;\n  }\n  function getParentNode(element) {\n    if (getNodeName(element) === 'html') {\n      return element;\n    }\n    return (\n      // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n      // $FlowFixMe[incompatible-return]\n      // $FlowFixMe[prop-missing]\n      element.assignedSlot ||\n      // step into the shadow DOM of the parent of a slotted node\n      element.parentNode || (\n      // DOM Element detected\n      isShadowRoot(element) ? element.host : null) ||\n      // ShadowRoot detected\n      // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n      getDocumentElement(element) // fallback\n    );\n  }\n\n  function getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) ||\n    // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle$1(element).position === 'fixed') {\n      return null;\n    }\n    return element.offsetParent;\n  } // `.offsetParent` reports `null` for fixed elements, while absolute elements\n  // return the containing block\n\n  function getContainingBlock(element) {\n    var isFirefox = /firefox/i.test(getUAString());\n    var isIE = /Trident/i.test(getUAString());\n    if (isIE && isHTMLElement(element)) {\n      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n      var elementCss = getComputedStyle$1(element);\n      if (elementCss.position === 'fixed') {\n        return null;\n      }\n    }\n    var currentNode = getParentNode(element);\n    if (isShadowRoot(currentNode)) {\n      currentNode = currentNode.host;\n    }\n    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n      var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n      // create a containing block.\n      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n        return currentNode;\n      } else {\n        currentNode = currentNode.parentNode;\n      }\n    }\n    return null;\n  } // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n\n  function getOffsetParent(element) {\n    var window = getWindow(element);\n    var offsetParent = getTrueOffsetParent(element);\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {\n      return window;\n    }\n    return offsetParent || getContainingBlock(element) || window;\n  }\n  function getMainAxisFromPlacement(placement) {\n    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n  }\n  function within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n  }\n  function withinMaxClamp(min, value, max) {\n    var v = within(min, value, max);\n    return v > max ? max : v;\n  }\n  function getFreshSideObject() {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n  function mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), paddingObject);\n  }\n  function expandToHashMap(value, keys) {\n    return keys.reduce(function (hashMap, key) {\n      hashMap[key] = value;\n      return hashMap;\n    }, {});\n  }\n  var toPaddingObject = function toPaddingObject(padding, state) {\n    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : padding;\n    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  };\n  function arrow(_ref) {\n    var _state$modifiersData$;\n    var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [left, right].indexOf(basePlacement) >= 0;\n    var len = isVertical ? 'height' : 'width';\n    if (!arrowElement || !popperOffsets) {\n      return;\n    }\n    var paddingObject = toPaddingObject(options.padding, state);\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === 'y' ? top : left;\n    var maxProp = axis === 'y' ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = getOffsetParent(arrowElement);\n    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n\n    var min = paddingObject[minProp];\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n    var axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n  }\n  function effect$1(_ref2) {\n    var state = _ref2.state,\n      options = _ref2.options;\n    var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n    if (arrowElement == null) {\n      return;\n    } // CSS selector\n\n    if (typeof arrowElement === 'string') {\n      arrowElement = state.elements.popper.querySelector(arrowElement);\n      if (!arrowElement) {\n        return;\n      }\n    }\n    if (!contains(state.elements.popper, arrowElement)) {\n      return;\n    }\n    state.elements.arrow = arrowElement;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var arrow$1 = {\n    name: 'arrow',\n    enabled: true,\n    phase: 'main',\n    fn: arrow,\n    effect: effect$1,\n    requires: ['popperOffsets'],\n    requiresIfExists: ['preventOverflow']\n  };\n  function getVariation(placement) {\n    return placement.split('-')[1];\n  }\n  var unsetSides = {\n    top: 'auto',\n    right: 'auto',\n    bottom: 'auto',\n    left: 'auto'\n  }; // Round the offsets to the nearest suitable subpixel based on the DPR.\n  // Zooming can change the DPR, but it seems to report a value that will\n  // cleanly divide the values into the appropriate subpixels.\n\n  function roundOffsetsByDPR(_ref) {\n    var x = _ref.x,\n      y = _ref.y;\n    var win = window;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n      x: round(x * dpr) / dpr || 0,\n      y: round(y * dpr) / dpr || 0\n    };\n  }\n  function mapToStyles(_ref2) {\n    var _Object$assign2;\n    var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n    var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n      x: x,\n      y: y\n    }) : {\n      x: x,\n      y: y\n    };\n    x = _ref3.x;\n    y = _ref3.y;\n    var hasX = offsets.hasOwnProperty('x');\n    var hasY = offsets.hasOwnProperty('y');\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n    if (adaptive) {\n      var offsetParent = getOffsetParent(popper);\n      var heightProp = 'clientHeight';\n      var widthProp = 'clientWidth';\n      if (offsetParent === getWindow(popper)) {\n        offsetParent = getDocumentElement(popper);\n        if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {\n          heightProp = 'scrollHeight';\n          widthProp = 'scrollWidth';\n        }\n      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n      offsetParent = offsetParent;\n      if (placement === top || (placement === left || placement === right) && variation === end) {\n        sideY = bottom;\n        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :\n        // $FlowFixMe[prop-missing]\n        offsetParent[heightProp];\n        y -= offsetY - popperRect.height;\n        y *= gpuAcceleration ? 1 : -1;\n      }\n      if (placement === left || (placement === top || placement === bottom) && variation === end) {\n        sideX = right;\n        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :\n        // $FlowFixMe[prop-missing]\n        offsetParent[widthProp];\n        x -= offsetX - popperRect.width;\n        x *= gpuAcceleration ? 1 : -1;\n      }\n    }\n    var commonStyles = Object.assign({\n      position: position\n    }, adaptive && unsetSides);\n    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n      x: x,\n      y: y\n    }) : {\n      x: x,\n      y: y\n    };\n    x = _ref4.x;\n    y = _ref4.y;\n    if (gpuAcceleration) {\n      var _Object$assign;\n      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n  }\n  function computeStyles(_ref5) {\n    var state = _ref5.state,\n      options = _ref5.options;\n    var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n    var commonStyles = {\n      placement: getBasePlacement(state.placement),\n      variation: getVariation(state.placement),\n      popper: state.elements.popper,\n      popperRect: state.rects.popper,\n      gpuAcceleration: gpuAcceleration,\n      isFixed: state.options.strategy === 'fixed'\n    };\n    if (state.modifiersData.popperOffsets != null) {\n      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.popperOffsets,\n        position: state.options.strategy,\n        adaptive: adaptive,\n        roundOffsets: roundOffsets\n      })));\n    }\n    if (state.modifiersData.arrow != null) {\n      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        adaptive: false,\n        roundOffsets: roundOffsets\n      })));\n    }\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-placement': state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var computeStyles$1 = {\n    name: 'computeStyles',\n    enabled: true,\n    phase: 'beforeWrite',\n    fn: computeStyles,\n    data: {}\n  };\n  var passive = {\n    passive: true\n  };\n  function effect(_ref) {\n    var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n    var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n    var window = getWindow(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.addEventListener('scroll', instance.update, passive);\n      });\n    }\n    if (resize) {\n      window.addEventListener('resize', instance.update, passive);\n    }\n    return function () {\n      if (scroll) {\n        scrollParents.forEach(function (scrollParent) {\n          scrollParent.removeEventListener('scroll', instance.update, passive);\n        });\n      }\n      if (resize) {\n        window.removeEventListener('resize', instance.update, passive);\n      }\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var eventListeners = {\n    name: 'eventListeners',\n    enabled: true,\n    phase: 'write',\n    fn: function fn() {},\n    effect: effect,\n    data: {}\n  };\n  var hash$1 = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash$1[matched];\n    });\n  }\n  var hash = {\n    start: 'end',\n    end: 'start'\n  };\n  function getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function (matched) {\n      return hash[matched];\n    });\n  }\n  function getWindowScroll(node) {\n    var win = getWindow(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n      scrollLeft: scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    // Popper 1 is broken in this case and never had a bug report so let's assume\n    // it's not an issue. I don't think anyone ever specifies width on <html>\n    // anyway.\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\n    // this (e.g. Edge 2019, IE11, Safari)\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n  }\n  function getViewportRect(element, strategy) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0;\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height;\n      var layoutViewport = isLayoutViewport();\n      if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n    return {\n      width: width,\n      height: height,\n      x: x + getWindowScrollBarX(element),\n      y: y\n    };\n  }\n\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\n  function getDocumentRect(element) {\n    var _element$ownerDocumen;\n    var html = getDocumentElement(element);\n    var winScroll = getWindowScroll(element);\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -winScroll.scrollTop;\n    if (getComputedStyle$1(body || html).direction === 'rtl') {\n      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n  function isScrollParent(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    var _getComputedStyle = getComputedStyle$1(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n  }\n  function getScrollParent(node) {\n    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n      // $FlowFixMe[incompatible-return]: assume body is always available\n      return node.ownerDocument.body;\n    }\n    if (isHTMLElement(node) && isScrollParent(node)) {\n      return node;\n    }\n    return getScrollParent(getParentNode(node));\n  }\n\n  /*\n  given a DOM element, return the list of all scroll parents, up the list of ancesors\n  until we get to the top window object. This list is what we attach scroll listeners\n  to, because if any of these parent elements scroll, we'll need to re-calculate the\n  reference element's position.\n  */\n\n  function listScrollParents(element, list) {\n    var _element$ownerDocumen;\n    if (list === void 0) {\n      list = [];\n    }\n    var scrollParent = getScrollParent(element);\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n    var win = getWindow(scrollParent);\n    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList :\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    updatedList.concat(listScrollParents(getParentNode(target)));\n  }\n  function rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n      left: rect.x,\n      top: rect.y,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    });\n  }\n  function getInnerBoundingClientRect(element, strategy) {\n    var rect = getBoundingClientRect(element, false, strategy === 'fixed');\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n  }\n  function getClientRectFromMixedType(element, clippingParent, strategy) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n  } // A \"clipping parent\" is an overflowable container with the characteristic of\n  // clipping (or hiding) overflowing elements with a position different from\n  // `initial`\n\n  function getClippingParents(element) {\n    var clippingParents = listScrollParents(getParentNode(element));\n    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n      return [];\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n    return clippingParents.filter(function (clippingParent) {\n      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n    });\n  } // Gets the maximum area that the element is visible in due to any number of\n  // clipping parents\n\n  function getClippingRect(element, boundary, rootBoundary, strategy) {\n    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n    var firstClippingParent = clippingParents[0];\n    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n      var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n  }\n  function computeOffsets(_ref) {\n    var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\n    var offsets;\n    switch (basePlacement) {\n      case top:\n        offsets = {\n          x: commonX,\n          y: reference.y - element.height\n        };\n        break;\n      case bottom:\n        offsets = {\n          x: commonX,\n          y: reference.y + reference.height\n        };\n        break;\n      case right:\n        offsets = {\n          x: reference.x + reference.width,\n          y: commonY\n        };\n        break;\n      case left:\n        offsets = {\n          x: reference.x - element.width,\n          y: commonY\n        };\n        break;\n      default:\n        offsets = {\n          x: reference.x,\n          y: reference.y\n        };\n    }\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n    if (mainAxis != null) {\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      switch (variation) {\n        case start:\n          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n          break;\n        case end:\n          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n          break;\n      }\n    }\n    return offsets;\n  }\n  function detectOverflow(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$strategy = _options.strategy,\n      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n    var referenceClientRect = getBoundingClientRect(state.elements.reference);\n    var popperOffsets = computeOffsets({\n      reference: referenceClientRect,\n      element: popperRect,\n      strategy: 'absolute',\n      placement: placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n\n    var overflowOffsets = {\n      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n      right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n    if (elementContext === popper && offsetData) {\n      var offset = offsetData[placement];\n      Object.keys(overflowOffsets).forEach(function (key) {\n        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n        overflowOffsets[key] += offset[axis] * multiply;\n      });\n    }\n    return overflowOffsets;\n  }\n  function computeAutoPlacement(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n      return getVariation(placement) === variation;\n    }) : basePlacements;\n    var allowedPlacements = placements$1.filter(function (placement) {\n      return allowedAutoPlacements.indexOf(placement) >= 0;\n    });\n    if (allowedPlacements.length === 0) {\n      allowedPlacements = placements$1;\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n    var overflows = allowedPlacements.reduce(function (acc, placement) {\n      acc[placement] = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding\n      })[getBasePlacement(placement)];\n      return acc;\n    }, {});\n    return Object.keys(overflows).sort(function (a, b) {\n      return overflows[a] - overflows[b];\n    });\n  }\n  function getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n      return [];\n    }\n    var oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n  }\n  function flip(_ref) {\n    var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n    if (state.modifiersData[name]._skip) {\n      return;\n    }\n    var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding,\n        flipVariations: flipVariations,\n        allowedAutoPlacements: allowedAutoPlacements\n      }) : placement);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements[0];\n    for (var i = 0; i < placements.length; i++) {\n      var placement = placements[i];\n      var _basePlacement = getBasePlacement(placement);\n      var isStartVariation = getVariation(placement) === start;\n      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n      var len = isVertical ? 'width' : 'height';\n      var overflow = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        altBoundary: altBoundary,\n        padding: padding\n      });\n      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n      if (referenceRect[len] > popperRect[len]) {\n        mainVariationSide = getOppositePlacement(mainVariationSide);\n      }\n      var altVariationSide = getOppositePlacement(mainVariationSide);\n      var checks = [];\n      if (checkMainAxis) {\n        checks.push(overflow[_basePlacement] <= 0);\n      }\n      if (checkAltAxis) {\n        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n      }\n      if (checks.every(function (check) {\n        return check;\n      })) {\n        firstFittingPlacement = placement;\n        makeFallbackChecks = false;\n        break;\n      }\n      checksMap.set(placement, checks);\n    }\n    if (makeFallbackChecks) {\n      // `2` may be desired in some cases  research later\n      var numberOfChecks = flipVariations ? 3 : 1;\n      var _loop = function _loop(_i) {\n        var fittingPlacement = placements.find(function (placement) {\n          var checks = checksMap.get(placement);\n          if (checks) {\n            return checks.slice(0, _i).every(function (check) {\n              return check;\n            });\n          }\n        });\n        if (fittingPlacement) {\n          firstFittingPlacement = fittingPlacement;\n          return \"break\";\n        }\n      };\n      for (var _i = numberOfChecks; _i > 0; _i--) {\n        var _ret = _loop(_i);\n        if (_ret === \"break\") break;\n      }\n    }\n    if (state.placement !== firstFittingPlacement) {\n      state.modifiersData[name]._skip = true;\n      state.placement = firstFittingPlacement;\n      state.reset = true;\n    }\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var flip$1 = {\n    name: 'flip',\n    enabled: true,\n    phase: 'main',\n    fn: flip,\n    requiresIfExists: ['offset'],\n    data: {\n      _skip: false\n    }\n  };\n  function getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n      preventedOffsets = {\n        x: 0,\n        y: 0\n      };\n    }\n    return {\n      top: overflow.top - rect.height - preventedOffsets.y,\n      right: overflow.right - rect.width + preventedOffsets.x,\n      bottom: overflow.bottom - rect.height + preventedOffsets.y,\n      left: overflow.left - rect.width - preventedOffsets.x\n    };\n  }\n  function isAnySideFullyClipped(overflow) {\n    return [top, right, bottom, left].some(function (side) {\n      return overflow[side] >= 0;\n    });\n  }\n  function hide(_ref) {\n    var state = _ref.state,\n      name = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n      elementContext: 'reference'\n    });\n    var popperAltOverflow = detectOverflow(state, {\n      altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name] = {\n      referenceClippingOffsets: referenceClippingOffsets,\n      popperEscapeOffsets: popperEscapeOffsets,\n      isReferenceHidden: isReferenceHidden,\n      hasPopperEscaped: hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-reference-hidden': isReferenceHidden,\n      'data-popper-escaped': hasPopperEscaped\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var hide$1 = {\n    name: 'hide',\n    enabled: true,\n    phase: 'main',\n    requiresIfExists: ['preventOverflow'],\n    fn: hide\n  };\n  function distanceAndSkiddingToXY(placement, rects, offset) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n        placement: placement\n      })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [left, right].indexOf(basePlacement) >= 0 ? {\n      x: distance,\n      y: skidding\n    } : {\n      x: skidding,\n      y: distance\n    };\n  }\n  function offset(_ref2) {\n    var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n    var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n    var data = placements.reduce(function (acc, placement) {\n      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n      return acc;\n    }, {});\n    var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n    if (state.modifiersData.popperOffsets != null) {\n      state.modifiersData.popperOffsets.x += x;\n      state.modifiersData.popperOffsets.y += y;\n    }\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var offset$1 = {\n    name: 'offset',\n    enabled: true,\n    phase: 'main',\n    requires: ['popperOffsets'],\n    fn: offset\n  };\n  function popperOffsets(_ref) {\n    var state = _ref.state,\n      name = _ref.name;\n    // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n    state.modifiersData[name] = computeOffsets({\n      reference: state.rects.reference,\n      element: state.rects.popper,\n      strategy: 'absolute',\n      placement: state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var popperOffsets$1 = {\n    name: 'popperOffsets',\n    enabled: true,\n    phase: 'read',\n    fn: popperOffsets,\n    data: {}\n  };\n  function getAltAxis(axis) {\n    return axis === 'x' ? 'y' : 'x';\n  }\n  function preventOverflow(_ref) {\n    var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n    var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      altBoundary: altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : tetherOffset;\n    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n      mainAxis: tetherOffsetValue,\n      altAxis: tetherOffsetValue\n    } : Object.assign({\n      mainAxis: 0,\n      altAxis: 0\n    }, tetherOffsetValue);\n    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n    var data = {\n      x: 0,\n      y: 0\n    };\n    if (!popperOffsets) {\n      return;\n    }\n    if (checkMainAxis) {\n      var _offsetModifierState$;\n      var mainSide = mainAxis === 'y' ? top : left;\n      var altSide = mainAxis === 'y' ? bottom : right;\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      var offset = popperOffsets[mainAxis];\n      var min$1 = offset + overflow[mainSide];\n      var max$1 = offset - overflow[altSide];\n      var additive = tether ? -popperRect[len] / 2 : 0;\n      var minLen = variation === start ? referenceRect[len] : popperRect[len];\n      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n      // outside the reference bounds\n\n      var arrowElement = state.elements.arrow;\n      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n        width: 0,\n        height: 0\n      };\n      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n      var arrowPaddingMin = arrowPaddingObject[mainSide];\n      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n      // to include its full size in the calculation. If the reference is small\n      // and near the edge of a boundary, the popper can overflow even if the\n      // reference is not overflowing as well (e.g. virtual elements with no\n      // width or height)\n\n      var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n      var tetherMax = offset + maxOffset - offsetModifierValue;\n      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n      popperOffsets[mainAxis] = preventedOffset;\n      data[mainAxis] = preventedOffset - offset;\n    }\n    if (checkAltAxis) {\n      var _offsetModifierState$2;\n      var _mainSide = mainAxis === 'x' ? top : left;\n      var _altSide = mainAxis === 'x' ? bottom : right;\n      var _offset = popperOffsets[altAxis];\n      var _len = altAxis === 'y' ? 'height' : 'width';\n      var _min = _offset + overflow[_mainSide];\n      var _max = _offset - overflow[_altSide];\n      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n      popperOffsets[altAxis] = _preventedOffset;\n      data[altAxis] = _preventedOffset - _offset;\n    }\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var preventOverflow$1 = {\n    name: 'preventOverflow',\n    enabled: true,\n    phase: 'main',\n    fn: preventOverflow,\n    requiresIfExists: ['offset']\n  };\n  function getHTMLElementScroll(element) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  function getNodeScroll(node) {\n    if (node === getWindow(node) || !isHTMLElement(node)) {\n      return getWindowScroll(node);\n    } else {\n      return getHTMLElementScroll(node);\n    }\n  }\n  function isElementScaled(element) {\n    var rect = element.getBoundingClientRect();\n    var scaleX = round(rect.width) / element.offsetWidth || 1;\n    var scaleY = round(rect.height) / element.offsetHeight || 1;\n    return scaleX !== 1 || scaleY !== 1;\n  } // Returns the composite rect of an element relative to its offsetParent.\n  // Composite means it takes into account transforms as well as layout.\n\n  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n      isFixed = false;\n    }\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== 'body' ||\n      // https://github.com/popperjs/popper-core/issues/1078\n      isScrollParent(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        offsets = getBoundingClientRect(offsetParent, true);\n        offsets.x += offsetParent.clientLeft;\n        offsets.y += offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n  function order(modifiers) {\n    var map = new Map();\n    var visited = new Set();\n    var result = [];\n    modifiers.forEach(function (modifier) {\n      map.set(modifier.name, modifier);\n    }); // On visiting object, check for its dependencies and visit them recursively\n\n    function sort(modifier) {\n      visited.add(modifier.name);\n      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n      requires.forEach(function (dep) {\n        if (!visited.has(dep)) {\n          var depModifier = map.get(dep);\n          if (depModifier) {\n            sort(depModifier);\n          }\n        }\n      });\n      result.push(modifier);\n    }\n    modifiers.forEach(function (modifier) {\n      if (!visited.has(modifier.name)) {\n        // check for visited object\n        sort(modifier);\n      }\n    });\n    return result;\n  }\n  function orderModifiers(modifiers) {\n    // order based on dependencies\n    var orderedModifiers = order(modifiers); // order based on phase\n\n    return modifierPhases.reduce(function (acc, phase) {\n      return acc.concat(orderedModifiers.filter(function (modifier) {\n        return modifier.phase === phase;\n      }));\n    }, []);\n  }\n  function debounce(fn) {\n    var pending;\n    return function () {\n      if (!pending) {\n        pending = new Promise(function (resolve) {\n          Promise.resolve().then(function () {\n            pending = undefined;\n            resolve(fn());\n          });\n        });\n      }\n      return pending;\n    };\n  }\n  function mergeByName(modifiers) {\n    var merged = modifiers.reduce(function (merged, current) {\n      var existing = merged[current.name];\n      merged[current.name] = existing ? Object.assign({}, existing, current, {\n        options: Object.assign({}, existing.options, current.options),\n        data: Object.assign({}, existing.data, current.data)\n      }) : current;\n      return merged;\n    }, {}); // IE11 does not support Object.values\n\n    return Object.keys(merged).map(function (key) {\n      return merged[key];\n    });\n  }\n  var DEFAULT_OPTIONS = {\n    placement: 'bottom',\n    modifiers: [],\n    strategy: 'absolute'\n  };\n  function areValidElements() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return !args.some(function (element) {\n      return !(element && typeof element.getBoundingClientRect === 'function');\n    });\n  }\n  function popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n      generatorOptions = {};\n    }\n    var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper(reference, popper, options) {\n      if (options === void 0) {\n        options = defaultOptions;\n      }\n      var state = {\n        placement: 'bottom',\n        orderedModifiers: [],\n        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n        modifiersData: {},\n        elements: {\n          reference: reference,\n          popper: popper\n        },\n        attributes: {},\n        styles: {}\n      };\n      var effectCleanupFns = [];\n      var isDestroyed = false;\n      var instance = {\n        state: state,\n        setOptions: function setOptions(setOptionsAction) {\n          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n          cleanupModifierEffects();\n          state.options = Object.assign({}, defaultOptions, state.options, options);\n          state.scrollParents = {\n            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n            popper: listScrollParents(popper)\n          }; // Orders the modifiers based on their dependencies and `phase`\n          // properties\n\n          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n          state.orderedModifiers = orderedModifiers.filter(function (m) {\n            return m.enabled;\n          }); // Validate the provided modifiers so that the consumer will get warned\n\n          runModifierEffects();\n          return instance.update();\n        },\n        // Sync update  it will always be executed, even if not necessary. This\n        // is useful for low frequency updates where sync behavior simplifies the\n        // logic.\n        // For high frequency updates (e.g. `resize` and `scroll` events), always\n        // prefer the async Popper#update method\n        forceUpdate: function forceUpdate() {\n          if (isDestroyed) {\n            return;\n          }\n          var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n          // anymore\n\n          if (!areValidElements(reference, popper)) {\n            return;\n          } // Store the reference and popper rects to be read by modifiers\n\n          state.rects = {\n            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n            popper: getLayoutRect(popper)\n          }; // Modifiers have the ability to reset the current update cycle. The\n          // most common use case for this is the `flip` modifier changing the\n          // placement, which then needs to re-run all the modifiers, because the\n          // logic was previously ran for the previous placement and is therefore\n          // stale/incorrect\n\n          state.reset = false;\n          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n          // is filled with the initial data specified by the modifier. This means\n          // it doesn't persist and is fresh on each update.\n          // To ensure persistent data, use `${name}#persistent`\n\n          state.orderedModifiers.forEach(function (modifier) {\n            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n          });\n          for (var index = 0; index < state.orderedModifiers.length; index++) {\n            if (state.reset === true) {\n              state.reset = false;\n              index = -1;\n              continue;\n            }\n            var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n            if (typeof fn === 'function') {\n              state = fn({\n                state: state,\n                options: _options,\n                name: name,\n                instance: instance\n              }) || state;\n            }\n          }\n        },\n        // Async and optimistically optimized update  it will not be executed if\n        // not necessary (debounced to run at most once-per-tick)\n        update: debounce(function () {\n          return new Promise(function (resolve) {\n            instance.forceUpdate();\n            resolve(state);\n          });\n        }),\n        destroy: function destroy() {\n          cleanupModifierEffects();\n          isDestroyed = true;\n        }\n      };\n      if (!areValidElements(reference, popper)) {\n        return instance;\n      }\n      instance.setOptions(options).then(function (state) {\n        if (!isDestroyed && options.onFirstUpdate) {\n          options.onFirstUpdate(state);\n        }\n      }); // Modifiers have the ability to execute arbitrary code before the first\n      // update cycle runs. They will be executed in the same order as the update\n      // cycle. This is useful when a modifier adds some persistent data that\n      // other modifiers need to use, but the modifier is run after the dependent\n      // one.\n\n      function runModifierEffects() {\n        state.orderedModifiers.forEach(function (_ref3) {\n          var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n          if (typeof effect === 'function') {\n            var cleanupFn = effect({\n              state: state,\n              name: name,\n              instance: instance,\n              options: options\n            });\n            var noopFn = function noopFn() {};\n            effectCleanupFns.push(cleanupFn || noopFn);\n          }\n        });\n      }\n      function cleanupModifierEffects() {\n        effectCleanupFns.forEach(function (fn) {\n          return fn();\n        });\n        effectCleanupFns = [];\n      }\n      return instance;\n    };\n  }\n  var createPopper$2 = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\n  var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];\n  var createPopper$1 = /*#__PURE__*/popperGenerator({\n    defaultModifiers: defaultModifiers$1\n  }); // eslint-disable-next-line import/no-unused-modules\n\n  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\n  var createPopper = /*#__PURE__*/popperGenerator({\n    defaultModifiers: defaultModifiers\n  }); // eslint-disable-next-line import/no-unused-modules\n\n  var Popper = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.defineProperty({\n    __proto__: null,\n    popperGenerator: popperGenerator,\n    detectOverflow: detectOverflow,\n    createPopperBase: createPopper$2,\n    createPopper: createPopper,\n    createPopperLite: createPopper$1,\n    top: top,\n    bottom: bottom,\n    right: right,\n    left: left,\n    auto: auto,\n    basePlacements: basePlacements,\n    start: start,\n    end: end,\n    clippingParents: clippingParents,\n    viewport: viewport,\n    popper: popper,\n    reference: reference,\n    variationPlacements: variationPlacements,\n    placements: placements,\n    beforeRead: beforeRead,\n    read: read,\n    afterRead: afterRead,\n    beforeMain: beforeMain,\n    main: main,\n    afterMain: afterMain,\n    beforeWrite: beforeWrite,\n    write: write,\n    afterWrite: afterWrite,\n    modifierPhases: modifierPhases,\n    applyStyles: applyStyles$1,\n    arrow: arrow$1,\n    computeStyles: computeStyles$1,\n    eventListeners: eventListeners,\n    flip: flip$1,\n    hide: hide$1,\n    offset: offset$1,\n    popperOffsets: popperOffsets$1,\n    preventOverflow: preventOverflow$1\n  }, Symbol.toStringTag, {\n    value: 'Module'\n  }));\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): dropdown.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  var NAME$a = 'dropdown';\n  var DATA_KEY$6 = 'bs.dropdown';\n  var EVENT_KEY$6 = \".\".concat(DATA_KEY$6);\n  var DATA_API_KEY$3 = '.data-api';\n  var ESCAPE_KEY$2 = 'Escape';\n  var TAB_KEY$1 = 'Tab';\n  var ARROW_UP_KEY$1 = 'ArrowUp';\n  var ARROW_DOWN_KEY$1 = 'ArrowDown';\n  var RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\n\n  var EVENT_HIDE$5 = \"hide\".concat(EVENT_KEY$6);\n  var EVENT_HIDDEN$5 = \"hidden\".concat(EVENT_KEY$6);\n  var EVENT_SHOW$5 = \"show\".concat(EVENT_KEY$6);\n  var EVENT_SHOWN$5 = \"shown\".concat(EVENT_KEY$6);\n  var EVENT_CLICK_DATA_API$3 = \"click\".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);\n  var EVENT_KEYDOWN_DATA_API = \"keydown\".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);\n  var EVENT_KEYUP_DATA_API = \"keyup\".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);\n  var CLASS_NAME_SHOW$6 = 'show';\n  var CLASS_NAME_DROPUP = 'dropup';\n  var CLASS_NAME_DROPEND = 'dropend';\n  var CLASS_NAME_DROPSTART = 'dropstart';\n  var CLASS_NAME_DROPUP_CENTER = 'dropup-center';\n  var CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';\n  var SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\"dropdown\"]:not(.disabled):not(:disabled)';\n  var SELECTOR_DATA_TOGGLE_SHOWN = \"\".concat(SELECTOR_DATA_TOGGLE$3, \".\").concat(CLASS_NAME_SHOW$6);\n  var SELECTOR_MENU = '.dropdown-menu';\n  var SELECTOR_NAVBAR = '.navbar';\n  var SELECTOR_NAVBAR_NAV = '.navbar-nav';\n  var SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\n  var PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';\n  var PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';\n  var PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';\n  var PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';\n  var PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';\n  var PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';\n  var PLACEMENT_TOPCENTER = 'top';\n  var PLACEMENT_BOTTOMCENTER = 'bottom';\n  var Default$9 = {\n    autoClose: true,\n    boundary: 'clippingParents',\n    display: 'dynamic',\n    offset: [0, 2],\n    popperConfig: null,\n    reference: 'toggle'\n  };\n  var DefaultType$9 = {\n    autoClose: '(boolean|string)',\n    boundary: '(string|element)',\n    display: 'string',\n    offset: '(array|string|function)',\n    popperConfig: '(null|object|function)',\n    reference: '(string|element|object)'\n  };\n  /**\n   * Class definition\n   */\n  var Dropdown = /*#__PURE__*/function (_BaseComponent5) {\n    _inherits(Dropdown, _BaseComponent5);\n    var _super7 = _createSuper(Dropdown);\n    function Dropdown(element, config) {\n      var _this15;\n      _classCallCheck(this, Dropdown);\n      _this15 = _super7.call(this, element, config);\n      _this15._popper = null;\n      _this15._parent = _this15._element.parentNode; // dropdown wrapper\n      // todo: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.2/forms/input-group/\n\n      _this15._menu = SelectorEngine.next(_this15._element, SELECTOR_MENU)[0] || SelectorEngine.prev(_this15._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, _this15._parent);\n      _this15._inNavbar = _this15._detectNavbar();\n      return _this15;\n    } // Getters\n    _createClass(Dropdown, [{\n      key: \"toggle\",\n      value:\n      // Public\n\n      function toggle() {\n        return this._isShown() ? this.hide() : this.show();\n      }\n    }, {\n      key: \"show\",\n      value: function show() {\n        if (isDisabled(this._element) || this._isShown()) {\n          return;\n        }\n        var relatedTarget = {\n          relatedTarget: this._element\n        };\n        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);\n        if (showEvent.defaultPrevented) {\n          return;\n        }\n        this._createPopper(); // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n        if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {\n          var _ref9;\n          var _iterator13 = _createForOfIteratorHelper((_ref9 = []).concat.apply(_ref9, _toConsumableArray(document.body.children))),\n            _step13;\n          try {\n            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n              var element = _step13.value;\n              EventHandler.on(element, 'mouseover', noop);\n            }\n          } catch (err) {\n            _iterator13.e(err);\n          } finally {\n            _iterator13.f();\n          }\n        }\n        this._element.focus();\n        this._element.setAttribute('aria-expanded', true);\n        this._menu.classList.add(CLASS_NAME_SHOW$6);\n        this._element.classList.add(CLASS_NAME_SHOW$6);\n        EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        if (isDisabled(this._element) || !this._isShown()) {\n          return;\n        }\n        var relatedTarget = {\n          relatedTarget: this._element\n        };\n        this._completeHide(relatedTarget);\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        if (this._popper) {\n          this._popper.destroy();\n        }\n        _get(_getPrototypeOf(Dropdown.prototype), \"dispose\", this).call(this);\n      }\n    }, {\n      key: \"update\",\n      value: function update() {\n        this._inNavbar = this._detectNavbar();\n        if (this._popper) {\n          this._popper.update();\n        }\n      } // Private\n    }, {\n      key: \"_completeHide\",\n      value: function _completeHide(relatedTarget) {\n        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);\n        if (hideEvent.defaultPrevented) {\n          return;\n        } // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n\n        if ('ontouchstart' in document.documentElement) {\n          var _ref10;\n          var _iterator14 = _createForOfIteratorHelper((_ref10 = []).concat.apply(_ref10, _toConsumableArray(document.body.children))),\n            _step14;\n          try {\n            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n              var element = _step14.value;\n              EventHandler.off(element, 'mouseover', noop);\n            }\n          } catch (err) {\n            _iterator14.e(err);\n          } finally {\n            _iterator14.f();\n          }\n        }\n        if (this._popper) {\n          this._popper.destroy();\n        }\n        this._menu.classList.remove(CLASS_NAME_SHOW$6);\n        this._element.classList.remove(CLASS_NAME_SHOW$6);\n        this._element.setAttribute('aria-expanded', 'false');\n        Manipulator.removeDataAttribute(this._menu, 'popper');\n        EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);\n      }\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        config = _get(_getPrototypeOf(Dropdown.prototype), \"_getConfig\", this).call(this, config);\n        if (_typeof(config.reference) === 'object' && !isElement$1(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {\n          // Popper virtual elements require a getBoundingClientRect method\n          throw new TypeError(\"\".concat(NAME$a.toUpperCase(), \": Option \\\"reference\\\" provided type \\\"object\\\" without a required \\\"getBoundingClientRect\\\" method.\"));\n        }\n        return config;\n      }\n    }, {\n      key: \"_createPopper\",\n      value: function _createPopper() {\n        if (typeof Popper === 'undefined') {\n          throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org)');\n        }\n        var referenceElement = this._element;\n        if (this._config.reference === 'parent') {\n          referenceElement = this._parent;\n        } else if (isElement$1(this._config.reference)) {\n          referenceElement = getElement(this._config.reference);\n        } else if (_typeof(this._config.reference) === 'object') {\n          referenceElement = this._config.reference;\n        }\n        var popperConfig = this._getPopperConfig();\n        this._popper = createPopper(referenceElement, this._menu, popperConfig);\n      }\n    }, {\n      key: \"_isShown\",\n      value: function _isShown() {\n        return this._menu.classList.contains(CLASS_NAME_SHOW$6);\n      }\n    }, {\n      key: \"_getPlacement\",\n      value: function _getPlacement() {\n        var parentDropdown = this._parent;\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\n          return PLACEMENT_RIGHT;\n        }\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\n          return PLACEMENT_LEFT;\n        }\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {\n          return PLACEMENT_TOPCENTER;\n        }\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {\n          return PLACEMENT_BOTTOMCENTER;\n        } // We need to trim the value because custom properties can also include spaces\n\n        var isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\n          return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n        }\n        return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\n      }\n    }, {\n      key: \"_detectNavbar\",\n      value: function _detectNavbar() {\n        return this._element.closest(SELECTOR_NAVBAR) !== null;\n      }\n    }, {\n      key: \"_getOffset\",\n      value: function _getOffset() {\n        var _this16 = this;\n        var offset = this._config.offset;\n        if (typeof offset === 'string') {\n          return offset.split(',').map(function (value) {\n            return Number.parseInt(value, 10);\n          });\n        }\n        if (typeof offset === 'function') {\n          return function (popperData) {\n            return offset(popperData, _this16._element);\n          };\n        }\n        return offset;\n      }\n    }, {\n      key: \"_getPopperConfig\",\n      value: function _getPopperConfig() {\n        var defaultBsPopperConfig = {\n          placement: this._getPlacement(),\n          modifiers: [{\n            name: 'preventOverflow',\n            options: {\n              boundary: this._config.boundary\n            }\n          }, {\n            name: 'offset',\n            options: {\n              offset: this._getOffset()\n            }\n          }]\n        }; // Disable Popper if we have a static display or Dropdown is in Navbar\n\n        if (this._inNavbar || this._config.display === 'static') {\n          Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // todo:v6 remove\n\n          defaultBsPopperConfig.modifiers = [{\n            name: 'applyStyles',\n            enabled: false\n          }];\n        }\n        return _objectSpread(_objectSpread({}, defaultBsPopperConfig), typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig);\n      }\n    }, {\n      key: \"_selectMenuItem\",\n      value: function _selectMenuItem(_ref11) {\n        var key = _ref11.key,\n          target = _ref11.target;\n        var items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(function (element) {\n          return isVisible(element);\n        });\n        if (!items.length) {\n          return;\n        } // if target isn't included in items (e.g. when expanding the dropdown)\n        // allow cycling to get the last item in case key equals ARROW_UP_KEY\n\n        getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$9;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$9;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$a;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Dropdown.getOrCreateInstance(this, config);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        });\n      }\n    }, {\n      key: \"clearMenus\",\n      value: function clearMenus(event) {\n        if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {\n          return;\n        }\n        var openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);\n        var _iterator15 = _createForOfIteratorHelper(openToggles),\n          _step15;\n        try {\n          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n            var toggle = _step15.value;\n            var context = Dropdown.getInstance(toggle);\n            if (!context || context._config.autoClose === false) {\n              continue;\n            }\n            var composedPath = event.composedPath();\n            var isMenuTarget = composedPath.includes(context._menu);\n            if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {\n              continue;\n            } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\n\n            if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {\n              continue;\n            }\n            var relatedTarget = {\n              relatedTarget: context._element\n            };\n            if (event.type === 'click') {\n              relatedTarget.clickEvent = event;\n            }\n            context._completeHide(relatedTarget);\n          }\n        } catch (err) {\n          _iterator15.e(err);\n        } finally {\n          _iterator15.f();\n        }\n      }\n    }, {\n      key: \"dataApiKeydownHandler\",\n      value: function dataApiKeydownHandler(event) {\n        // If not an UP | DOWN | ESCAPE key => not a dropdown command\n        // If input/textarea && if key is other than ESCAPE => not a dropdown command\n        var isInput = /input|textarea/i.test(event.target.tagName);\n        var isEscapeEvent = event.key === ESCAPE_KEY$2;\n        var isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);\n        if (!isUpOrDownEvent && !isEscapeEvent) {\n          return;\n        }\n        if (isInput && !isEscapeEvent) {\n          return;\n        }\n        event.preventDefault(); // todo: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.2/forms/input-group/\n\n        var getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);\n        var instance = Dropdown.getOrCreateInstance(getToggleButton);\n        if (isUpOrDownEvent) {\n          event.stopPropagation();\n          instance.show();\n          instance._selectMenuItem(event);\n          return;\n        }\n        if (instance._isShown()) {\n          // else is escape and we check if it is shown\n          event.stopPropagation();\n          instance.hide();\n          getToggleButton.focus();\n        }\n      }\n    }]);\n    return Dropdown;\n  }(BaseComponent);\n  /**\n   * Data API implementation\n   */\n  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);\n  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\n  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);\n  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\n  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {\n    event.preventDefault();\n    Dropdown.getOrCreateInstance(this).toggle();\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Dropdown);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): util/scrollBar.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  var SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\n  var SELECTOR_STICKY_CONTENT = '.sticky-top';\n  var PROPERTY_PADDING = 'padding-right';\n  var PROPERTY_MARGIN = 'margin-right';\n  /**\n   * Class definition\n   */\n  var ScrollBarHelper = /*#__PURE__*/function () {\n    function ScrollBarHelper() {\n      _classCallCheck(this, ScrollBarHelper);\n      this._element = document.body;\n    } // Public\n    _createClass(ScrollBarHelper, [{\n      key: \"getWidth\",\n      value: function getWidth() {\n        // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n        var documentWidth = document.documentElement.clientWidth;\n        return Math.abs(window.innerWidth - documentWidth);\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var width = this.getWidth();\n        this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width\n\n        this._setElementAttributes(this._element, PROPERTY_PADDING, function (calculatedValue) {\n          return calculatedValue + width;\n        }); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\n\n        this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, function (calculatedValue) {\n          return calculatedValue + width;\n        });\n        this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, function (calculatedValue) {\n          return calculatedValue - width;\n        });\n      }\n    }, {\n      key: \"reset\",\n      value: function reset() {\n        this._resetElementAttributes(this._element, 'overflow');\n        this._resetElementAttributes(this._element, PROPERTY_PADDING);\n        this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);\n        this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);\n      }\n    }, {\n      key: \"isOverflowing\",\n      value: function isOverflowing() {\n        return this.getWidth() > 0;\n      } // Private\n    }, {\n      key: \"_disableOverFlow\",\n      value: function _disableOverFlow() {\n        this._saveInitialAttribute(this._element, 'overflow');\n        this._element.style.overflow = 'hidden';\n      }\n    }, {\n      key: \"_setElementAttributes\",\n      value: function _setElementAttributes(selector, styleProperty, callback) {\n        var _this17 = this;\n        var scrollbarWidth = this.getWidth();\n        var manipulationCallBack = function manipulationCallBack(element) {\n          if (element !== _this17._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\n            return;\n          }\n          _this17._saveInitialAttribute(element, styleProperty);\n          var calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);\n          element.style.setProperty(styleProperty, \"\".concat(callback(Number.parseFloat(calculatedValue)), \"px\"));\n        };\n        this._applyManipulationCallback(selector, manipulationCallBack);\n      }\n    }, {\n      key: \"_saveInitialAttribute\",\n      value: function _saveInitialAttribute(element, styleProperty) {\n        var actualValue = element.style.getPropertyValue(styleProperty);\n        if (actualValue) {\n          Manipulator.setDataAttribute(element, styleProperty, actualValue);\n        }\n      }\n    }, {\n      key: \"_resetElementAttributes\",\n      value: function _resetElementAttributes(selector, styleProperty) {\n        var manipulationCallBack = function manipulationCallBack(element) {\n          var value = Manipulator.getDataAttribute(element, styleProperty); // We only want to remove the property if the value is `null`; the value can also be zero\n\n          if (value === null) {\n            element.style.removeProperty(styleProperty);\n            return;\n          }\n          Manipulator.removeDataAttribute(element, styleProperty);\n          element.style.setProperty(styleProperty, value);\n        };\n        this._applyManipulationCallback(selector, manipulationCallBack);\n      }\n    }, {\n      key: \"_applyManipulationCallback\",\n      value: function _applyManipulationCallback(selector, callBack) {\n        if (isElement$1(selector)) {\n          callBack(selector);\n          return;\n        }\n        var _iterator16 = _createForOfIteratorHelper(SelectorEngine.find(selector, this._element)),\n          _step16;\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var sel = _step16.value;\n            callBack(sel);\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      }\n    }]);\n    return ScrollBarHelper;\n  }();\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): util/backdrop.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n  var NAME$9 = 'backdrop';\n  var CLASS_NAME_FADE$4 = 'fade';\n  var CLASS_NAME_SHOW$5 = 'show';\n  var EVENT_MOUSEDOWN = \"mousedown.bs.\".concat(NAME$9);\n  var Default$8 = {\n    className: 'modal-backdrop',\n    clickCallback: null,\n    isAnimated: false,\n    isVisible: true,\n    // if false, we use the backdrop helper without adding any element to the dom\n    rootElement: 'body' // give the choice to place backdrop under different elements\n  };\n\n  var DefaultType$8 = {\n    className: 'string',\n    clickCallback: '(function|null)',\n    isAnimated: 'boolean',\n    isVisible: 'boolean',\n    rootElement: '(element|string)'\n  };\n  /**\n   * Class definition\n   */\n  var Backdrop = /*#__PURE__*/function (_Config3) {\n    _inherits(Backdrop, _Config3);\n    var _super8 = _createSuper(Backdrop);\n    function Backdrop(config) {\n      var _this18;\n      _classCallCheck(this, Backdrop);\n      _this18 = _super8.call(this);\n      _this18._config = _this18._getConfig(config);\n      _this18._isAppended = false;\n      _this18._element = null;\n      return _this18;\n    } // Getters\n    _createClass(Backdrop, [{\n      key: \"show\",\n      value:\n      // Public\n\n      function show(callback) {\n        if (!this._config.isVisible) {\n          execute(callback);\n          return;\n        }\n        this._append();\n        var element = this._getElement();\n        if (this._config.isAnimated) {\n          reflow(element);\n        }\n        element.classList.add(CLASS_NAME_SHOW$5);\n        this._emulateAnimation(function () {\n          execute(callback);\n        });\n      }\n    }, {\n      key: \"hide\",\n      value: function hide(callback) {\n        var _this19 = this;\n        if (!this._config.isVisible) {\n          execute(callback);\n          return;\n        }\n        this._getElement().classList.remove(CLASS_NAME_SHOW$5);\n        this._emulateAnimation(function () {\n          _this19.dispose();\n          execute(callback);\n        });\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        if (!this._isAppended) {\n          return;\n        }\n        EventHandler.off(this._element, EVENT_MOUSEDOWN);\n        this._element.remove();\n        this._isAppended = false;\n      } // Private\n    }, {\n      key: \"_getElement\",\n      value: function _getElement() {\n        if (!this._element) {\n          var backdrop = document.createElement('div');\n          backdrop.className = this._config.className;\n          if (this._config.isAnimated) {\n            backdrop.classList.add(CLASS_NAME_FADE$4);\n          }\n          this._element = backdrop;\n        }\n        return this._element;\n      }\n    }, {\n      key: \"_configAfterMerge\",\n      value: function _configAfterMerge(config) {\n        // use getElement() with the default \"body\" to get a fresh Element on each instantiation\n        config.rootElement = getElement(config.rootElement);\n        return config;\n      }\n    }, {\n      key: \"_append\",\n      value: function _append() {\n        var _this20 = this;\n        if (this._isAppended) {\n          return;\n        }\n        var element = this._getElement();\n        this._config.rootElement.append(element);\n        EventHandler.on(element, EVENT_MOUSEDOWN, function () {\n          execute(_this20._config.clickCallback);\n        });\n        this._isAppended = true;\n      }\n    }, {\n      key: \"_emulateAnimation\",\n      value: function _emulateAnimation(callback) {\n        executeAfterTransition(callback, this._getElement(), this._config.isAnimated);\n      }\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$8;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$8;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$9;\n      }\n    }]);\n    return Backdrop;\n  }(Config);\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): util/focustrap.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n  var NAME$8 = 'focustrap';\n  var DATA_KEY$5 = 'bs.focustrap';\n  var EVENT_KEY$5 = \".\".concat(DATA_KEY$5);\n  var EVENT_FOCUSIN$2 = \"focusin\".concat(EVENT_KEY$5);\n  var EVENT_KEYDOWN_TAB = \"keydown.tab\".concat(EVENT_KEY$5);\n  var TAB_KEY = 'Tab';\n  var TAB_NAV_FORWARD = 'forward';\n  var TAB_NAV_BACKWARD = 'backward';\n  var Default$7 = {\n    autofocus: true,\n    trapElement: null // The element to trap focus inside of\n  };\n\n  var DefaultType$7 = {\n    autofocus: 'boolean',\n    trapElement: 'element'\n  };\n  /**\n   * Class definition\n   */\n  var FocusTrap = /*#__PURE__*/function (_Config4) {\n    _inherits(FocusTrap, _Config4);\n    var _super9 = _createSuper(FocusTrap);\n    function FocusTrap(config) {\n      var _this21;\n      _classCallCheck(this, FocusTrap);\n      _this21 = _super9.call(this);\n      _this21._config = _this21._getConfig(config);\n      _this21._isActive = false;\n      _this21._lastTabNavDirection = null;\n      return _this21;\n    } // Getters\n    _createClass(FocusTrap, [{\n      key: \"activate\",\n      value:\n      // Public\n\n      function activate() {\n        var _this22 = this;\n        if (this._isActive) {\n          return;\n        }\n        if (this._config.autofocus) {\n          this._config.trapElement.focus();\n        }\n        EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop\n\n        EventHandler.on(document, EVENT_FOCUSIN$2, function (event) {\n          return _this22._handleFocusin(event);\n        });\n        EventHandler.on(document, EVENT_KEYDOWN_TAB, function (event) {\n          return _this22._handleKeydown(event);\n        });\n        this._isActive = true;\n      }\n    }, {\n      key: \"deactivate\",\n      value: function deactivate() {\n        if (!this._isActive) {\n          return;\n        }\n        this._isActive = false;\n        EventHandler.off(document, EVENT_KEY$5);\n      } // Private\n    }, {\n      key: \"_handleFocusin\",\n      value: function _handleFocusin(event) {\n        var trapElement = this._config.trapElement;\n        if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {\n          return;\n        }\n        var elements = SelectorEngine.focusableChildren(trapElement);\n        if (elements.length === 0) {\n          trapElement.focus();\n        } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {\n          elements[elements.length - 1].focus();\n        } else {\n          elements[0].focus();\n        }\n      }\n    }, {\n      key: \"_handleKeydown\",\n      value: function _handleKeydown(event) {\n        if (event.key !== TAB_KEY) {\n          return;\n        }\n        this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;\n      }\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$7;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$7;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$8;\n      }\n    }]);\n    return FocusTrap;\n  }(Config);\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): modal.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n  var NAME$7 = 'modal';\n  var DATA_KEY$4 = 'bs.modal';\n  var EVENT_KEY$4 = \".\".concat(DATA_KEY$4);\n  var DATA_API_KEY$2 = '.data-api';\n  var ESCAPE_KEY$1 = 'Escape';\n  var EVENT_HIDE$4 = \"hide\".concat(EVENT_KEY$4);\n  var EVENT_HIDE_PREVENTED$1 = \"hidePrevented\".concat(EVENT_KEY$4);\n  var EVENT_HIDDEN$4 = \"hidden\".concat(EVENT_KEY$4);\n  var EVENT_SHOW$4 = \"show\".concat(EVENT_KEY$4);\n  var EVENT_SHOWN$4 = \"shown\".concat(EVENT_KEY$4);\n  var EVENT_RESIZE$1 = \"resize\".concat(EVENT_KEY$4);\n  var EVENT_CLICK_DISMISS = \"click.dismiss\".concat(EVENT_KEY$4);\n  var EVENT_MOUSEDOWN_DISMISS = \"mousedown.dismiss\".concat(EVENT_KEY$4);\n  var EVENT_KEYDOWN_DISMISS$1 = \"keydown.dismiss\".concat(EVENT_KEY$4);\n  var EVENT_CLICK_DATA_API$2 = \"click\".concat(EVENT_KEY$4).concat(DATA_API_KEY$2);\n  var CLASS_NAME_OPEN = 'modal-open';\n  var CLASS_NAME_FADE$3 = 'fade';\n  var CLASS_NAME_SHOW$4 = 'show';\n  var CLASS_NAME_STATIC = 'modal-static';\n  var OPEN_SELECTOR$1 = '.modal.show';\n  var SELECTOR_DIALOG = '.modal-dialog';\n  var SELECTOR_MODAL_BODY = '.modal-body';\n  var SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\"modal\"]';\n  var Default$6 = {\n    backdrop: true,\n    focus: true,\n    keyboard: true\n  };\n  var DefaultType$6 = {\n    backdrop: '(boolean|string)',\n    focus: 'boolean',\n    keyboard: 'boolean'\n  };\n  /**\n   * Class definition\n   */\n  var Modal = /*#__PURE__*/function (_BaseComponent6) {\n    _inherits(Modal, _BaseComponent6);\n    var _super10 = _createSuper(Modal);\n    function Modal(element, config) {\n      var _this23;\n      _classCallCheck(this, Modal);\n      _this23 = _super10.call(this, element, config);\n      _this23._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, _this23._element);\n      _this23._backdrop = _this23._initializeBackDrop();\n      _this23._focustrap = _this23._initializeFocusTrap();\n      _this23._isShown = false;\n      _this23._isTransitioning = false;\n      _this23._scrollBar = new ScrollBarHelper();\n      _this23._addEventListeners();\n      return _this23;\n    } // Getters\n    _createClass(Modal, [{\n      key: \"toggle\",\n      value:\n      // Public\n\n      function toggle(relatedTarget) {\n        return this._isShown ? this.hide() : this.show(relatedTarget);\n      }\n    }, {\n      key: \"show\",\n      value: function show(relatedTarget) {\n        var _this24 = this;\n        if (this._isShown || this._isTransitioning) {\n          return;\n        }\n        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {\n          relatedTarget: relatedTarget\n        });\n        if (showEvent.defaultPrevented) {\n          return;\n        }\n        this._isShown = true;\n        this._isTransitioning = true;\n        this._scrollBar.hide();\n        document.body.classList.add(CLASS_NAME_OPEN);\n        this._adjustDialog();\n        this._backdrop.show(function () {\n          return _this24._showElement(relatedTarget);\n        });\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var _this25 = this;\n        if (!this._isShown || this._isTransitioning) {\n          return;\n        }\n        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);\n        if (hideEvent.defaultPrevented) {\n          return;\n        }\n        this._isShown = false;\n        this._isTransitioning = true;\n        this._focustrap.deactivate();\n        this._element.classList.remove(CLASS_NAME_SHOW$4);\n        this._queueCallback(function () {\n          return _this25._hideModal();\n        }, this._element, this._isAnimated());\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        for (var _i7 = 0, _arr2 = [window, this._dialog]; _i7 < _arr2.length; _i7++) {\n          var htmlElement = _arr2[_i7];\n          EventHandler.off(htmlElement, EVENT_KEY$4);\n        }\n        this._backdrop.dispose();\n        this._focustrap.deactivate();\n        _get(_getPrototypeOf(Modal.prototype), \"dispose\", this).call(this);\n      }\n    }, {\n      key: \"handleUpdate\",\n      value: function handleUpdate() {\n        this._adjustDialog();\n      } // Private\n    }, {\n      key: \"_initializeBackDrop\",\n      value: function _initializeBackDrop() {\n        return new Backdrop({\n          isVisible: Boolean(this._config.backdrop),\n          // 'static' option will be translated to true, and booleans will keep their value,\n          isAnimated: this._isAnimated()\n        });\n      }\n    }, {\n      key: \"_initializeFocusTrap\",\n      value: function _initializeFocusTrap() {\n        return new FocusTrap({\n          trapElement: this._element\n        });\n      }\n    }, {\n      key: \"_showElement\",\n      value: function _showElement(relatedTarget) {\n        var _this26 = this;\n        // try to append dynamic modal\n        if (!document.body.contains(this._element)) {\n          document.body.append(this._element);\n        }\n        this._element.style.display = 'block';\n        this._element.removeAttribute('aria-hidden');\n        this._element.setAttribute('aria-modal', true);\n        this._element.setAttribute('role', 'dialog');\n        this._element.scrollTop = 0;\n        var modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\n        if (modalBody) {\n          modalBody.scrollTop = 0;\n        }\n        reflow(this._element);\n        this._element.classList.add(CLASS_NAME_SHOW$4);\n        var transitionComplete = function transitionComplete() {\n          if (_this26._config.focus) {\n            _this26._focustrap.activate();\n          }\n          _this26._isTransitioning = false;\n          EventHandler.trigger(_this26._element, EVENT_SHOWN$4, {\n            relatedTarget: relatedTarget\n          });\n        };\n        this._queueCallback(transitionComplete, this._dialog, this._isAnimated());\n      }\n    }, {\n      key: \"_addEventListeners\",\n      value: function _addEventListeners() {\n        var _this27 = this;\n        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, function (event) {\n          if (event.key !== ESCAPE_KEY$1) {\n            return;\n          }\n          if (_this27._config.keyboard) {\n            event.preventDefault();\n            _this27.hide();\n            return;\n          }\n          _this27._triggerBackdropTransition();\n        });\n        EventHandler.on(window, EVENT_RESIZE$1, function () {\n          if (_this27._isShown && !_this27._isTransitioning) {\n            _this27._adjustDialog();\n          }\n        });\n        EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, function (event) {\n          // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks\n          EventHandler.one(_this27._element, EVENT_CLICK_DISMISS, function (event2) {\n            if (_this27._element !== event.target || _this27._element !== event2.target) {\n              return;\n            }\n            if (_this27._config.backdrop === 'static') {\n              _this27._triggerBackdropTransition();\n              return;\n            }\n            if (_this27._config.backdrop) {\n              _this27.hide();\n            }\n          });\n        });\n      }\n    }, {\n      key: \"_hideModal\",\n      value: function _hideModal() {\n        var _this28 = this;\n        this._element.style.display = 'none';\n        this._element.setAttribute('aria-hidden', true);\n        this._element.removeAttribute('aria-modal');\n        this._element.removeAttribute('role');\n        this._isTransitioning = false;\n        this._backdrop.hide(function () {\n          document.body.classList.remove(CLASS_NAME_OPEN);\n          _this28._resetAdjustments();\n          _this28._scrollBar.reset();\n          EventHandler.trigger(_this28._element, EVENT_HIDDEN$4);\n        });\n      }\n    }, {\n      key: \"_isAnimated\",\n      value: function _isAnimated() {\n        return this._element.classList.contains(CLASS_NAME_FADE$3);\n      }\n    }, {\n      key: \"_triggerBackdropTransition\",\n      value: function _triggerBackdropTransition() {\n        var _this29 = this;\n        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);\n        if (hideEvent.defaultPrevented) {\n          return;\n        }\n        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n        var initialOverflowY = this._element.style.overflowY; // return if the following background transition hasn't yet completed\n\n        if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {\n          return;\n        }\n        if (!isModalOverflowing) {\n          this._element.style.overflowY = 'hidden';\n        }\n        this._element.classList.add(CLASS_NAME_STATIC);\n        this._queueCallback(function () {\n          _this29._element.classList.remove(CLASS_NAME_STATIC);\n          _this29._queueCallback(function () {\n            _this29._element.style.overflowY = initialOverflowY;\n          }, _this29._dialog);\n        }, this._dialog);\n        this._element.focus();\n      }\n      /**\n       * The following methods are used to handle overflowing modals\n       */\n    }, {\n      key: \"_adjustDialog\",\n      value: function _adjustDialog() {\n        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n        var scrollbarWidth = this._scrollBar.getWidth();\n        var isBodyOverflowing = scrollbarWidth > 0;\n        if (isBodyOverflowing && !isModalOverflowing) {\n          var property = isRTL() ? 'paddingLeft' : 'paddingRight';\n          this._element.style[property] = \"\".concat(scrollbarWidth, \"px\");\n        }\n        if (!isBodyOverflowing && isModalOverflowing) {\n          var _property = isRTL() ? 'paddingRight' : 'paddingLeft';\n          this._element.style[_property] = \"\".concat(scrollbarWidth, \"px\");\n        }\n      }\n    }, {\n      key: \"_resetAdjustments\",\n      value: function _resetAdjustments() {\n        this._element.style.paddingLeft = '';\n        this._element.style.paddingRight = '';\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$6;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$6;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$7;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config, relatedTarget) {\n        return this.each(function () {\n          var data = Modal.getOrCreateInstance(this, config);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config](relatedTarget);\n        });\n      }\n    }]);\n    return Modal;\n  }(BaseComponent);\n  /**\n   * Data API implementation\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {\n    var _this30 = this;\n    var target = getElementFromSelector(this);\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n    EventHandler.one(target, EVENT_SHOW$4, function (showEvent) {\n      if (showEvent.defaultPrevented) {\n        // only register focus restorer if modal will actually get shown\n        return;\n      }\n      EventHandler.one(target, EVENT_HIDDEN$4, function () {\n        if (isVisible(_this30)) {\n          _this30.focus();\n        }\n      });\n    }); // avoid conflict when clicking modal toggler while another one is open\n\n    var alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);\n    if (alreadyOpen) {\n      Modal.getInstance(alreadyOpen).hide();\n    }\n    var data = Modal.getOrCreateInstance(target);\n    data.toggle(this);\n  });\n  enableDismissTrigger(Modal);\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Modal);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): offcanvas.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  var NAME$6 = 'offcanvas';\n  var DATA_KEY$3 = 'bs.offcanvas';\n  var EVENT_KEY$3 = \".\".concat(DATA_KEY$3);\n  var DATA_API_KEY$1 = '.data-api';\n  var EVENT_LOAD_DATA_API$2 = \"load\".concat(EVENT_KEY$3).concat(DATA_API_KEY$1);\n  var ESCAPE_KEY = 'Escape';\n  var CLASS_NAME_SHOW$3 = 'show';\n  var CLASS_NAME_SHOWING$1 = 'showing';\n  var CLASS_NAME_HIDING = 'hiding';\n  var CLASS_NAME_BACKDROP = 'offcanvas-backdrop';\n  var OPEN_SELECTOR = '.offcanvas.show';\n  var EVENT_SHOW$3 = \"show\".concat(EVENT_KEY$3);\n  var EVENT_SHOWN$3 = \"shown\".concat(EVENT_KEY$3);\n  var EVENT_HIDE$3 = \"hide\".concat(EVENT_KEY$3);\n  var EVENT_HIDE_PREVENTED = \"hidePrevented\".concat(EVENT_KEY$3);\n  var EVENT_HIDDEN$3 = \"hidden\".concat(EVENT_KEY$3);\n  var EVENT_RESIZE = \"resize\".concat(EVENT_KEY$3);\n  var EVENT_CLICK_DATA_API$1 = \"click\".concat(EVENT_KEY$3).concat(DATA_API_KEY$1);\n  var EVENT_KEYDOWN_DISMISS = \"keydown.dismiss\".concat(EVENT_KEY$3);\n  var SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\"offcanvas\"]';\n  var Default$5 = {\n    backdrop: true,\n    keyboard: true,\n    scroll: false\n  };\n  var DefaultType$5 = {\n    backdrop: '(boolean|string)',\n    keyboard: 'boolean',\n    scroll: 'boolean'\n  };\n  /**\n   * Class definition\n   */\n  var Offcanvas = /*#__PURE__*/function (_BaseComponent7) {\n    _inherits(Offcanvas, _BaseComponent7);\n    var _super11 = _createSuper(Offcanvas);\n    function Offcanvas(element, config) {\n      var _this31;\n      _classCallCheck(this, Offcanvas);\n      _this31 = _super11.call(this, element, config);\n      _this31._isShown = false;\n      _this31._backdrop = _this31._initializeBackDrop();\n      _this31._focustrap = _this31._initializeFocusTrap();\n      _this31._addEventListeners();\n      return _this31;\n    } // Getters\n    _createClass(Offcanvas, [{\n      key: \"toggle\",\n      value:\n      // Public\n\n      function toggle(relatedTarget) {\n        return this._isShown ? this.hide() : this.show(relatedTarget);\n      }\n    }, {\n      key: \"show\",\n      value: function show(relatedTarget) {\n        var _this32 = this;\n        if (this._isShown) {\n          return;\n        }\n        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\n          relatedTarget: relatedTarget\n        });\n        if (showEvent.defaultPrevented) {\n          return;\n        }\n        this._isShown = true;\n        this._backdrop.show();\n        if (!this._config.scroll) {\n          new ScrollBarHelper().hide();\n        }\n        this._element.setAttribute('aria-modal', true);\n        this._element.setAttribute('role', 'dialog');\n        this._element.classList.add(CLASS_NAME_SHOWING$1);\n        var completeCallBack = function completeCallBack() {\n          if (!_this32._config.scroll || _this32._config.backdrop) {\n            _this32._focustrap.activate();\n          }\n          _this32._element.classList.add(CLASS_NAME_SHOW$3);\n          _this32._element.classList.remove(CLASS_NAME_SHOWING$1);\n          EventHandler.trigger(_this32._element, EVENT_SHOWN$3, {\n            relatedTarget: relatedTarget\n          });\n        };\n        this._queueCallback(completeCallBack, this._element, true);\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var _this33 = this;\n        if (!this._isShown) {\n          return;\n        }\n        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\n        if (hideEvent.defaultPrevented) {\n          return;\n        }\n        this._focustrap.deactivate();\n        this._element.blur();\n        this._isShown = false;\n        this._element.classList.add(CLASS_NAME_HIDING);\n        this._backdrop.hide();\n        var completeCallback = function completeCallback() {\n          _this33._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);\n          _this33._element.removeAttribute('aria-modal');\n          _this33._element.removeAttribute('role');\n          if (!_this33._config.scroll) {\n            new ScrollBarHelper().reset();\n          }\n          EventHandler.trigger(_this33._element, EVENT_HIDDEN$3);\n        };\n        this._queueCallback(completeCallback, this._element, true);\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        this._backdrop.dispose();\n        this._focustrap.deactivate();\n        _get(_getPrototypeOf(Offcanvas.prototype), \"dispose\", this).call(this);\n      } // Private\n    }, {\n      key: \"_initializeBackDrop\",\n      value: function _initializeBackDrop() {\n        var _this34 = this;\n        var clickCallback = function clickCallback() {\n          if (_this34._config.backdrop === 'static') {\n            EventHandler.trigger(_this34._element, EVENT_HIDE_PREVENTED);\n            return;\n          }\n          _this34.hide();\n        }; // 'static' option will be translated to true, and booleans will keep their value\n\n        var isVisible = Boolean(this._config.backdrop);\n        return new Backdrop({\n          className: CLASS_NAME_BACKDROP,\n          isVisible: isVisible,\n          isAnimated: true,\n          rootElement: this._element.parentNode,\n          clickCallback: isVisible ? clickCallback : null\n        });\n      }\n    }, {\n      key: \"_initializeFocusTrap\",\n      value: function _initializeFocusTrap() {\n        return new FocusTrap({\n          trapElement: this._element\n        });\n      }\n    }, {\n      key: \"_addEventListeners\",\n      value: function _addEventListeners() {\n        var _this35 = this;\n        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, function (event) {\n          if (event.key !== ESCAPE_KEY) {\n            return;\n          }\n          if (!_this35._config.keyboard) {\n            EventHandler.trigger(_this35._element, EVENT_HIDE_PREVENTED);\n            return;\n          }\n          _this35.hide();\n        });\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$5;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$5;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$6;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Offcanvas.getOrCreateInstance(this, config);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config](this);\n        });\n      }\n    }]);\n    return Offcanvas;\n  }(BaseComponent);\n  /**\n   * Data API implementation\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {\n    var _this36 = this;\n    var target = getElementFromSelector(this);\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n    if (isDisabled(this)) {\n      return;\n    }\n    EventHandler.one(target, EVENT_HIDDEN$3, function () {\n      // focus on trigger when it is closed\n      if (isVisible(_this36)) {\n        _this36.focus();\n      }\n    }); // avoid conflict when clicking a toggler of an offcanvas, while another is open\n\n    var alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);\n    if (alreadyOpen && alreadyOpen !== target) {\n      Offcanvas.getInstance(alreadyOpen).hide();\n    }\n    var data = Offcanvas.getOrCreateInstance(target);\n    data.toggle(this);\n  });\n  EventHandler.on(window, EVENT_LOAD_DATA_API$2, function () {\n    var _iterator17 = _createForOfIteratorHelper(SelectorEngine.find(OPEN_SELECTOR)),\n      _step17;\n    try {\n      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n        var selector = _step17.value;\n        Offcanvas.getOrCreateInstance(selector).show();\n      }\n    } catch (err) {\n      _iterator17.e(err);\n    } finally {\n      _iterator17.f();\n    }\n  });\n  EventHandler.on(window, EVENT_RESIZE, function () {\n    var _iterator18 = _createForOfIteratorHelper(SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')),\n      _step18;\n    try {\n      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n        var element = _step18.value;\n        if (getComputedStyle(element).position !== 'fixed') {\n          Offcanvas.getOrCreateInstance(element).hide();\n        }\n      }\n    } catch (err) {\n      _iterator18.e(err);\n    } finally {\n      _iterator18.f();\n    }\n  });\n  enableDismissTrigger(Offcanvas);\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Offcanvas);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): util/sanitizer.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  var uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);\n  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n  /**\n   * A pattern that recognizes a commonly useful subset of URLs that are safe.\n   *\n   * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;\n  /**\n   * A pattern that matches safe data URLs. Only matches image, video and audio types.\n   *\n   * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  var DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i;\n  var allowedAttribute = function allowedAttribute(attribute, allowedAttributeList) {\n    var attributeName = attribute.nodeName.toLowerCase();\n    if (allowedAttributeList.includes(attributeName)) {\n      if (uriAttributes.has(attributeName)) {\n        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));\n      }\n      return true;\n    } // Check if a regular expression validates the attribute.\n\n    return allowedAttributeList.filter(function (attributeRegex) {\n      return attributeRegex instanceof RegExp;\n    }).some(function (regex) {\n      return regex.test(attributeName);\n    });\n  };\n  var DefaultAllowlist = {\n    // Global attributes allowed on any supplied element below.\n    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n    a: ['target', 'href', 'title', 'rel'],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    div: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n  };\n  function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {\n    var _ref12;\n    if (!unsafeHtml.length) {\n      return unsafeHtml;\n    }\n    if (sanitizeFunction && typeof sanitizeFunction === 'function') {\n      return sanitizeFunction(unsafeHtml);\n    }\n    var domParser = new window.DOMParser();\n    var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\n    var elements = (_ref12 = []).concat.apply(_ref12, _toConsumableArray(createdDocument.body.querySelectorAll('*')));\n    var _iterator19 = _createForOfIteratorHelper(elements),\n      _step19;\n    try {\n      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n        var _ref13;\n        var element = _step19.value;\n        var elementName = element.nodeName.toLowerCase();\n        if (!Object.keys(allowList).includes(elementName)) {\n          element.remove();\n          continue;\n        }\n        var attributeList = (_ref13 = []).concat.apply(_ref13, _toConsumableArray(element.attributes));\n        var allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);\n        var _iterator20 = _createForOfIteratorHelper(attributeList),\n          _step20;\n        try {\n          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n            var attribute = _step20.value;\n            if (!allowedAttribute(attribute, allowedAttributes)) {\n              element.removeAttribute(attribute.nodeName);\n            }\n          }\n        } catch (err) {\n          _iterator20.e(err);\n        } finally {\n          _iterator20.f();\n        }\n      }\n    } catch (err) {\n      _iterator19.e(err);\n    } finally {\n      _iterator19.f();\n    }\n    return createdDocument.body.innerHTML;\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): util/template-factory.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  var NAME$5 = 'TemplateFactory';\n  var Default$4 = {\n    allowList: DefaultAllowlist,\n    content: {},\n    // { selector : text ,  selector2 : text2 , }\n    extraClass: '',\n    html: false,\n    sanitize: true,\n    sanitizeFn: null,\n    template: '<div></div>'\n  };\n  var DefaultType$4 = {\n    allowList: 'object',\n    content: 'object',\n    extraClass: '(string|function)',\n    html: 'boolean',\n    sanitize: 'boolean',\n    sanitizeFn: '(null|function)',\n    template: 'string'\n  };\n  var DefaultContentType = {\n    entry: '(string|element|function|null)',\n    selector: '(string|element)'\n  };\n  /**\n   * Class definition\n   */\n  var TemplateFactory = /*#__PURE__*/function (_Config5) {\n    _inherits(TemplateFactory, _Config5);\n    var _super12 = _createSuper(TemplateFactory);\n    function TemplateFactory(config) {\n      var _this37;\n      _classCallCheck(this, TemplateFactory);\n      _this37 = _super12.call(this);\n      _this37._config = _this37._getConfig(config);\n      return _this37;\n    } // Getters\n    _createClass(TemplateFactory, [{\n      key: \"getContent\",\n      value:\n      // Public\n\n      function getContent() {\n        var _this38 = this;\n        return Object.values(this._config.content).map(function (config) {\n          return _this38._resolvePossibleFunction(config);\n        }).filter(Boolean);\n      }\n    }, {\n      key: \"hasContent\",\n      value: function hasContent() {\n        return this.getContent().length > 0;\n      }\n    }, {\n      key: \"changeContent\",\n      value: function changeContent(content) {\n        this._checkContent(content);\n        this._config.content = _objectSpread(_objectSpread({}, this._config.content), content);\n        return this;\n      }\n    }, {\n      key: \"toHtml\",\n      value: function toHtml() {\n        var templateWrapper = document.createElement('div');\n        templateWrapper.innerHTML = this._maybeSanitize(this._config.template);\n        for (var _i8 = 0, _Object$entries2 = Object.entries(this._config.content); _i8 < _Object$entries2.length; _i8++) {\n          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i8], 2),\n            selector = _Object$entries2$_i[0],\n            text = _Object$entries2$_i[1];\n          this._setContent(templateWrapper, text, selector);\n        }\n        var template = templateWrapper.children[0];\n        var extraClass = this._resolvePossibleFunction(this._config.extraClass);\n        if (extraClass) {\n          var _template$classList;\n          (_template$classList = template.classList).add.apply(_template$classList, _toConsumableArray(extraClass.split(' ')));\n        }\n        return template;\n      } // Private\n    }, {\n      key: \"_typeCheckConfig\",\n      value: function _typeCheckConfig(config) {\n        _get(_getPrototypeOf(TemplateFactory.prototype), \"_typeCheckConfig\", this).call(this, config);\n        this._checkContent(config.content);\n      }\n    }, {\n      key: \"_checkContent\",\n      value: function _checkContent(arg) {\n        for (var _i9 = 0, _Object$entries3 = Object.entries(arg); _i9 < _Object$entries3.length; _i9++) {\n          var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i9], 2),\n            selector = _Object$entries3$_i[0],\n            content = _Object$entries3$_i[1];\n          _get(_getPrototypeOf(TemplateFactory.prototype), \"_typeCheckConfig\", this).call(this, {\n            selector: selector,\n            entry: content\n          }, DefaultContentType);\n        }\n      }\n    }, {\n      key: \"_setContent\",\n      value: function _setContent(template, content, selector) {\n        var templateElement = SelectorEngine.findOne(selector, template);\n        if (!templateElement) {\n          return;\n        }\n        content = this._resolvePossibleFunction(content);\n        if (!content) {\n          templateElement.remove();\n          return;\n        }\n        if (isElement$1(content)) {\n          this._putElementInTemplate(getElement(content), templateElement);\n          return;\n        }\n        if (this._config.html) {\n          templateElement.innerHTML = this._maybeSanitize(content);\n          return;\n        }\n        templateElement.textContent = content;\n      }\n    }, {\n      key: \"_maybeSanitize\",\n      value: function _maybeSanitize(arg) {\n        return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;\n      }\n    }, {\n      key: \"_resolvePossibleFunction\",\n      value: function _resolvePossibleFunction(arg) {\n        return typeof arg === 'function' ? arg(this) : arg;\n      }\n    }, {\n      key: \"_putElementInTemplate\",\n      value: function _putElementInTemplate(element, templateElement) {\n        if (this._config.html) {\n          templateElement.innerHTML = '';\n          templateElement.append(element);\n          return;\n        }\n        templateElement.textContent = element.textContent;\n      }\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$4;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$4;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$5;\n      }\n    }]);\n    return TemplateFactory;\n  }(Config);\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): tooltip.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n  var NAME$4 = 'tooltip';\n  var DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);\n  var CLASS_NAME_FADE$2 = 'fade';\n  var CLASS_NAME_MODAL = 'modal';\n  var CLASS_NAME_SHOW$2 = 'show';\n  var SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\n  var SELECTOR_MODAL = \".\".concat(CLASS_NAME_MODAL);\n  var EVENT_MODAL_HIDE = 'hide.bs.modal';\n  var TRIGGER_HOVER = 'hover';\n  var TRIGGER_FOCUS = 'focus';\n  var TRIGGER_CLICK = 'click';\n  var TRIGGER_MANUAL = 'manual';\n  var EVENT_HIDE$2 = 'hide';\n  var EVENT_HIDDEN$2 = 'hidden';\n  var EVENT_SHOW$2 = 'show';\n  var EVENT_SHOWN$2 = 'shown';\n  var EVENT_INSERTED = 'inserted';\n  var EVENT_CLICK$1 = 'click';\n  var EVENT_FOCUSIN$1 = 'focusin';\n  var EVENT_FOCUSOUT$1 = 'focusout';\n  var EVENT_MOUSEENTER = 'mouseenter';\n  var EVENT_MOUSELEAVE = 'mouseleave';\n  var AttachmentMap = {\n    AUTO: 'auto',\n    TOP: 'top',\n    RIGHT: isRTL() ? 'left' : 'right',\n    BOTTOM: 'bottom',\n    LEFT: isRTL() ? 'right' : 'left'\n  };\n  var Default$3 = {\n    allowList: DefaultAllowlist,\n    animation: true,\n    boundary: 'clippingParents',\n    container: false,\n    customClass: '',\n    delay: 0,\n    fallbackPlacements: ['top', 'right', 'bottom', 'left'],\n    html: false,\n    offset: [0, 0],\n    placement: 'top',\n    popperConfig: null,\n    sanitize: true,\n    sanitizeFn: null,\n    selector: false,\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-arrow\"></div>' + '<div class=\"tooltip-inner\"></div>' + '</div>',\n    title: '',\n    trigger: 'hover focus'\n  };\n  var DefaultType$3 = {\n    allowList: 'object',\n    animation: 'boolean',\n    boundary: '(string|element)',\n    container: '(string|element|boolean)',\n    customClass: '(string|function)',\n    delay: '(number|object)',\n    fallbackPlacements: 'array',\n    html: 'boolean',\n    offset: '(array|string|function)',\n    placement: '(string|function)',\n    popperConfig: '(null|object|function)',\n    sanitize: 'boolean',\n    sanitizeFn: '(null|function)',\n    selector: '(string|boolean)',\n    template: 'string',\n    title: '(string|element|function)',\n    trigger: 'string'\n  };\n  /**\n   * Class definition\n   */\n  var Tooltip = /*#__PURE__*/function (_BaseComponent8) {\n    _inherits(Tooltip, _BaseComponent8);\n    var _super13 = _createSuper(Tooltip);\n    function Tooltip(element, config) {\n      var _this39;\n      _classCallCheck(this, Tooltip);\n      if (typeof Popper === 'undefined') {\n        throw new TypeError('Bootstrap\\'s tooltips require Popper (https://popper.js.org)');\n      }\n      _this39 = _super13.call(this, element, config); // Private\n\n      _this39._isEnabled = true;\n      _this39._timeout = 0;\n      _this39._isHovered = null;\n      _this39._activeTrigger = {};\n      _this39._popper = null;\n      _this39._templateFactory = null;\n      _this39._newContent = null; // Protected\n\n      _this39.tip = null;\n      _this39._setListeners();\n      if (!_this39._config.selector) {\n        _this39._fixTitle();\n      }\n      return _this39;\n    } // Getters\n    _createClass(Tooltip, [{\n      key: \"enable\",\n      value:\n      // Public\n\n      function enable() {\n        this._isEnabled = true;\n      }\n    }, {\n      key: \"disable\",\n      value: function disable() {\n        this._isEnabled = false;\n      }\n    }, {\n      key: \"toggleEnabled\",\n      value: function toggleEnabled() {\n        this._isEnabled = !this._isEnabled;\n      }\n    }, {\n      key: \"toggle\",\n      value: function toggle() {\n        if (!this._isEnabled) {\n          return;\n        }\n        this._activeTrigger.click = !this._activeTrigger.click;\n        if (this._isShown()) {\n          this._leave();\n          return;\n        }\n        this._enter();\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        clearTimeout(this._timeout);\n        EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n        if (this._element.getAttribute('data-bs-original-title')) {\n          this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title'));\n        }\n        this._disposePopper();\n        _get(_getPrototypeOf(Tooltip.prototype), \"dispose\", this).call(this);\n      }\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this40 = this;\n        if (this._element.style.display === 'none') {\n          throw new Error('Please use show on visible elements');\n        }\n        if (!(this._isWithContent() && this._isEnabled)) {\n          return;\n        }\n        var showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));\n        var shadowRoot = findShadowRoot(this._element);\n        var isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);\n        if (showEvent.defaultPrevented || !isInTheDom) {\n          return;\n        } // todo v6 remove this OR make it optional\n\n        this._disposePopper();\n        var tip = this._getTipElement();\n        this._element.setAttribute('aria-describedby', tip.getAttribute('id'));\n        var container = this._config.container;\n        if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\n          container.append(tip);\n          EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));\n        }\n        this._popper = this._createPopper(tip);\n        tip.classList.add(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n        if ('ontouchstart' in document.documentElement) {\n          var _ref14;\n          var _iterator21 = _createForOfIteratorHelper((_ref14 = []).concat.apply(_ref14, _toConsumableArray(document.body.children))),\n            _step21;\n          try {\n            for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n              var element = _step21.value;\n              EventHandler.on(element, 'mouseover', noop);\n            }\n          } catch (err) {\n            _iterator21.e(err);\n          } finally {\n            _iterator21.f();\n          }\n        }\n        var complete = function complete() {\n          EventHandler.trigger(_this40._element, _this40.constructor.eventName(EVENT_SHOWN$2));\n          if (_this40._isHovered === false) {\n            _this40._leave();\n          }\n          _this40._isHovered = false;\n        };\n        this._queueCallback(complete, this.tip, this._isAnimated());\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var _this41 = this;\n        if (!this._isShown()) {\n          return;\n        }\n        var hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));\n        if (hideEvent.defaultPrevented) {\n          return;\n        }\n        var tip = this._getTipElement();\n        tip.classList.remove(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n\n        if ('ontouchstart' in document.documentElement) {\n          var _ref15;\n          var _iterator22 = _createForOfIteratorHelper((_ref15 = []).concat.apply(_ref15, _toConsumableArray(document.body.children))),\n            _step22;\n          try {\n            for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n              var element = _step22.value;\n              EventHandler.off(element, 'mouseover', noop);\n            }\n          } catch (err) {\n            _iterator22.e(err);\n          } finally {\n            _iterator22.f();\n          }\n        }\n        this._activeTrigger[TRIGGER_CLICK] = false;\n        this._activeTrigger[TRIGGER_FOCUS] = false;\n        this._activeTrigger[TRIGGER_HOVER] = false;\n        this._isHovered = null; // it is a trick to support manual triggering\n\n        var complete = function complete() {\n          if (_this41._isWithActiveTrigger()) {\n            return;\n          }\n          if (!_this41._isHovered) {\n            _this41._disposePopper();\n          }\n          _this41._element.removeAttribute('aria-describedby');\n          EventHandler.trigger(_this41._element, _this41.constructor.eventName(EVENT_HIDDEN$2));\n        };\n        this._queueCallback(complete, this.tip, this._isAnimated());\n      }\n    }, {\n      key: \"update\",\n      value: function update() {\n        if (this._popper) {\n          this._popper.update();\n        }\n      } // Protected\n    }, {\n      key: \"_isWithContent\",\n      value: function _isWithContent() {\n        return Boolean(this._getTitle());\n      }\n    }, {\n      key: \"_getTipElement\",\n      value: function _getTipElement() {\n        if (!this.tip) {\n          this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());\n        }\n        return this.tip;\n      }\n    }, {\n      key: \"_createTipElement\",\n      value: function _createTipElement(content) {\n        var tip = this._getTemplateFactory(content).toHtml(); // todo: remove this check on v6\n\n        if (!tip) {\n          return null;\n        }\n        tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2); // todo: on v6 the following can be achieved with CSS only\n\n        tip.classList.add(\"bs-\".concat(this.constructor.NAME, \"-auto\"));\n        var tipId = getUID(this.constructor.NAME).toString();\n        tip.setAttribute('id', tipId);\n        if (this._isAnimated()) {\n          tip.classList.add(CLASS_NAME_FADE$2);\n        }\n        return tip;\n      }\n    }, {\n      key: \"setContent\",\n      value: function setContent(content) {\n        this._newContent = content;\n        if (this._isShown()) {\n          this._disposePopper();\n          this.show();\n        }\n      }\n    }, {\n      key: \"_getTemplateFactory\",\n      value: function _getTemplateFactory(content) {\n        if (this._templateFactory) {\n          this._templateFactory.changeContent(content);\n        } else {\n          this._templateFactory = new TemplateFactory(_objectSpread(_objectSpread({}, this._config), {}, {\n            // the `content` var has to be after `this._config`\n            // to override config.content in case of popover\n            content: content,\n            extraClass: this._resolvePossibleFunction(this._config.customClass)\n          }));\n        }\n        return this._templateFactory;\n      }\n    }, {\n      key: \"_getContentForTemplate\",\n      value: function _getContentForTemplate() {\n        return _defineProperty({}, SELECTOR_TOOLTIP_INNER, this._getTitle());\n      }\n    }, {\n      key: \"_getTitle\",\n      value: function _getTitle() {\n        return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title');\n      } // Private\n    }, {\n      key: \"_initializeOnDelegatedTarget\",\n      value: function _initializeOnDelegatedTarget(event) {\n        return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());\n      }\n    }, {\n      key: \"_isAnimated\",\n      value: function _isAnimated() {\n        return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);\n      }\n    }, {\n      key: \"_isShown\",\n      value: function _isShown() {\n        return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);\n      }\n    }, {\n      key: \"_createPopper\",\n      value: function _createPopper(tip) {\n        var placement = typeof this._config.placement === 'function' ? this._config.placement.call(this, tip, this._element) : this._config.placement;\n        var attachment = AttachmentMap[placement.toUpperCase()];\n        return createPopper(this._element, tip, this._getPopperConfig(attachment));\n      }\n    }, {\n      key: \"_getOffset\",\n      value: function _getOffset() {\n        var _this42 = this;\n        var offset = this._config.offset;\n        if (typeof offset === 'string') {\n          return offset.split(',').map(function (value) {\n            return Number.parseInt(value, 10);\n          });\n        }\n        if (typeof offset === 'function') {\n          return function (popperData) {\n            return offset(popperData, _this42._element);\n          };\n        }\n        return offset;\n      }\n    }, {\n      key: \"_resolvePossibleFunction\",\n      value: function _resolvePossibleFunction(arg) {\n        return typeof arg === 'function' ? arg.call(this._element) : arg;\n      }\n    }, {\n      key: \"_getPopperConfig\",\n      value: function _getPopperConfig(attachment) {\n        var _this43 = this;\n        var defaultBsPopperConfig = {\n          placement: attachment,\n          modifiers: [{\n            name: 'flip',\n            options: {\n              fallbackPlacements: this._config.fallbackPlacements\n            }\n          }, {\n            name: 'offset',\n            options: {\n              offset: this._getOffset()\n            }\n          }, {\n            name: 'preventOverflow',\n            options: {\n              boundary: this._config.boundary\n            }\n          }, {\n            name: 'arrow',\n            options: {\n              element: \".\".concat(this.constructor.NAME, \"-arrow\")\n            }\n          }, {\n            name: 'preSetPlacement',\n            enabled: true,\n            phase: 'beforeMain',\n            fn: function fn(data) {\n              // Pre-set Popper's placement attribute in order to read the arrow sizes properly.\n              // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement\n              _this43._getTipElement().setAttribute('data-popper-placement', data.state.placement);\n            }\n          }]\n        };\n        return _objectSpread(_objectSpread({}, defaultBsPopperConfig), typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig);\n      }\n    }, {\n      key: \"_setListeners\",\n      value: function _setListeners() {\n        var _this44 = this;\n        var triggers = this._config.trigger.split(' ');\n        var _iterator23 = _createForOfIteratorHelper(triggers),\n          _step23;\n        try {\n          for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n            var trigger = _step23.value;\n            if (trigger === 'click') {\n              EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, function (event) {\n                var context = _this44._initializeOnDelegatedTarget(event);\n                context.toggle();\n              });\n            } else if (trigger !== TRIGGER_MANUAL) {\n              var eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);\n              var eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);\n              EventHandler.on(this._element, eventIn, this._config.selector, function (event) {\n                var context = _this44._initializeOnDelegatedTarget(event);\n                context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n                context._enter();\n              });\n              EventHandler.on(this._element, eventOut, this._config.selector, function (event) {\n                var context = _this44._initializeOnDelegatedTarget(event);\n                context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\n                context._leave();\n              });\n            }\n          }\n        } catch (err) {\n          _iterator23.e(err);\n        } finally {\n          _iterator23.f();\n        }\n        this._hideModalHandler = function () {\n          if (_this44._element) {\n            _this44.hide();\n          }\n        };\n        EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n      }\n    }, {\n      key: \"_fixTitle\",\n      value: function _fixTitle() {\n        var title = this._element.getAttribute('title');\n        if (!title) {\n          return;\n        }\n        if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {\n          this._element.setAttribute('aria-label', title);\n        }\n        this._element.setAttribute('data-bs-original-title', title); // DO NOT USE IT. Is only for backwards compatibility\n\n        this._element.removeAttribute('title');\n      }\n    }, {\n      key: \"_enter\",\n      value: function _enter() {\n        var _this45 = this;\n        if (this._isShown() || this._isHovered) {\n          this._isHovered = true;\n          return;\n        }\n        this._isHovered = true;\n        this._setTimeout(function () {\n          if (_this45._isHovered) {\n            _this45.show();\n          }\n        }, this._config.delay.show);\n      }\n    }, {\n      key: \"_leave\",\n      value: function _leave() {\n        var _this46 = this;\n        if (this._isWithActiveTrigger()) {\n          return;\n        }\n        this._isHovered = false;\n        this._setTimeout(function () {\n          if (!_this46._isHovered) {\n            _this46.hide();\n          }\n        }, this._config.delay.hide);\n      }\n    }, {\n      key: \"_setTimeout\",\n      value: function _setTimeout(handler, timeout) {\n        clearTimeout(this._timeout);\n        this._timeout = setTimeout(handler, timeout);\n      }\n    }, {\n      key: \"_isWithActiveTrigger\",\n      value: function _isWithActiveTrigger() {\n        return Object.values(this._activeTrigger).includes(true);\n      }\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        var dataAttributes = Manipulator.getDataAttributes(this._element);\n        for (var _i10 = 0, _Object$keys5 = Object.keys(dataAttributes); _i10 < _Object$keys5.length; _i10++) {\n          var dataAttribute = _Object$keys5[_i10];\n          if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {\n            delete dataAttributes[dataAttribute];\n          }\n        }\n        config = _objectSpread(_objectSpread({}, dataAttributes), _typeof(config) === 'object' && config ? config : {});\n        config = this._mergeConfigObj(config);\n        config = this._configAfterMerge(config);\n        this._typeCheckConfig(config);\n        return config;\n      }\n    }, {\n      key: \"_configAfterMerge\",\n      value: function _configAfterMerge(config) {\n        config.container = config.container === false ? document.body : getElement(config.container);\n        if (typeof config.delay === 'number') {\n          config.delay = {\n            show: config.delay,\n            hide: config.delay\n          };\n        }\n        if (typeof config.title === 'number') {\n          config.title = config.title.toString();\n        }\n        if (typeof config.content === 'number') {\n          config.content = config.content.toString();\n        }\n        return config;\n      }\n    }, {\n      key: \"_getDelegateConfig\",\n      value: function _getDelegateConfig() {\n        var config = {};\n        for (var key in this._config) {\n          if (this.constructor.Default[key] !== this._config[key]) {\n            config[key] = this._config[key];\n          }\n        }\n        config.selector = false;\n        config.trigger = 'manual'; // In the future can be replaced with:\n        // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])\n        // `Object.fromEntries(keysWithDifferentValues)`\n\n        return config;\n      }\n    }, {\n      key: \"_disposePopper\",\n      value: function _disposePopper() {\n        if (this._popper) {\n          this._popper.destroy();\n          this._popper = null;\n        }\n        if (this.tip) {\n          this.tip.remove();\n          this.tip = null;\n        }\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$3;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$3;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$4;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Tooltip.getOrCreateInstance(this, config);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        });\n      }\n    }]);\n    return Tooltip;\n  }(BaseComponent);\n  /**\n   * jQuery\n   */\n  defineJQueryPlugin(Tooltip);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): popover.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  var NAME$3 = 'popover';\n  var SELECTOR_TITLE = '.popover-header';\n  var SELECTOR_CONTENT = '.popover-body';\n  var Default$2 = _objectSpread(_objectSpread({}, Tooltip.Default), {}, {\n    content: '',\n    offset: [0, 8],\n    placement: 'right',\n    template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"popover-arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div>' + '</div>',\n    trigger: 'click'\n  });\n  var DefaultType$2 = _objectSpread(_objectSpread({}, Tooltip.DefaultType), {}, {\n    content: '(null|string|element|function)'\n  });\n  /**\n   * Class definition\n   */\n  var Popover = /*#__PURE__*/function (_Tooltip) {\n    _inherits(Popover, _Tooltip);\n    var _super14 = _createSuper(Popover);\n    function Popover() {\n      _classCallCheck(this, Popover);\n      return _super14.apply(this, arguments);\n    }\n    _createClass(Popover, [{\n      key: \"_isWithContent\",\n      value:\n      // Overrides\n\n      function _isWithContent() {\n        return this._getTitle() || this._getContent();\n      } // Private\n    }, {\n      key: \"_getContentForTemplate\",\n      value: function _getContentForTemplate() {\n        var _ref17;\n        return _ref17 = {}, _defineProperty(_ref17, SELECTOR_TITLE, this._getTitle()), _defineProperty(_ref17, SELECTOR_CONTENT, this._getContent()), _ref17;\n      }\n    }, {\n      key: \"_getContent\",\n      value: function _getContent() {\n        return this._resolvePossibleFunction(this._config.content);\n      } // Static\n    }], [{\n      key: \"Default\",\n      get:\n      // Getters\n      function get() {\n        return Default$2;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$2;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$3;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Popover.getOrCreateInstance(this, config);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        });\n      }\n    }]);\n    return Popover;\n  }(Tooltip);\n  /**\n   * jQuery\n   */\n  defineJQueryPlugin(Popover);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): scrollspy.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  var NAME$2 = 'scrollspy';\n  var DATA_KEY$2 = 'bs.scrollspy';\n  var EVENT_KEY$2 = \".\".concat(DATA_KEY$2);\n  var DATA_API_KEY = '.data-api';\n  var EVENT_ACTIVATE = \"activate\".concat(EVENT_KEY$2);\n  var EVENT_CLICK = \"click\".concat(EVENT_KEY$2);\n  var EVENT_LOAD_DATA_API$1 = \"load\".concat(EVENT_KEY$2).concat(DATA_API_KEY);\n  var CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';\n  var CLASS_NAME_ACTIVE$1 = 'active';\n  var SELECTOR_DATA_SPY = '[data-bs-spy=\"scroll\"]';\n  var SELECTOR_TARGET_LINKS = '[href]';\n  var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\n  var SELECTOR_NAV_LINKS = '.nav-link';\n  var SELECTOR_NAV_ITEMS = '.nav-item';\n  var SELECTOR_LIST_ITEMS = '.list-group-item';\n  var SELECTOR_LINK_ITEMS = \"\".concat(SELECTOR_NAV_LINKS, \", \").concat(SELECTOR_NAV_ITEMS, \" > \").concat(SELECTOR_NAV_LINKS, \", \").concat(SELECTOR_LIST_ITEMS);\n  var SELECTOR_DROPDOWN = '.dropdown';\n  var SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';\n  var Default$1 = {\n    offset: null,\n    // TODO: v6 @deprecated, keep it for backwards compatibility reasons\n    rootMargin: '0px 0px -25%',\n    smoothScroll: false,\n    target: null,\n    threshold: [0.1, 0.5, 1]\n  };\n  var DefaultType$1 = {\n    offset: '(number|null)',\n    // TODO v6 @deprecated, keep it for backwards compatibility reasons\n    rootMargin: 'string',\n    smoothScroll: 'boolean',\n    target: 'element',\n    threshold: 'array'\n  };\n  /**\n   * Class definition\n   */\n  var ScrollSpy = /*#__PURE__*/function (_BaseComponent9) {\n    _inherits(ScrollSpy, _BaseComponent9);\n    var _super15 = _createSuper(ScrollSpy);\n    function ScrollSpy(element, config) {\n      var _this47;\n      _classCallCheck(this, ScrollSpy);\n      _this47 = _super15.call(this, element, config); // this._element is the observablesContainer and config.target the menu links wrapper\n\n      _this47._targetLinks = new Map();\n      _this47._observableSections = new Map();\n      _this47._rootElement = getComputedStyle(_this47._element).overflowY === 'visible' ? null : _this47._element;\n      _this47._activeTarget = null;\n      _this47._observer = null;\n      _this47._previousScrollData = {\n        visibleEntryTop: 0,\n        parentScrollTop: 0\n      };\n      _this47.refresh(); // initialize\n      return _this47;\n    } // Getters\n    _createClass(ScrollSpy, [{\n      key: \"refresh\",\n      value:\n      // Public\n\n      function refresh() {\n        this._initializeTargetsAndObservables();\n        this._maybeEnableSmoothScroll();\n        if (this._observer) {\n          this._observer.disconnect();\n        } else {\n          this._observer = this._getNewObserver();\n        }\n        var _iterator24 = _createForOfIteratorHelper(this._observableSections.values()),\n          _step24;\n        try {\n          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n            var section = _step24.value;\n            this._observer.observe(section);\n          }\n        } catch (err) {\n          _iterator24.e(err);\n        } finally {\n          _iterator24.f();\n        }\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        this._observer.disconnect();\n        _get(_getPrototypeOf(ScrollSpy.prototype), \"dispose\", this).call(this);\n      } // Private\n    }, {\n      key: \"_configAfterMerge\",\n      value: function _configAfterMerge(config) {\n        // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case\n        config.target = getElement(config.target) || document.body; // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only\n\n        config.rootMargin = config.offset ? \"\".concat(config.offset, \"px 0px -30%\") : config.rootMargin;\n        if (typeof config.threshold === 'string') {\n          config.threshold = config.threshold.split(',').map(function (value) {\n            return Number.parseFloat(value);\n          });\n        }\n        return config;\n      }\n    }, {\n      key: \"_maybeEnableSmoothScroll\",\n      value: function _maybeEnableSmoothScroll() {\n        var _this48 = this;\n        if (!this._config.smoothScroll) {\n          return;\n        } // unregister any previous listeners\n\n        EventHandler.off(this._config.target, EVENT_CLICK);\n        EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, function (event) {\n          var observableSection = _this48._observableSections.get(event.target.hash);\n          if (observableSection) {\n            event.preventDefault();\n            var root = _this48._rootElement || window;\n            var height = observableSection.offsetTop - _this48._element.offsetTop;\n            if (root.scrollTo) {\n              root.scrollTo({\n                top: height,\n                behavior: 'smooth'\n              });\n              return;\n            } // Chrome 60 doesn't support `scrollTo`\n\n            root.scrollTop = height;\n          }\n        });\n      }\n    }, {\n      key: \"_getNewObserver\",\n      value: function _getNewObserver() {\n        var _this49 = this;\n        var options = {\n          root: this._rootElement,\n          threshold: this._config.threshold,\n          rootMargin: this._config.rootMargin\n        };\n        return new IntersectionObserver(function (entries) {\n          return _this49._observerCallback(entries);\n        }, options);\n      } // The logic of selection\n    }, {\n      key: \"_observerCallback\",\n      value: function _observerCallback(entries) {\n        var _this50 = this;\n        var targetElement = function targetElement(entry) {\n          return _this50._targetLinks.get(\"#\".concat(entry.target.id));\n        };\n        var activate = function activate(entry) {\n          _this50._previousScrollData.visibleEntryTop = entry.target.offsetTop;\n          _this50._process(targetElement(entry));\n        };\n        var parentScrollTop = (this._rootElement || document.documentElement).scrollTop;\n        var userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;\n        this._previousScrollData.parentScrollTop = parentScrollTop;\n        var _iterator25 = _createForOfIteratorHelper(entries),\n          _step25;\n        try {\n          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n            var entry = _step25.value;\n            if (!entry.isIntersecting) {\n              this._activeTarget = null;\n              this._clearActiveClass(targetElement(entry));\n              continue;\n            }\n            var entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop; // if we are scrolling down, pick the bigger offsetTop\n\n            if (userScrollsDown && entryIsLowerThanPrevious) {\n              activate(entry); // if parent isn't scrolled, let's keep the first visible item, breaking the iteration\n\n              if (!parentScrollTop) {\n                return;\n              }\n              continue;\n            } // if we are scrolling up, pick the smallest offsetTop\n\n            if (!userScrollsDown && !entryIsLowerThanPrevious) {\n              activate(entry);\n            }\n          }\n        } catch (err) {\n          _iterator25.e(err);\n        } finally {\n          _iterator25.f();\n        }\n      }\n    }, {\n      key: \"_initializeTargetsAndObservables\",\n      value: function _initializeTargetsAndObservables() {\n        this._targetLinks = new Map();\n        this._observableSections = new Map();\n        var targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);\n        var _iterator26 = _createForOfIteratorHelper(targetLinks),\n          _step26;\n        try {\n          for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n            var anchor = _step26.value;\n            // ensure that the anchor has an id and is not disabled\n            if (!anchor.hash || isDisabled(anchor)) {\n              continue;\n            }\n            var observableSection = SelectorEngine.findOne(anchor.hash, this._element); // ensure that the observableSection exists & is visible\n\n            if (isVisible(observableSection)) {\n              this._targetLinks.set(anchor.hash, anchor);\n              this._observableSections.set(anchor.hash, observableSection);\n            }\n          }\n        } catch (err) {\n          _iterator26.e(err);\n        } finally {\n          _iterator26.f();\n        }\n      }\n    }, {\n      key: \"_process\",\n      value: function _process(target) {\n        if (this._activeTarget === target) {\n          return;\n        }\n        this._clearActiveClass(this._config.target);\n        this._activeTarget = target;\n        target.classList.add(CLASS_NAME_ACTIVE$1);\n        this._activateParents(target);\n        EventHandler.trigger(this._element, EVENT_ACTIVATE, {\n          relatedTarget: target\n        });\n      }\n    }, {\n      key: \"_activateParents\",\n      value: function _activateParents(target) {\n        // Activate dropdown parents\n        if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\n          SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);\n          return;\n        }\n        var _iterator27 = _createForOfIteratorHelper(SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)),\n          _step27;\n        try {\n          for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n            var listGroup = _step27.value;\n            // Set triggered links parents as active\n            // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n            var _iterator28 = _createForOfIteratorHelper(SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)),\n              _step28;\n            try {\n              for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n                var item = _step28.value;\n                item.classList.add(CLASS_NAME_ACTIVE$1);\n              }\n            } catch (err) {\n              _iterator28.e(err);\n            } finally {\n              _iterator28.f();\n            }\n          }\n        } catch (err) {\n          _iterator27.e(err);\n        } finally {\n          _iterator27.f();\n        }\n      }\n    }, {\n      key: \"_clearActiveClass\",\n      value: function _clearActiveClass(parent) {\n        parent.classList.remove(CLASS_NAME_ACTIVE$1);\n        var activeNodes = SelectorEngine.find(\"\".concat(SELECTOR_TARGET_LINKS, \".\").concat(CLASS_NAME_ACTIVE$1), parent);\n        var _iterator29 = _createForOfIteratorHelper(activeNodes),\n          _step29;\n        try {\n          for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n            var node = _step29.value;\n            node.classList.remove(CLASS_NAME_ACTIVE$1);\n          }\n        } catch (err) {\n          _iterator29.e(err);\n        } finally {\n          _iterator29.f();\n        }\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$1;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$1;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$2;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = ScrollSpy.getOrCreateInstance(this, config);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        });\n      }\n    }]);\n    return ScrollSpy;\n  }(BaseComponent);\n  /**\n   * Data API implementation\n   */\n  EventHandler.on(window, EVENT_LOAD_DATA_API$1, function () {\n    var _iterator30 = _createForOfIteratorHelper(SelectorEngine.find(SELECTOR_DATA_SPY)),\n      _step30;\n    try {\n      for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n        var spy = _step30.value;\n        ScrollSpy.getOrCreateInstance(spy);\n      }\n    } catch (err) {\n      _iterator30.e(err);\n    } finally {\n      _iterator30.f();\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(ScrollSpy);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): tab.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  var NAME$1 = 'tab';\n  var DATA_KEY$1 = 'bs.tab';\n  var EVENT_KEY$1 = \".\".concat(DATA_KEY$1);\n  var EVENT_HIDE$1 = \"hide\".concat(EVENT_KEY$1);\n  var EVENT_HIDDEN$1 = \"hidden\".concat(EVENT_KEY$1);\n  var EVENT_SHOW$1 = \"show\".concat(EVENT_KEY$1);\n  var EVENT_SHOWN$1 = \"shown\".concat(EVENT_KEY$1);\n  var EVENT_CLICK_DATA_API = \"click\".concat(EVENT_KEY$1);\n  var EVENT_KEYDOWN = \"keydown\".concat(EVENT_KEY$1);\n  var EVENT_LOAD_DATA_API = \"load\".concat(EVENT_KEY$1);\n  var ARROW_LEFT_KEY = 'ArrowLeft';\n  var ARROW_RIGHT_KEY = 'ArrowRight';\n  var ARROW_UP_KEY = 'ArrowUp';\n  var ARROW_DOWN_KEY = 'ArrowDown';\n  var CLASS_NAME_ACTIVE = 'active';\n  var CLASS_NAME_FADE$1 = 'fade';\n  var CLASS_NAME_SHOW$1 = 'show';\n  var CLASS_DROPDOWN = 'dropdown';\n  var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\n  var SELECTOR_DROPDOWN_MENU = '.dropdown-menu';\n  var NOT_SELECTOR_DROPDOWN_TOGGLE = ':not(.dropdown-toggle)';\n  var SELECTOR_TAB_PANEL = '.list-group, .nav, [role=\"tablist\"]';\n  var SELECTOR_OUTER = '.nav-item, .list-group-item';\n  var SELECTOR_INNER = \".nav-link\".concat(NOT_SELECTOR_DROPDOWN_TOGGLE, \", .list-group-item\").concat(NOT_SELECTOR_DROPDOWN_TOGGLE, \", [role=\\\"tab\\\"]\").concat(NOT_SELECTOR_DROPDOWN_TOGGLE);\n  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]'; // todo:v6: could be only `tab`\n\n  var SELECTOR_INNER_ELEM = \"\".concat(SELECTOR_INNER, \", \").concat(SELECTOR_DATA_TOGGLE);\n  var SELECTOR_DATA_TOGGLE_ACTIVE = \".\".concat(CLASS_NAME_ACTIVE, \"[data-bs-toggle=\\\"tab\\\"], .\").concat(CLASS_NAME_ACTIVE, \"[data-bs-toggle=\\\"pill\\\"], .\").concat(CLASS_NAME_ACTIVE, \"[data-bs-toggle=\\\"list\\\"]\");\n  /**\n   * Class definition\n   */\n  var Tab = /*#__PURE__*/function (_BaseComponent10) {\n    _inherits(Tab, _BaseComponent10);\n    var _super16 = _createSuper(Tab);\n    function Tab(element) {\n      var _this51;\n      _classCallCheck(this, Tab);\n      _this51 = _super16.call(this, element);\n      _this51._parent = _this51._element.closest(SELECTOR_TAB_PANEL);\n      if (!_this51._parent) {\n        return _possibleConstructorReturn(_this51); // todo: should Throw exception on v6\n        // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)\n      } // Set up initial aria attributes\n\n      _this51._setInitialAttributes(_this51._parent, _this51._getChildren());\n      EventHandler.on(_this51._element, EVENT_KEYDOWN, function (event) {\n        return _this51._keydown(event);\n      });\n      return _this51;\n    } // Getters\n    _createClass(Tab, [{\n      key: \"show\",\n      value:\n      // Public\n\n      function show() {\n        // Shows this elem and deactivate the active sibling if exists\n        var innerElem = this._element;\n        if (this._elemIsActive(innerElem)) {\n          return;\n        } // Search for active tab on same parent to deactivate it\n\n        var active = this._getActiveElem();\n        var hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {\n          relatedTarget: innerElem\n        }) : null;\n        var showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {\n          relatedTarget: active\n        });\n        if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {\n          return;\n        }\n        this._deactivate(active, innerElem);\n        this._activate(innerElem, active);\n      } // Private\n    }, {\n      key: \"_activate\",\n      value: function _activate(element, relatedElem) {\n        var _this52 = this;\n        if (!element) {\n          return;\n        }\n        element.classList.add(CLASS_NAME_ACTIVE);\n        this._activate(getElementFromSelector(element)); // Search and activate/show the proper section\n\n        var complete = function complete() {\n          if (element.getAttribute('role') !== 'tab') {\n            element.classList.add(CLASS_NAME_SHOW$1);\n            return;\n          }\n          element.removeAttribute('tabindex');\n          element.setAttribute('aria-selected', true);\n          _this52._toggleDropDown(element, true);\n          EventHandler.trigger(element, EVENT_SHOWN$1, {\n            relatedTarget: relatedElem\n          });\n        };\n        this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n      }\n    }, {\n      key: \"_deactivate\",\n      value: function _deactivate(element, relatedElem) {\n        var _this53 = this;\n        if (!element) {\n          return;\n        }\n        element.classList.remove(CLASS_NAME_ACTIVE);\n        element.blur();\n        this._deactivate(getElementFromSelector(element)); // Search and deactivate the shown section too\n\n        var complete = function complete() {\n          if (element.getAttribute('role') !== 'tab') {\n            element.classList.remove(CLASS_NAME_SHOW$1);\n            return;\n          }\n          element.setAttribute('aria-selected', false);\n          element.setAttribute('tabindex', '-1');\n          _this53._toggleDropDown(element, false);\n          EventHandler.trigger(element, EVENT_HIDDEN$1, {\n            relatedTarget: relatedElem\n          });\n        };\n        this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n      }\n    }, {\n      key: \"_keydown\",\n      value: function _keydown(event) {\n        if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY].includes(event.key)) {\n          return;\n        }\n        event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page\n\n        event.preventDefault();\n        var isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);\n        var nextActiveElement = getNextActiveElement(this._getChildren().filter(function (element) {\n          return !isDisabled(element);\n        }), event.target, isNext, true);\n        if (nextActiveElement) {\n          nextActiveElement.focus({\n            preventScroll: true\n          });\n          Tab.getOrCreateInstance(nextActiveElement).show();\n        }\n      }\n    }, {\n      key: \"_getChildren\",\n      value: function _getChildren() {\n        // collection of inner elements\n        return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);\n      }\n    }, {\n      key: \"_getActiveElem\",\n      value: function _getActiveElem() {\n        var _this54 = this;\n        return this._getChildren().find(function (child) {\n          return _this54._elemIsActive(child);\n        }) || null;\n      }\n    }, {\n      key: \"_setInitialAttributes\",\n      value: function _setInitialAttributes(parent, children) {\n        this._setAttributeIfNotExists(parent, 'role', 'tablist');\n        var _iterator31 = _createForOfIteratorHelper(children),\n          _step31;\n        try {\n          for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n            var child = _step31.value;\n            this._setInitialAttributesOnChild(child);\n          }\n        } catch (err) {\n          _iterator31.e(err);\n        } finally {\n          _iterator31.f();\n        }\n      }\n    }, {\n      key: \"_setInitialAttributesOnChild\",\n      value: function _setInitialAttributesOnChild(child) {\n        child = this._getInnerElement(child);\n        var isActive = this._elemIsActive(child);\n        var outerElem = this._getOuterElement(child);\n        child.setAttribute('aria-selected', isActive);\n        if (outerElem !== child) {\n          this._setAttributeIfNotExists(outerElem, 'role', 'presentation');\n        }\n        if (!isActive) {\n          child.setAttribute('tabindex', '-1');\n        }\n        this._setAttributeIfNotExists(child, 'role', 'tab'); // set attributes to the related panel too\n\n        this._setInitialAttributesOnTargetPanel(child);\n      }\n    }, {\n      key: \"_setInitialAttributesOnTargetPanel\",\n      value: function _setInitialAttributesOnTargetPanel(child) {\n        var target = getElementFromSelector(child);\n        if (!target) {\n          return;\n        }\n        this._setAttributeIfNotExists(target, 'role', 'tabpanel');\n        if (child.id) {\n          this._setAttributeIfNotExists(target, 'aria-labelledby', \"#\".concat(child.id));\n        }\n      }\n    }, {\n      key: \"_toggleDropDown\",\n      value: function _toggleDropDown(element, open) {\n        var outerElem = this._getOuterElement(element);\n        if (!outerElem.classList.contains(CLASS_DROPDOWN)) {\n          return;\n        }\n        var toggle = function toggle(selector, className) {\n          var element = SelectorEngine.findOne(selector, outerElem);\n          if (element) {\n            element.classList.toggle(className, open);\n          }\n        };\n        toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);\n        toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);\n        outerElem.setAttribute('aria-expanded', open);\n      }\n    }, {\n      key: \"_setAttributeIfNotExists\",\n      value: function _setAttributeIfNotExists(element, attribute, value) {\n        if (!element.hasAttribute(attribute)) {\n          element.setAttribute(attribute, value);\n        }\n      }\n    }, {\n      key: \"_elemIsActive\",\n      value: function _elemIsActive(elem) {\n        return elem.classList.contains(CLASS_NAME_ACTIVE);\n      } // Try to get the inner element (usually the .nav-link)\n    }, {\n      key: \"_getInnerElement\",\n      value: function _getInnerElement(elem) {\n        return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);\n      } // Try to get the outer element (usually the .nav-item)\n    }, {\n      key: \"_getOuterElement\",\n      value: function _getOuterElement(elem) {\n        return elem.closest(SELECTOR_OUTER) || elem;\n      } // Static\n    }], [{\n      key: \"NAME\",\n      get: function get() {\n        return NAME$1;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Tab.getOrCreateInstance(this);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        });\n      }\n    }]);\n    return Tab;\n  }(BaseComponent);\n  /**\n   * Data API implementation\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n    if (isDisabled(this)) {\n      return;\n    }\n    Tab.getOrCreateInstance(this).show();\n  });\n  /**\n   * Initialize on focus\n   */\n\n  EventHandler.on(window, EVENT_LOAD_DATA_API, function () {\n    var _iterator32 = _createForOfIteratorHelper(SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)),\n      _step32;\n    try {\n      for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n        var element = _step32.value;\n        Tab.getOrCreateInstance(element);\n      }\n    } catch (err) {\n      _iterator32.e(err);\n    } finally {\n      _iterator32.f();\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Tab);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): toast.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  var NAME = 'toast';\n  var DATA_KEY = 'bs.toast';\n  var EVENT_KEY = \".\".concat(DATA_KEY);\n  var EVENT_MOUSEOVER = \"mouseover\".concat(EVENT_KEY);\n  var EVENT_MOUSEOUT = \"mouseout\".concat(EVENT_KEY);\n  var EVENT_FOCUSIN = \"focusin\".concat(EVENT_KEY);\n  var EVENT_FOCUSOUT = \"focusout\".concat(EVENT_KEY);\n  var EVENT_HIDE = \"hide\".concat(EVENT_KEY);\n  var EVENT_HIDDEN = \"hidden\".concat(EVENT_KEY);\n  var EVENT_SHOW = \"show\".concat(EVENT_KEY);\n  var EVENT_SHOWN = \"shown\".concat(EVENT_KEY);\n  var CLASS_NAME_FADE = 'fade';\n  var CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility\n\n  var CLASS_NAME_SHOW = 'show';\n  var CLASS_NAME_SHOWING = 'showing';\n  var DefaultType = {\n    animation: 'boolean',\n    autohide: 'boolean',\n    delay: 'number'\n  };\n  var Default = {\n    animation: true,\n    autohide: true,\n    delay: 5000\n  };\n  /**\n   * Class definition\n   */\n  var Toast = /*#__PURE__*/function (_BaseComponent11) {\n    _inherits(Toast, _BaseComponent11);\n    var _super17 = _createSuper(Toast);\n    function Toast(element, config) {\n      var _this55;\n      _classCallCheck(this, Toast);\n      _this55 = _super17.call(this, element, config);\n      _this55._timeout = null;\n      _this55._hasMouseInteraction = false;\n      _this55._hasKeyboardInteraction = false;\n      _this55._setListeners();\n      return _this55;\n    } // Getters\n    _createClass(Toast, [{\n      key: \"show\",\n      value:\n      // Public\n\n      function show() {\n        var _this56 = this;\n        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\n        if (showEvent.defaultPrevented) {\n          return;\n        }\n        this._clearTimeout();\n        if (this._config.animation) {\n          this._element.classList.add(CLASS_NAME_FADE);\n        }\n        var complete = function complete() {\n          _this56._element.classList.remove(CLASS_NAME_SHOWING);\n          EventHandler.trigger(_this56._element, EVENT_SHOWN);\n          _this56._maybeScheduleHide();\n        };\n        this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated\n\n        reflow(this._element);\n        this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);\n        this._queueCallback(complete, this._element, this._config.animation);\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var _this57 = this;\n        if (!this.isShown()) {\n          return;\n        }\n        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\n        if (hideEvent.defaultPrevented) {\n          return;\n        }\n        var complete = function complete() {\n          _this57._element.classList.add(CLASS_NAME_HIDE); // @deprecated\n\n          _this57._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);\n          EventHandler.trigger(_this57._element, EVENT_HIDDEN);\n        };\n        this._element.classList.add(CLASS_NAME_SHOWING);\n        this._queueCallback(complete, this._element, this._config.animation);\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        this._clearTimeout();\n        if (this.isShown()) {\n          this._element.classList.remove(CLASS_NAME_SHOW);\n        }\n        _get(_getPrototypeOf(Toast.prototype), \"dispose\", this).call(this);\n      }\n    }, {\n      key: \"isShown\",\n      value: function isShown() {\n        return this._element.classList.contains(CLASS_NAME_SHOW);\n      } // Private\n    }, {\n      key: \"_maybeScheduleHide\",\n      value: function _maybeScheduleHide() {\n        var _this58 = this;\n        if (!this._config.autohide) {\n          return;\n        }\n        if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\n          return;\n        }\n        this._timeout = setTimeout(function () {\n          _this58.hide();\n        }, this._config.delay);\n      }\n    }, {\n      key: \"_onInteraction\",\n      value: function _onInteraction(event, isInteracting) {\n        switch (event.type) {\n          case 'mouseover':\n          case 'mouseout':\n            {\n              this._hasMouseInteraction = isInteracting;\n              break;\n            }\n          case 'focusin':\n          case 'focusout':\n            {\n              this._hasKeyboardInteraction = isInteracting;\n              break;\n            }\n        }\n        if (isInteracting) {\n          this._clearTimeout();\n          return;\n        }\n        var nextElement = event.relatedTarget;\n        if (this._element === nextElement || this._element.contains(nextElement)) {\n          return;\n        }\n        this._maybeScheduleHide();\n      }\n    }, {\n      key: \"_setListeners\",\n      value: function _setListeners() {\n        var _this59 = this;\n        EventHandler.on(this._element, EVENT_MOUSEOVER, function (event) {\n          return _this59._onInteraction(event, true);\n        });\n        EventHandler.on(this._element, EVENT_MOUSEOUT, function (event) {\n          return _this59._onInteraction(event, false);\n        });\n        EventHandler.on(this._element, EVENT_FOCUSIN, function (event) {\n          return _this59._onInteraction(event, true);\n        });\n        EventHandler.on(this._element, EVENT_FOCUSOUT, function (event) {\n          return _this59._onInteraction(event, false);\n        });\n      }\n    }, {\n      key: \"_clearTimeout\",\n      value: function _clearTimeout() {\n        clearTimeout(this._timeout);\n        this._timeout = null;\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Toast.getOrCreateInstance(this, config);\n          if (typeof config === 'string') {\n            if (typeof data[config] === 'undefined') {\n              throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n            }\n            data[config](this);\n          }\n        });\n      }\n    }]);\n    return Toast;\n  }(BaseComponent);\n  /**\n   * Data API implementation\n   */\n  enableDismissTrigger(Toast);\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Toast);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.3): index.umd.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  var index_umd = {\n    Alert: Alert,\n    Button: Button,\n    Carousel: Carousel,\n    Collapse: Collapse,\n    Dropdown: Dropdown,\n    Modal: Modal,\n    Offcanvas: Offcanvas,\n    Popover: Popover,\n    ScrollSpy: ScrollSpy,\n    Tab: Tab,\n    Toast: Toast,\n    Tooltip: Tooltip\n  };\n  return index_umd;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLElBQUksQ0FBQztVQUNwQjtRQUNGLENBQUMsQ0FBQztNQUNKO0lBQUM7SUFBQTtFQUFBLEVBdEtpQmtCLGFBQWE7RUF5S2pDO0FBQ0Y7QUFDQTtFQUdFVSxvQkFBb0IsQ0FBQ21tQyxLQUFLLENBQUM7RUFDM0I7QUFDRjtBQUNBOztFQUVFOXdDLGtCQUFrQixDQUFDOHdDLEtBQUssQ0FBQzs7RUFFekI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0UsSUFBTVEsU0FBUyxHQUFHO0lBQ2hCOWxDLEtBQUssRUFBTEEsS0FBSztJQUNMYyxNQUFNLEVBQU5BLE1BQU07SUFDTm9HLFFBQVEsRUFBUkEsUUFBUTtJQUNSMEUsUUFBUSxFQUFSQSxRQUFRO0lBQ1I2ZSxRQUFRLEVBQVJBLFFBQVE7SUFDUmlILEtBQUssRUFBTEEsS0FBSztJQUNMOEMsU0FBUyxFQUFUQSxTQUFTO0lBQ1RzSixPQUFPLEVBQVBBLE9BQU87SUFDUHlCLFNBQVMsRUFBVEEsU0FBUztJQUNUNkQsR0FBRyxFQUFIQSxHQUFHO0lBQ0hrQyxLQUFLLEVBQUxBLEtBQUs7SUFDTGxLLE9BQU8sRUFBUEE7RUFDRixDQUFDO0VBRUQsT0FBTzBLLFNBQVM7QUFFbEIsQ0FBQyxDQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2Jvb3RzdHJhcC5idW5kbGUuanM/ZDFhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgKiBCb290c3RyYXAgdjUuMi4zIChodHRwczovL2dldGJvb3RzdHJhcC5jb20vKVxuICAqIENvcHlyaWdodCAyMDExLTIwMjIgVGhlIEJvb3RzdHJhcCBBdXRob3JzIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvZ3JhcGhzL2NvbnRyaWJ1dG9ycylcbiAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmJvb3RzdHJhcCA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogdXRpbC9pbmRleC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG4gIGNvbnN0IE1BWF9VSUQgPSAxMDAwMDAwO1xuICBjb25zdCBNSUxMSVNFQ09ORFNfTVVMVElQTElFUiA9IDEwMDA7XG4gIGNvbnN0IFRSQU5TSVRJT05fRU5EID0gJ3RyYW5zaXRpb25lbmQnOyAvLyBTaG91dC1vdXQgQW5ndXMgQ3JvbGwgKGh0dHBzOi8vZ29vLmdsL3B4d1FHcClcblxuICBjb25zdCB0b1R5cGUgPSBvYmplY3QgPT4ge1xuICAgIGlmIChvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBgJHtvYmplY3R9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkubWF0Y2goL1xccyhbYS16XSspL2kpWzFdLnRvTG93ZXJDYXNlKCk7XG4gIH07XG4gIC8qKlxuICAgKiBQdWJsaWMgVXRpbCBBUElcbiAgICovXG5cblxuICBjb25zdCBnZXRVSUQgPSBwcmVmaXggPT4ge1xuICAgIGRvIHtcbiAgICAgIHByZWZpeCArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNQVhfVUlEKTtcbiAgICB9IHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcmVmaXgpKTtcblxuICAgIHJldHVybiBwcmVmaXg7XG4gIH07XG5cbiAgY29uc3QgZ2V0U2VsZWN0b3IgPSBlbGVtZW50ID0+IHtcbiAgICBsZXQgc2VsZWN0b3IgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy10YXJnZXQnKTtcblxuICAgIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09ICcjJykge1xuICAgICAgbGV0IGhyZWZBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpOyAvLyBUaGUgb25seSB2YWxpZCBjb250ZW50IHRoYXQgY291bGQgZG91YmxlIGFzIGEgc2VsZWN0b3IgYXJlIElEcyBvciBjbGFzc2VzLFxuICAgICAgLy8gc28gZXZlcnl0aGluZyBzdGFydGluZyB3aXRoIGAjYCBvciBgLmAuIElmIGEgXCJyZWFsXCIgVVJMIGlzIHVzZWQgYXMgdGhlIHNlbGVjdG9yLFxuICAgICAgLy8gYGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JgIHdpbGwgcmlnaHRmdWxseSBjb21wbGFpbiBpdCBpcyBpbnZhbGlkLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMzIyNzNcblxuICAgICAgaWYgKCFocmVmQXR0cmlidXRlIHx8ICFocmVmQXR0cmlidXRlLmluY2x1ZGVzKCcjJykgJiYgIWhyZWZBdHRyaWJ1dGUuc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyBKdXN0IGluIGNhc2Ugc29tZSBDTVMgcHV0cyBvdXQgYSBmdWxsIFVSTCB3aXRoIHRoZSBhbmNob3IgYXBwZW5kZWRcblxuXG4gICAgICBpZiAoaHJlZkF0dHJpYnV0ZS5pbmNsdWRlcygnIycpICYmICFocmVmQXR0cmlidXRlLnN0YXJ0c1dpdGgoJyMnKSkge1xuICAgICAgICBocmVmQXR0cmlidXRlID0gYCMke2hyZWZBdHRyaWJ1dGUuc3BsaXQoJyMnKVsxXX1gO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3RvciA9IGhyZWZBdHRyaWJ1dGUgJiYgaHJlZkF0dHJpYnV0ZSAhPT0gJyMnID8gaHJlZkF0dHJpYnV0ZS50cmltKCkgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3RvcjtcbiAgfTtcblxuICBjb25zdCBnZXRTZWxlY3RvckZyb21FbGVtZW50ID0gZWxlbWVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihlbGVtZW50KTtcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIGNvbnN0IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IgPSBlbGVtZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGVsZW1lbnQpO1xuICAgIHJldHVybiBzZWxlY3RvciA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpIDogbnVsbDtcbiAgfTtcblxuICBjb25zdCBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCA9IGVsZW1lbnQgPT4ge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSAvLyBHZXQgdHJhbnNpdGlvbi1kdXJhdGlvbiBvZiB0aGUgZWxlbWVudFxuXG5cbiAgICBsZXQge1xuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uLFxuICAgICAgdHJhbnNpdGlvbkRlbGF5XG4gICAgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uID0gTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICBjb25zdCBmbG9hdFRyYW5zaXRpb25EZWxheSA9IE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSk7IC8vIFJldHVybiAwIGlmIGVsZW1lbnQgb3IgdHJhbnNpdGlvbiBkdXJhdGlvbiBpcyBub3QgZm91bmRcblxuICAgIGlmICghZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gJiYgIWZsb2F0VHJhbnNpdGlvbkRlbGF5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IC8vIElmIG11bHRpcGxlIGR1cmF0aW9ucyBhcmUgZGVmaW5lZCwgdGFrZSB0aGUgZmlyc3RcblxuXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gdHJhbnNpdGlvbkR1cmF0aW9uLnNwbGl0KCcsJylbMF07XG4gICAgdHJhbnNpdGlvbkRlbGF5ID0gdHJhbnNpdGlvbkRlbGF5LnNwbGl0KCcsJylbMF07XG4gICAgcmV0dXJuIChOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pICsgTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KSkgKiBNSUxMSVNFQ09ORFNfTVVMVElQTElFUjtcbiAgfTtcblxuICBjb25zdCB0cmlnZ2VyVHJhbnNpdGlvbkVuZCA9IGVsZW1lbnQgPT4ge1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoVFJBTlNJVElPTl9FTkQpKTtcbiAgfTtcblxuICBjb25zdCBpc0VsZW1lbnQkMSA9IG9iamVjdCA9PiB7XG4gICAgaWYgKCFvYmplY3QgfHwgdHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iamVjdC5qcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3RbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgIT09ICd1bmRlZmluZWQnO1xuICB9O1xuXG4gIGNvbnN0IGdldEVsZW1lbnQgPSBvYmplY3QgPT4ge1xuICAgIC8vIGl0J3MgYSBqUXVlcnkgb2JqZWN0IG9yIGEgbm9kZSBlbGVtZW50XG4gICAgaWYgKGlzRWxlbWVudCQxKG9iamVjdCkpIHtcbiAgICAgIHJldHVybiBvYmplY3QuanF1ZXJ5ID8gb2JqZWN0WzBdIDogb2JqZWN0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob2JqZWN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBjb25zdCBpc1Zpc2libGUgPSBlbGVtZW50ID0+IHtcbiAgICBpZiAoIWlzRWxlbWVudCQxKGVsZW1lbnQpIHx8IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50SXNWaXNpYmxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCd2aXNpYmlsaXR5JykgPT09ICd2aXNpYmxlJzsgLy8gSGFuZGxlIGBkZXRhaWxzYCBlbGVtZW50IGFzIGl0cyBjb250ZW50IG1heSBmYWxzaWUgYXBwZWFyIHZpc2libGUgd2hlbiBpdCBpcyBjbG9zZWRcblxuICAgIGNvbnN0IGNsb3NlZERldGFpbHMgPSBlbGVtZW50LmNsb3Nlc3QoJ2RldGFpbHM6bm90KFtvcGVuXSknKTtcblxuICAgIGlmICghY2xvc2VkRGV0YWlscykge1xuICAgICAgcmV0dXJuIGVsZW1lbnRJc1Zpc2libGU7XG4gICAgfVxuXG4gICAgaWYgKGNsb3NlZERldGFpbHMgIT09IGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHN1bW1hcnkgPSBlbGVtZW50LmNsb3Nlc3QoJ3N1bW1hcnknKTtcblxuICAgICAgaWYgKHN1bW1hcnkgJiYgc3VtbWFyeS5wYXJlbnROb2RlICE9PSBjbG9zZWREZXRhaWxzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN1bW1hcnkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50SXNWaXNpYmxlO1xuICB9O1xuXG4gIGNvbnN0IGlzRGlzYWJsZWQgPSBlbGVtZW50ID0+IHtcbiAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpICE9PSAnZmFsc2UnO1xuICB9O1xuXG4gIGNvbnN0IGZpbmRTaGFkb3dSb290ID0gZWxlbWVudCA9PiB7XG4gICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoU2hhZG93KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIENhbiBmaW5kIHRoZSBzaGFkb3cgcm9vdCBvdGhlcndpc2UgaXQnbGwgcmV0dXJuIHRoZSBkb2N1bWVudFxuXG5cbiAgICBpZiAodHlwZW9mIGVsZW1lbnQuZ2V0Um9vdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHJvb3QgPSBlbGVtZW50LmdldFJvb3ROb2RlKCk7XG4gICAgICByZXR1cm4gcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyByb290IDogbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gd2hlbiB3ZSBkb24ndCBmaW5kIGEgc2hhZG93IHJvb3RcblxuXG4gICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmaW5kU2hhZG93Um9vdChlbGVtZW50LnBhcmVudE5vZGUpO1xuICB9O1xuXG4gIGNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbiAgLyoqXG4gICAqIFRyaWNrIHRvIHJlc3RhcnQgYW4gZWxlbWVudCdzIGFuaW1hdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm4gdm9pZFxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmNoYXJpc3RoZW8uaW8vYmxvZy8yMDIxLzAyL3Jlc3RhcnQtYS1jc3MtYW5pbWF0aW9uLXdpdGgtamF2YXNjcmlwdC8jcmVzdGFydGluZy1hLWNzcy1hbmltYXRpb25cbiAgICovXG5cblxuICBjb25zdCByZWZsb3cgPSBlbGVtZW50ID0+IHtcbiAgICBlbGVtZW50Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgfTtcblxuICBjb25zdCBnZXRqUXVlcnkgPSAoKSA9PiB7XG4gICAgaWYgKHdpbmRvdy5qUXVlcnkgJiYgIWRvY3VtZW50LmJvZHkuaGFzQXR0cmlidXRlKCdkYXRhLWJzLW5vLWpxdWVyeScpKSB7XG4gICAgICByZXR1cm4gd2luZG93LmpRdWVyeTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBjb25zdCBET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzID0gW107XG5cbiAgY29uc3Qgb25ET01Db250ZW50TG9hZGVkID0gY2FsbGJhY2sgPT4ge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgIC8vIGFkZCBsaXN0ZW5lciBvbiB0aGUgZmlyc3QgY2FsbCB3aGVuIHRoZSBkb2N1bWVudCBpcyBpbiBsb2FkaW5nIHN0YXRlXG4gICAgICBpZiAoIURPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIERPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGlzUlRMID0gKCkgPT4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRpciA9PT0gJ3J0bCc7XG5cbiAgY29uc3QgZGVmaW5lSlF1ZXJ5UGx1Z2luID0gcGx1Z2luID0+IHtcbiAgICBvbkRPTUNvbnRlbnRMb2FkZWQoKCkgPT4ge1xuICAgICAgY29uc3QgJCA9IGdldGpRdWVyeSgpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cbiAgICAgIGlmICgkKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwbHVnaW4uTkFNRTtcbiAgICAgICAgY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltuYW1lXTtcbiAgICAgICAgJC5mbltuYW1lXSA9IHBsdWdpbi5qUXVlcnlJbnRlcmZhY2U7XG4gICAgICAgICQuZm5bbmFtZV0uQ29uc3RydWN0b3IgPSBwbHVnaW47XG5cbiAgICAgICAgJC5mbltuYW1lXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAgICAgICAgICQuZm5bbmFtZV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gICAgICAgICAgcmV0dXJuIHBsdWdpbi5qUXVlcnlJbnRlcmZhY2U7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgZXhlY3V0ZSA9IGNhbGxiYWNrID0+IHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uID0gKGNhbGxiYWNrLCB0cmFuc2l0aW9uRWxlbWVudCwgd2FpdEZvclRyYW5zaXRpb24gPSB0cnVlKSA9PiB7XG4gICAgaWYgKCF3YWl0Rm9yVHJhbnNpdGlvbikge1xuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZHVyYXRpb25QYWRkaW5nID0gNTtcbiAgICBjb25zdCBlbXVsYXRlZER1cmF0aW9uID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodHJhbnNpdGlvbkVsZW1lbnQpICsgZHVyYXRpb25QYWRkaW5nO1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGhhbmRsZXIgPSAoe1xuICAgICAgdGFyZ2V0XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKHRhcmdldCAhPT0gdHJhbnNpdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgdHJhbnNpdGlvbkVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgaGFuZGxlcik7XG4gICAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgdHJhbnNpdGlvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgaGFuZGxlcik7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRWxlbWVudCk7XG4gICAgICB9XG4gICAgfSwgZW11bGF0ZWREdXJhdGlvbik7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHByZXZpb3VzL25leHQgZWxlbWVudCBvZiBhIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IGxpc3QgICAgVGhlIGxpc3Qgb2YgZWxlbWVudHNcbiAgICogQHBhcmFtIGFjdGl2ZUVsZW1lbnQgICBUaGUgYWN0aXZlIGVsZW1lbnRcbiAgICogQHBhcmFtIHNob3VsZEdldE5leHQgICBDaG9vc2UgdG8gZ2V0IG5leHQgb3IgcHJldmlvdXMgZWxlbWVudFxuICAgKiBAcGFyYW0gaXNDeWNsZUFsbG93ZWRcbiAgICogQHJldHVybiB7RWxlbWVudHxlbGVtfSBUaGUgcHJvcGVyIGVsZW1lbnRcbiAgICovXG5cblxuICBjb25zdCBnZXROZXh0QWN0aXZlRWxlbWVudCA9IChsaXN0LCBhY3RpdmVFbGVtZW50LCBzaG91bGRHZXROZXh0LCBpc0N5Y2xlQWxsb3dlZCkgPT4ge1xuICAgIGNvbnN0IGxpc3RMZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICBsZXQgaW5kZXggPSBsaXN0LmluZGV4T2YoYWN0aXZlRWxlbWVudCk7IC8vIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0IHJldHVybiBhbiBlbGVtZW50XG4gICAgLy8gZGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb24gYW5kIGlmIGN5Y2xlIGlzIGFsbG93ZWRcblxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAhc2hvdWxkR2V0TmV4dCAmJiBpc0N5Y2xlQWxsb3dlZCA/IGxpc3RbbGlzdExlbmd0aCAtIDFdIDogbGlzdFswXTtcbiAgICB9XG5cbiAgICBpbmRleCArPSBzaG91bGRHZXROZXh0ID8gMSA6IC0xO1xuXG4gICAgaWYgKGlzQ3ljbGVBbGxvd2VkKSB7XG4gICAgICBpbmRleCA9IChpbmRleCArIGxpc3RMZW5ndGgpICUgbGlzdExlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdFtNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgbGlzdExlbmd0aCAtIDEpKV07XG4gIH07XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogZG9tL2V2ZW50LWhhbmRsZXIuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IG5hbWVzcGFjZVJlZ2V4ID0gL1teLl0qKD89XFwuLiopXFwufC4qLztcbiAgY29uc3Qgc3RyaXBOYW1lUmVnZXggPSAvXFwuLiovO1xuICBjb25zdCBzdHJpcFVpZFJlZ2V4ID0gLzo6XFxkKyQvO1xuICBjb25zdCBldmVudFJlZ2lzdHJ5ID0ge307IC8vIEV2ZW50cyBzdG9yYWdlXG5cbiAgbGV0IHVpZEV2ZW50ID0gMTtcbiAgY29uc3QgY3VzdG9tRXZlbnRzID0ge1xuICAgIG1vdXNlZW50ZXI6ICdtb3VzZW92ZXInLFxuICAgIG1vdXNlbGVhdmU6ICdtb3VzZW91dCdcbiAgfTtcbiAgY29uc3QgbmF0aXZlRXZlbnRzID0gbmV3IFNldChbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ2NvbnRleHRtZW51JywgJ21vdXNld2hlZWwnLCAnRE9NTW91c2VTY3JvbGwnLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ21vdXNlbW92ZScsICdzZWxlY3RzdGFydCcsICdzZWxlY3RlbmQnLCAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCcsICdvcmllbnRhdGlvbmNoYW5nZScsICd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICd0b3VjaGVuZCcsICd0b3VjaGNhbmNlbCcsICdwb2ludGVyZG93bicsICdwb2ludGVybW92ZScsICdwb2ludGVydXAnLCAncG9pbnRlcmxlYXZlJywgJ3BvaW50ZXJjYW5jZWwnLCAnZ2VzdHVyZXN0YXJ0JywgJ2dlc3R1cmVjaGFuZ2UnLCAnZ2VzdHVyZWVuZCcsICdmb2N1cycsICdibHVyJywgJ2NoYW5nZScsICdyZXNldCcsICdzZWxlY3QnLCAnc3VibWl0JywgJ2ZvY3VzaW4nLCAnZm9jdXNvdXQnLCAnbG9hZCcsICd1bmxvYWQnLCAnYmVmb3JldW5sb2FkJywgJ3Jlc2l6ZScsICdtb3ZlJywgJ0RPTUNvbnRlbnRMb2FkZWQnLCAncmVhZHlzdGF0ZWNoYW5nZScsICdlcnJvcicsICdhYm9ydCcsICdzY3JvbGwnXSk7XG4gIC8qKlxuICAgKiBQcml2YXRlIG1ldGhvZHNcbiAgICovXG5cbiAgZnVuY3Rpb24gbWFrZUV2ZW50VWlkKGVsZW1lbnQsIHVpZCkge1xuICAgIHJldHVybiB1aWQgJiYgYCR7dWlkfTo6JHt1aWRFdmVudCsrfWAgfHwgZWxlbWVudC51aWRFdmVudCB8fCB1aWRFdmVudCsrO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudEV2ZW50cyhlbGVtZW50KSB7XG4gICAgY29uc3QgdWlkID0gbWFrZUV2ZW50VWlkKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQudWlkRXZlbnQgPSB1aWQ7XG4gICAgZXZlbnRSZWdpc3RyeVt1aWRdID0gZXZlbnRSZWdpc3RyeVt1aWRdIHx8IHt9O1xuICAgIHJldHVybiBldmVudFJlZ2lzdHJ5W3VpZF07XG4gIH1cblxuICBmdW5jdGlvbiBib290c3RyYXBIYW5kbGVyKGVsZW1lbnQsIGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZXIoZXZlbnQpIHtcbiAgICAgIGh5ZHJhdGVPYmooZXZlbnQsIHtcbiAgICAgICAgZGVsZWdhdGVUYXJnZXQ6IGVsZW1lbnRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFuZGxlci5vbmVPZmYpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCBldmVudC50eXBlLCBmbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbi5hcHBseShlbGVtZW50LCBbZXZlbnRdKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgc2VsZWN0b3IsIGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZXIoZXZlbnQpIHtcbiAgICAgIGNvbnN0IGRvbUVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICAgICAgZm9yIChsZXQge1xuICAgICAgICB0YXJnZXRcbiAgICAgIH0gPSBldmVudDsgdGFyZ2V0ICYmIHRhcmdldCAhPT0gdGhpczsgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBkb21FbGVtZW50IG9mIGRvbUVsZW1lbnRzKSB7XG4gICAgICAgICAgaWYgKGRvbUVsZW1lbnQgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaHlkcmF0ZU9iaihldmVudCwge1xuICAgICAgICAgICAgZGVsZWdhdGVUYXJnZXQ6IHRhcmdldFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGhhbmRsZXIub25lT2ZmKSB7XG4gICAgICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsIGV2ZW50LnR5cGUsIHNlbGVjdG9yLCBmbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRhcmdldCwgW2V2ZW50XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEhhbmRsZXIoZXZlbnRzLCBjYWxsYWJsZSwgZGVsZWdhdGlvblNlbGVjdG9yID0gbnVsbCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKGV2ZW50cykuZmluZChldmVudCA9PiBldmVudC5jYWxsYWJsZSA9PT0gY2FsbGFibGUgJiYgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yID09PSBkZWxlZ2F0aW9uU2VsZWN0b3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XG4gICAgY29uc3QgaXNEZWxlZ2F0ZWQgPSB0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZyc7IC8vIHRvZG86IHRvb2x0aXAgcGFzc2VzIGBmYWxzZWAgaW5zdGVhZCBvZiBzZWxlY3Rvciwgc28gd2UgbmVlZCB0byBjaGVja1xuXG4gICAgY29uc3QgY2FsbGFibGUgPSBpc0RlbGVnYXRlZCA/IGRlbGVnYXRpb25GdW5jdGlvbiA6IGhhbmRsZXIgfHwgZGVsZWdhdGlvbkZ1bmN0aW9uO1xuICAgIGxldCB0eXBlRXZlbnQgPSBnZXRUeXBlRXZlbnQob3JpZ2luYWxUeXBlRXZlbnQpO1xuXG4gICAgaWYgKCFuYXRpdmVFdmVudHMuaGFzKHR5cGVFdmVudCkpIHtcbiAgICAgIHR5cGVFdmVudCA9IG9yaWdpbmFsVHlwZUV2ZW50O1xuICAgIH1cblxuICAgIHJldHVybiBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkSGFuZGxlcihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCBvbmVPZmYpIHtcbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsVHlwZUV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdID0gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKTsgLy8gaW4gY2FzZSBvZiBtb3VzZWVudGVyIG9yIG1vdXNlbGVhdmUgd3JhcCB0aGUgaGFuZGxlciB3aXRoaW4gYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBmb3IgaXRzIERPTSBwb3NpdGlvblxuICAgIC8vIHRoaXMgcHJldmVudHMgdGhlIGhhbmRsZXIgZnJvbSBiZWluZyBkaXNwYXRjaGVkIHRoZSBzYW1lIHdheSBhcyBtb3VzZW92ZXIgb3IgbW91c2VvdXQgZG9lc1xuXG4gICAgaWYgKG9yaWdpbmFsVHlwZUV2ZW50IGluIGN1c3RvbUV2ZW50cykge1xuICAgICAgY29uc3Qgd3JhcEZ1bmN0aW9uID0gZm4gPT4ge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKCFldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQgIT09IGV2ZW50LmRlbGVnYXRlVGFyZ2V0ICYmICFldmVudC5kZWxlZ2F0ZVRhcmdldC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGNhbGxhYmxlID0gd3JhcEZ1bmN0aW9uKGNhbGxhYmxlKTtcbiAgICB9XG5cbiAgICBjb25zdCBldmVudHMgPSBnZXRFbGVtZW50RXZlbnRzKGVsZW1lbnQpO1xuICAgIGNvbnN0IGhhbmRsZXJzID0gZXZlbnRzW3R5cGVFdmVudF0gfHwgKGV2ZW50c1t0eXBlRXZlbnRdID0ge30pO1xuICAgIGNvbnN0IHByZXZpb3VzRnVuY3Rpb24gPSBmaW5kSGFuZGxlcihoYW5kbGVycywgY2FsbGFibGUsIGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGwpO1xuXG4gICAgaWYgKHByZXZpb3VzRnVuY3Rpb24pIHtcbiAgICAgIHByZXZpb3VzRnVuY3Rpb24ub25lT2ZmID0gcHJldmlvdXNGdW5jdGlvbi5vbmVPZmYgJiYgb25lT2ZmO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHVpZCA9IG1ha2VFdmVudFVpZChjYWxsYWJsZSwgb3JpZ2luYWxUeXBlRXZlbnQucmVwbGFjZShuYW1lc3BhY2VSZWdleCwgJycpKTtcbiAgICBjb25zdCBmbiA9IGlzRGVsZWdhdGVkID8gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgaGFuZGxlciwgY2FsbGFibGUpIDogYm9vdHN0cmFwSGFuZGxlcihlbGVtZW50LCBjYWxsYWJsZSk7XG4gICAgZm4uZGVsZWdhdGlvblNlbGVjdG9yID0gaXNEZWxlZ2F0ZWQgPyBoYW5kbGVyIDogbnVsbDtcbiAgICBmbi5jYWxsYWJsZSA9IGNhbGxhYmxlO1xuICAgIGZuLm9uZU9mZiA9IG9uZU9mZjtcbiAgICBmbi51aWRFdmVudCA9IHVpZDtcbiAgICBoYW5kbGVyc1t1aWRdID0gZm47XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGVFdmVudCwgZm4sIGlzRGVsZWdhdGVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3Rvcikge1xuICAgIGNvbnN0IGZuID0gZmluZEhhbmRsZXIoZXZlbnRzW3R5cGVFdmVudF0sIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3Rvcik7XG5cbiAgICBpZiAoIWZuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGVFdmVudCwgZm4sIEJvb2xlYW4oZGVsZWdhdGlvblNlbGVjdG9yKSk7XG4gICAgZGVsZXRlIGV2ZW50c1t0eXBlRXZlbnRdW2ZuLnVpZEV2ZW50XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5hbWVzcGFjZWRIYW5kbGVycyhlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgbmFtZXNwYWNlKSB7XG4gICAgY29uc3Qgc3RvcmVFbGVtZW50RXZlbnQgPSBldmVudHNbdHlwZUV2ZW50XSB8fCB7fTtcblxuICAgIGZvciAoY29uc3QgaGFuZGxlcktleSBvZiBPYmplY3Qua2V5cyhzdG9yZUVsZW1lbnRFdmVudCkpIHtcbiAgICAgIGlmIChoYW5kbGVyS2V5LmluY2x1ZGVzKG5hbWVzcGFjZSkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBzdG9yZUVsZW1lbnRFdmVudFtoYW5kbGVyS2V5XTtcbiAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgZXZlbnQuY2FsbGFibGUsIGV2ZW50LmRlbGVnYXRpb25TZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VHlwZUV2ZW50KGV2ZW50KSB7XG4gICAgLy8gYWxsb3cgdG8gZ2V0IHRoZSBuYXRpdmUgZXZlbnRzIGZyb20gbmFtZXNwYWNlZCBldmVudHMgKCdjbGljay5icy5idXR0b24nIC0tPiAnY2xpY2snKVxuICAgIGV2ZW50ID0gZXZlbnQucmVwbGFjZShzdHJpcE5hbWVSZWdleCwgJycpO1xuICAgIHJldHVybiBjdXN0b21FdmVudHNbZXZlbnRdIHx8IGV2ZW50O1xuICB9XG5cbiAgY29uc3QgRXZlbnRIYW5kbGVyID0ge1xuICAgIG9uKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcbiAgICAgIGFkZEhhbmRsZXIoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbiwgZmFsc2UpO1xuICAgIH0sXG5cbiAgICBvbmUoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbikge1xuICAgICAgYWRkSGFuZGxlcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgb2ZmKGVsZW1lbnQsIG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUeXBlRXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW2lzRGVsZWdhdGVkLCBjYWxsYWJsZSwgdHlwZUV2ZW50XSA9IG5vcm1hbGl6ZVBhcmFtZXRlcnMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbik7XG4gICAgICBjb25zdCBpbk5hbWVzcGFjZSA9IHR5cGVFdmVudCAhPT0gb3JpZ2luYWxUeXBlRXZlbnQ7XG4gICAgICBjb25zdCBldmVudHMgPSBnZXRFbGVtZW50RXZlbnRzKGVsZW1lbnQpO1xuICAgICAgY29uc3Qgc3RvcmVFbGVtZW50RXZlbnQgPSBldmVudHNbdHlwZUV2ZW50XSB8fCB7fTtcbiAgICAgIGNvbnN0IGlzTmFtZXNwYWNlID0gb3JpZ2luYWxUeXBlRXZlbnQuc3RhcnRzV2l0aCgnLicpO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBTaW1wbGVzdCBjYXNlOiBoYW5kbGVyIGlzIHBhc3NlZCwgcmVtb3ZlIHRoYXQgbGlzdGVuZXIgT05MWS5cbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhzdG9yZUVsZW1lbnRFdmVudCkubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgY2FsbGFibGUsIGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05hbWVzcGFjZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnRFdmVudCBvZiBPYmplY3Qua2V5cyhldmVudHMpKSB7XG4gICAgICAgICAgcmVtb3ZlTmFtZXNwYWNlZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50cywgZWxlbWVudEV2ZW50LCBvcmlnaW5hbFR5cGVFdmVudC5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBrZXlIYW5kbGVycyBvZiBPYmplY3Qua2V5cyhzdG9yZUVsZW1lbnRFdmVudCkpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlcktleSA9IGtleUhhbmRsZXJzLnJlcGxhY2Uoc3RyaXBVaWRSZWdleCwgJycpO1xuXG4gICAgICAgIGlmICghaW5OYW1lc3BhY2UgfHwgb3JpZ2luYWxUeXBlRXZlbnQuaW5jbHVkZXMoaGFuZGxlcktleSkpIHtcbiAgICAgICAgICBjb25zdCBldmVudCA9IHN0b3JlRWxlbWVudEV2ZW50W2tleUhhbmRsZXJzXTtcbiAgICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBldmVudC5jYWxsYWJsZSwgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB0cmlnZ2VyKGVsZW1lbnQsIGV2ZW50LCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgJCA9IGdldGpRdWVyeSgpO1xuICAgICAgY29uc3QgdHlwZUV2ZW50ID0gZ2V0VHlwZUV2ZW50KGV2ZW50KTtcbiAgICAgIGNvbnN0IGluTmFtZXNwYWNlID0gZXZlbnQgIT09IHR5cGVFdmVudDtcbiAgICAgIGxldCBqUXVlcnlFdmVudCA9IG51bGw7XG4gICAgICBsZXQgYnViYmxlcyA9IHRydWU7XG4gICAgICBsZXQgbmF0aXZlRGlzcGF0Y2ggPSB0cnVlO1xuICAgICAgbGV0IGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGluTmFtZXNwYWNlICYmICQpIHtcbiAgICAgICAgalF1ZXJ5RXZlbnQgPSAkLkV2ZW50KGV2ZW50LCBhcmdzKTtcbiAgICAgICAgJChlbGVtZW50KS50cmlnZ2VyKGpRdWVyeUV2ZW50KTtcbiAgICAgICAgYnViYmxlcyA9ICFqUXVlcnlFdmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpO1xuICAgICAgICBuYXRpdmVEaXNwYXRjaCA9ICFqUXVlcnlFdmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpO1xuICAgICAgICBkZWZhdWx0UHJldmVudGVkID0galF1ZXJ5RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBldnQgPSBuZXcgRXZlbnQoZXZlbnQsIHtcbiAgICAgICAgYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBldnQgPSBoeWRyYXRlT2JqKGV2dCwgYXJncyk7XG5cbiAgICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmF0aXZlRGlzcGF0Y2gpIHtcbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChldnQuZGVmYXVsdFByZXZlbnRlZCAmJiBqUXVlcnlFdmVudCkge1xuICAgICAgICBqUXVlcnlFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZ0O1xuICAgIH1cblxuICB9O1xuXG4gIGZ1bmN0aW9uIGh5ZHJhdGVPYmoob2JqLCBtZXRhKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWV0YSB8fCB7fSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IGRvbS9kYXRhLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuICBjb25zdCBlbGVtZW50TWFwID0gbmV3IE1hcCgpO1xuICBjb25zdCBEYXRhID0ge1xuICAgIHNldChlbGVtZW50LCBrZXksIGluc3RhbmNlKSB7XG4gICAgICBpZiAoIWVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgIGVsZW1lbnRNYXAuc2V0KGVsZW1lbnQsIG5ldyBNYXAoKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluc3RhbmNlTWFwID0gZWxlbWVudE1hcC5nZXQoZWxlbWVudCk7IC8vIG1ha2UgaXQgY2xlYXIgd2Ugb25seSB3YW50IG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudFxuICAgICAgLy8gY2FuIGJlIHJlbW92ZWQgbGF0ZXIgd2hlbiBtdWx0aXBsZSBrZXkvaW5zdGFuY2VzIGFyZSBmaW5lIHRvIGJlIHVzZWRcblxuICAgICAgaWYgKCFpbnN0YW5jZU1hcC5oYXMoa2V5KSAmJiBpbnN0YW5jZU1hcC5zaXplICE9PSAwKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEJvb3RzdHJhcCBkb2Vzbid0IGFsbG93IG1vcmUgdGhhbiBvbmUgaW5zdGFuY2UgcGVyIGVsZW1lbnQuIEJvdW5kIGluc3RhbmNlOiAke0FycmF5LmZyb20oaW5zdGFuY2VNYXAua2V5cygpKVswXX0uYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2VNYXAuc2V0KGtleSwgaW5zdGFuY2UpO1xuICAgIH0sXG5cbiAgICBnZXQoZWxlbWVudCwga2V5KSB7XG4gICAgICBpZiAoZWxlbWVudE1hcC5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpLmdldChrZXkpIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICByZW1vdmUoZWxlbWVudCwga2V5KSB7XG4gICAgICBpZiAoIWVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5zdGFuY2VNYXAgPSBlbGVtZW50TWFwLmdldChlbGVtZW50KTtcbiAgICAgIGluc3RhbmNlTWFwLmRlbGV0ZShrZXkpOyAvLyBmcmVlIHVwIGVsZW1lbnQgcmVmZXJlbmNlcyBpZiB0aGVyZSBhcmUgbm8gaW5zdGFuY2VzIGxlZnQgZm9yIGFuIGVsZW1lbnRcblxuICAgICAgaWYgKGluc3RhbmNlTWFwLnNpemUgPT09IDApIHtcbiAgICAgICAgZWxlbWVudE1hcC5kZWxldGUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogZG9tL21hbmlwdWxhdG9yLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplRGF0YSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09IE51bWJlcih2YWx1ZSkudG9TdHJpbmcoKSkge1xuICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gJ251bGwnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplRGF0YUtleShrZXkpIHtcbiAgICByZXR1cm4ga2V5LnJlcGxhY2UoL1tBLVpdL2csIGNociA9PiBgLSR7Y2hyLnRvTG93ZXJDYXNlKCl9YCk7XG4gIH1cblxuICBjb25zdCBNYW5pcHVsYXRvciA9IHtcbiAgICBzZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIGtleSwgdmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGBkYXRhLWJzLSR7bm9ybWFsaXplRGF0YUtleShrZXkpfWAsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlRGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXkpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGBkYXRhLWJzLSR7bm9ybWFsaXplRGF0YUtleShrZXkpfWApO1xuICAgIH0sXG5cbiAgICBnZXREYXRhQXR0cmlidXRlcyhlbGVtZW50KSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgICBjb25zdCBic0tleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50LmRhdGFzZXQpLmZpbHRlcihrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2JzJykgJiYgIWtleS5zdGFydHNXaXRoKCdic0NvbmZpZycpKTtcblxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgYnNLZXlzKSB7XG4gICAgICAgIGxldCBwdXJlS2V5ID0ga2V5LnJlcGxhY2UoL15icy8sICcnKTtcbiAgICAgICAgcHVyZUtleSA9IHB1cmVLZXkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBwdXJlS2V5LnNsaWNlKDEsIHB1cmVLZXkubGVuZ3RoKTtcbiAgICAgICAgYXR0cmlidXRlc1twdXJlS2V5XSA9IG5vcm1hbGl6ZURhdGEoZWxlbWVudC5kYXRhc2V0W2tleV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LFxuXG4gICAgZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXkpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVEYXRhKGVsZW1lbnQuZ2V0QXR0cmlidXRlKGBkYXRhLWJzLSR7bm9ybWFsaXplRGF0YUtleShrZXkpfWApKTtcbiAgICB9XG5cbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwICh2NS4yLjMpOiB1dGlsL2NvbmZpZy5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIENvbmZpZyB7XG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGhhdmUgdG8gaW1wbGVtZW50IHRoZSBzdGF0aWMgbWV0aG9kIFwiTkFNRVwiLCBmb3IgZWFjaCBjb21wb25lbnQhJyk7XG4gICAgfVxuXG4gICAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9IHRoaXMuX21lcmdlQ29uZmlnT2JqKGNvbmZpZyk7XG4gICAgICBjb25maWcgPSB0aGlzLl9jb25maWdBZnRlck1lcmdlKGNvbmZpZyk7XG5cbiAgICAgIHRoaXMuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xuXG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBfbWVyZ2VDb25maWdPYmooY29uZmlnLCBlbGVtZW50KSB7XG4gICAgICBjb25zdCBqc29uQ29uZmlnID0gaXNFbGVtZW50JDEoZWxlbWVudCkgPyBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsICdjb25maWcnKSA6IHt9OyAvLyB0cnkgdG8gcGFyc2VcblxuICAgICAgcmV0dXJuIHsgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxuICAgICAgICAuLi4odHlwZW9mIGpzb25Db25maWcgPT09ICdvYmplY3QnID8ganNvbkNvbmZpZyA6IHt9KSxcbiAgICAgICAgLi4uKGlzRWxlbWVudCQxKGVsZW1lbnQpID8gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXMoZWxlbWVudCkgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IHt9KVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBfdHlwZUNoZWNrQ29uZmlnKGNvbmZpZywgY29uZmlnVHlwZXMgPSB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIE9iamVjdC5rZXlzKGNvbmZpZ1R5cGVzKSkge1xuICAgICAgICBjb25zdCBleHBlY3RlZFR5cGVzID0gY29uZmlnVHlwZXNbcHJvcGVydHldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZ1twcm9wZXJ0eV07XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGlzRWxlbWVudCQxKHZhbHVlKSA/ICdlbGVtZW50JyA6IHRvVHlwZSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKCFuZXcgUmVnRXhwKGV4cGVjdGVkVHlwZXMpLnRlc3QodmFsdWVUeXBlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FLnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCIke3Byb3BlcnR5fVwiIHByb3ZpZGVkIHR5cGUgXCIke3ZhbHVlVHlwZX1cIiBidXQgZXhwZWN0ZWQgdHlwZSBcIiR7ZXhwZWN0ZWRUeXBlc31cIi5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogYmFzZS1jb21wb25lbnQuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IFZFUlNJT04gPSAnNS4yLjMnO1xuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBCYXNlQ29tcG9uZW50IGV4dGVuZHMgQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICBlbGVtZW50ID0gZ2V0RWxlbWVudChlbGVtZW50KTtcblxuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIERhdGEuc2V0KHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpO1xuICAgIH0gLy8gUHVibGljXG5cblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICBEYXRhLnJlbW92ZSh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9LRVkpO1xuXG4gICAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xuICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9xdWV1ZUNhbGxiYWNrKGNhbGxiYWNrLCBlbGVtZW50LCBpc0FuaW1hdGVkID0gdHJ1ZSkge1xuICAgICAgZXhlY3V0ZUFmdGVyVHJhbnNpdGlvbihjYWxsYmFjaywgZWxlbWVudCwgaXNBbmltYXRlZCk7XG4gICAgfVxuXG4gICAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9IHRoaXMuX21lcmdlQ29uZmlnT2JqKGNvbmZpZywgdGhpcy5fZWxlbWVudCk7XG4gICAgICBjb25maWcgPSB0aGlzLl9jb25maWdBZnRlck1lcmdlKGNvbmZpZyk7XG5cbiAgICAgIHRoaXMuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xuXG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH0gLy8gU3RhdGljXG5cblxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZShlbGVtZW50KSB7XG4gICAgICByZXR1cm4gRGF0YS5nZXQoZ2V0RWxlbWVudChlbGVtZW50KSwgdGhpcy5EQVRBX0tFWSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCwgY29uZmlnID0ge30pIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKGVsZW1lbnQpIHx8IG5ldyB0aGlzKGVsZW1lbnQsIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDogbnVsbCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgICAgcmV0dXJuIFZFUlNJT047XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICAgIHJldHVybiBgYnMuJHt0aGlzLk5BTUV9YDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IEVWRU5UX0tFWSgpIHtcbiAgICAgIHJldHVybiBgLiR7dGhpcy5EQVRBX0tFWX1gO1xuICAgIH1cblxuICAgIHN0YXRpYyBldmVudE5hbWUobmFtZSkge1xuICAgICAgcmV0dXJuIGAke25hbWV9JHt0aGlzLkVWRU5UX0tFWX1gO1xuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogdXRpbC9jb21wb25lbnQtZnVuY3Rpb25zLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICBjb25zdCBlbmFibGVEaXNtaXNzVHJpZ2dlciA9IChjb21wb25lbnQsIG1ldGhvZCA9ICdoaWRlJykgPT4ge1xuICAgIGNvbnN0IGNsaWNrRXZlbnQgPSBgY2xpY2suZGlzbWlzcyR7Y29tcG9uZW50LkVWRU5UX0tFWX1gO1xuICAgIGNvbnN0IG5hbWUgPSBjb21wb25lbnQuTkFNRTtcbiAgICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIGNsaWNrRXZlbnQsIGBbZGF0YS1icy1kaXNtaXNzPVwiJHtuYW1lfVwiXWAsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcykgfHwgdGhpcy5jbG9zZXN0KGAuJHtuYW1lfWApO1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBjb21wb25lbnQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpOyAvLyBNZXRob2QgYXJndW1lbnQgaXMgbGVmdCwgZm9yIEFsZXJ0IGFuZCBvbmx5LCBhcyBpdCBkb2Vzbid0IGltcGxlbWVudCB0aGUgJ2hpZGUnIG1ldGhvZFxuXG4gICAgICBpbnN0YW5jZVttZXRob2RdKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogYWxlcnQuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkZiA9ICdhbGVydCc7XG4gIGNvbnN0IERBVEFfS0VZJGEgPSAnYnMuYWxlcnQnO1xuICBjb25zdCBFVkVOVF9LRVkkYiA9IGAuJHtEQVRBX0tFWSRhfWA7XG4gIGNvbnN0IEVWRU5UX0NMT1NFID0gYGNsb3NlJHtFVkVOVF9LRVkkYn1gO1xuICBjb25zdCBFVkVOVF9DTE9TRUQgPSBgY2xvc2VkJHtFVkVOVF9LRVkkYn1gO1xuICBjb25zdCBDTEFTU19OQU1FX0ZBREUkNSA9ICdmYWRlJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDggPSAnc2hvdyc7XG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIEFsZXJ0IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJGY7XG4gICAgfSAvLyBQdWJsaWNcblxuXG4gICAgY2xvc2UoKSB7XG4gICAgICBjb25zdCBjbG9zZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfQ0xPU0UpO1xuXG4gICAgICBpZiAoY2xvc2VFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ4KTtcblxuICAgICAgY29uc3QgaXNBbmltYXRlZCA9IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQ1KTtcblxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudCgpLCB0aGlzLl9lbGVtZW50LCBpc0FuaW1hdGVkKTtcbiAgICB9IC8vIFByaXZhdGVcblxuXG4gICAgX2Rlc3Ryb3lFbGVtZW50KCkge1xuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmUoKTtcblxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfQ0xPU0VEKTtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH0gLy8gU3RhdGljXG5cblxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEFsZXJ0LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICB9XG4gIC8qKlxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICAgKi9cblxuXG4gIGVuYWJsZURpc21pc3NUcmlnZ2VyKEFsZXJ0LCAnY2xvc2UnKTtcbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oQWxlcnQpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IGJ1dHRvbi5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSRlID0gJ2J1dHRvbic7XG4gIGNvbnN0IERBVEFfS0VZJDkgPSAnYnMuYnV0dG9uJztcbiAgY29uc3QgRVZFTlRfS0VZJGEgPSBgLiR7REFUQV9LRVkkOX1gO1xuICBjb25zdCBEQVRBX0FQSV9LRVkkNiA9ICcuZGF0YS1hcGknO1xuICBjb25zdCBDTEFTU19OQU1FX0FDVElWRSQzID0gJ2FjdGl2ZSc7XG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUgPSAnW2RhdGEtYnMtdG9nZ2xlPVwiYnV0dG9uXCJdJztcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNiA9IGBjbGljayR7RVZFTlRfS0VZJGF9JHtEQVRBX0FQSV9LRVkkNn1gO1xuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBCdXR0b24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkZTtcbiAgICB9IC8vIFB1YmxpY1xuXG5cbiAgICB0b2dnbGUoKSB7XG4gICAgICAvLyBUb2dnbGUgY2xhc3MgYW5kIHN5bmMgdGhlIGBhcmlhLXByZXNzZWRgIGF0dHJpYnV0ZSB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGAudG9nZ2xlKClgIG1ldGhvZFxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtcHJlc3NlZCcsIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19OQU1FX0FDVElWRSQzKSk7XG4gICAgfSAvLyBTdGF0aWNcblxuXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gQnV0dG9uLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG5cbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIH1cbiAgLyoqXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gICAqL1xuXG5cbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ2LCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1LCBldmVudCA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBidXR0b24gPSBldmVudC50YXJnZXQuY2xvc2VzdChTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1KTtcbiAgICBjb25zdCBkYXRhID0gQnV0dG9uLmdldE9yQ3JlYXRlSW5zdGFuY2UoYnV0dG9uKTtcbiAgICBkYXRhLnRvZ2dsZSgpO1xuICB9KTtcbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oQnV0dG9uKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwICh2NS4yLjMpOiBkb20vc2VsZWN0b3ItZW5naW5lLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBTZWxlY3RvckVuZ2luZSA9IHtcbiAgICBmaW5kKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KC4uLkVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwuY2FsbChlbGVtZW50LCBzZWxlY3RvcikpO1xuICAgIH0sXG5cbiAgICBmaW5kT25lKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvci5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICB9LFxuXG4gICAgY2hpbGRyZW4oZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoLi4uZWxlbWVudC5jaGlsZHJlbikuZmlsdGVyKGNoaWxkID0+IGNoaWxkLm1hdGNoZXMoc2VsZWN0b3IpKTtcbiAgICB9LFxuXG4gICAgcGFyZW50cyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgbGV0IGFuY2VzdG9yID0gZWxlbWVudC5wYXJlbnROb2RlLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuXG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgcGFyZW50cy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9LFxuXG4gICAgcHJldihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgbGV0IHByZXZpb3VzID0gZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuXG4gICAgICB3aGlsZSAocHJldmlvdXMpIHtcbiAgICAgICAgaWYgKHByZXZpb3VzLm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIFtwcmV2aW91c107XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91cyA9IHByZXZpb3VzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgLy8gVE9ETzogdGhpcyBpcyBub3cgdW51c2VkOyByZW1vdmUgbGF0ZXIgYWxvbmcgd2l0aCBwcmV2KClcbiAgICBuZXh0KGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICBsZXQgbmV4dCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nO1xuXG4gICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICBpZiAobmV4dC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICAgIHJldHVybiBbbmV4dF07XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0ID0gbmV4dC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgZm9jdXNhYmxlQ2hpbGRyZW4oZWxlbWVudCkge1xuICAgICAgY29uc3QgZm9jdXNhYmxlcyA9IFsnYScsICdidXR0b24nLCAnaW5wdXQnLCAndGV4dGFyZWEnLCAnc2VsZWN0JywgJ2RldGFpbHMnLCAnW3RhYmluZGV4XScsICdbY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXSddLm1hcChzZWxlY3RvciA9PiBgJHtzZWxlY3Rvcn06bm90KFt0YWJpbmRleF49XCItXCJdKWApLmpvaW4oJywnKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmQoZm9jdXNhYmxlcywgZWxlbWVudCkuZmlsdGVyKGVsID0+ICFpc0Rpc2FibGVkKGVsKSAmJiBpc1Zpc2libGUoZWwpKTtcbiAgICB9XG5cbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwICh2NS4yLjMpOiB1dGlsL3N3aXBlLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FJGQgPSAnc3dpcGUnO1xuICBjb25zdCBFVkVOVF9LRVkkOSA9ICcuYnMuc3dpcGUnO1xuICBjb25zdCBFVkVOVF9UT1VDSFNUQVJUID0gYHRvdWNoc3RhcnQke0VWRU5UX0tFWSQ5fWA7XG4gIGNvbnN0IEVWRU5UX1RPVUNITU9WRSA9IGB0b3VjaG1vdmUke0VWRU5UX0tFWSQ5fWA7XG4gIGNvbnN0IEVWRU5UX1RPVUNIRU5EID0gYHRvdWNoZW5kJHtFVkVOVF9LRVkkOX1gO1xuICBjb25zdCBFVkVOVF9QT0lOVEVSRE9XTiA9IGBwb2ludGVyZG93biR7RVZFTlRfS0VZJDl9YDtcbiAgY29uc3QgRVZFTlRfUE9JTlRFUlVQID0gYHBvaW50ZXJ1cCR7RVZFTlRfS0VZJDl9YDtcbiAgY29uc3QgUE9JTlRFUl9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbiAgY29uc3QgUE9JTlRFUl9UWVBFX1BFTiA9ICdwZW4nO1xuICBjb25zdCBDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQgPSAncG9pbnRlci1ldmVudCc7XG4gIGNvbnN0IFNXSVBFX1RIUkVTSE9MRCA9IDQwO1xuICBjb25zdCBEZWZhdWx0JGMgPSB7XG4gICAgZW5kQ2FsbGJhY2s6IG51bGwsXG4gICAgbGVmdENhbGxiYWNrOiBudWxsLFxuICAgIHJpZ2h0Q2FsbGJhY2s6IG51bGxcbiAgfTtcbiAgY29uc3QgRGVmYXVsdFR5cGUkYyA9IHtcbiAgICBlbmRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKScsXG4gICAgbGVmdENhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJyxcbiAgICByaWdodENhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJ1xuICB9O1xuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBTd2lwZSBleHRlbmRzIENvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgIGlmICghZWxlbWVudCB8fCAhU3dpcGUuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy5fZGVsdGFYID0gMDtcbiAgICAgIHRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzID0gQm9vbGVhbih3aW5kb3cuUG9pbnRlckV2ZW50KTtcblxuICAgICAgdGhpcy5faW5pdEV2ZW50cygpO1xuICAgIH0gLy8gR2V0dGVyc1xuXG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCRjO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkYztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSRkO1xuICAgIH0gLy8gUHVibGljXG5cblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWSQ5KTtcbiAgICB9IC8vIFByaXZhdGVcblxuXG4gICAgX3N0YXJ0KGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaChldmVudCkpIHtcbiAgICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfZW5kKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5fZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaChldmVudCkpIHtcbiAgICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQuY2xpZW50WCAtIHRoaXMuX2RlbHRhWDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faGFuZGxlU3dpcGUoKTtcblxuICAgICAgZXhlY3V0ZSh0aGlzLl9jb25maWcuZW5kQ2FsbGJhY2spO1xuICAgIH1cblxuICAgIF9tb3ZlKGV2ZW50KSB7XG4gICAgICB0aGlzLl9kZWx0YVggPSBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSA/IDAgOiBldmVudC50b3VjaGVzWzBdLmNsaWVudFggLSB0aGlzLl9kZWx0YVg7XG4gICAgfVxuXG4gICAgX2hhbmRsZVN3aXBlKCkge1xuICAgICAgY29uc3QgYWJzRGVsdGFYID0gTWF0aC5hYnModGhpcy5fZGVsdGFYKTtcblxuICAgICAgaWYgKGFic0RlbHRhWCA8PSBTV0lQRV9USFJFU0hPTEQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBhYnNEZWx0YVggLyB0aGlzLl9kZWx0YVg7XG4gICAgICB0aGlzLl9kZWx0YVggPSAwO1xuXG4gICAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV4ZWN1dGUoZGlyZWN0aW9uID4gMCA/IHRoaXMuX2NvbmZpZy5yaWdodENhbGxiYWNrIDogdGhpcy5fY29uZmlnLmxlZnRDYWxsYmFjayk7XG4gICAgfVxuXG4gICAgX2luaXRFdmVudHMoKSB7XG4gICAgICBpZiAodGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1BPSU5URVJET1dOLCBldmVudCA9PiB0aGlzLl9zdGFydChldmVudCkpO1xuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfUE9JTlRFUlVQLCBldmVudCA9PiB0aGlzLl9lbmQoZXZlbnQpKTtcblxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSFNUQVJULCBldmVudCA9PiB0aGlzLl9zdGFydChldmVudCkpO1xuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hNT1ZFLCBldmVudCA9PiB0aGlzLl9tb3ZlKGV2ZW50KSk7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSEVORCwgZXZlbnQgPT4gdGhpcy5fZW5kKGV2ZW50KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2V2ZW50SXNQb2ludGVyUGVuVG91Y2goZXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdXBwb3J0UG9pbnRlckV2ZW50cyAmJiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9QRU4gfHwgZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9UT1VDSCk7XG4gICAgfSAvLyBTdGF0aWNcblxuXG4gICAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xuICAgICAgcmV0dXJuICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwO1xuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogY2Fyb3VzZWwuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkYyA9ICdjYXJvdXNlbCc7XG4gIGNvbnN0IERBVEFfS0VZJDggPSAnYnMuY2Fyb3VzZWwnO1xuICBjb25zdCBFVkVOVF9LRVkkOCA9IGAuJHtEQVRBX0tFWSQ4fWA7XG4gIGNvbnN0IERBVEFfQVBJX0tFWSQ1ID0gJy5kYXRhLWFwaSc7XG4gIGNvbnN0IEFSUk9XX0xFRlRfS0VZJDEgPSAnQXJyb3dMZWZ0JztcbiAgY29uc3QgQVJST1dfUklHSFRfS0VZJDEgPSAnQXJyb3dSaWdodCc7XG4gIGNvbnN0IFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgPSA1MDA7IC8vIFRpbWUgZm9yIG1vdXNlIGNvbXBhdCBldmVudHMgdG8gZmlyZSBhZnRlciB0b3VjaFxuXG4gIGNvbnN0IE9SREVSX05FWFQgPSAnbmV4dCc7XG4gIGNvbnN0IE9SREVSX1BSRVYgPSAncHJldic7XG4gIGNvbnN0IERJUkVDVElPTl9MRUZUID0gJ2xlZnQnO1xuICBjb25zdCBESVJFQ1RJT05fUklHSFQgPSAncmlnaHQnO1xuICBjb25zdCBFVkVOVF9TTElERSA9IGBzbGlkZSR7RVZFTlRfS0VZJDh9YDtcbiAgY29uc3QgRVZFTlRfU0xJRCA9IGBzbGlkJHtFVkVOVF9LRVkkOH1gO1xuICBjb25zdCBFVkVOVF9LRVlET1dOJDEgPSBga2V5ZG93biR7RVZFTlRfS0VZJDh9YDtcbiAgY29uc3QgRVZFTlRfTU9VU0VFTlRFUiQxID0gYG1vdXNlZW50ZXIke0VWRU5UX0tFWSQ4fWA7XG4gIGNvbnN0IEVWRU5UX01PVVNFTEVBVkUkMSA9IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVkkOH1gO1xuICBjb25zdCBFVkVOVF9EUkFHX1NUQVJUID0gYGRyYWdzdGFydCR7RVZFTlRfS0VZJDh9YDtcbiAgY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQzID0gYGxvYWQke0VWRU5UX0tFWSQ4fSR7REFUQV9BUElfS0VZJDV9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSA9IGBjbGljayR7RVZFTlRfS0VZJDh9JHtEQVRBX0FQSV9LRVkkNX1gO1xuICBjb25zdCBDTEFTU19OQU1FX0NBUk9VU0VMID0gJ2Nhcm91c2VsJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUkMiA9ICdhY3RpdmUnO1xuICBjb25zdCBDTEFTU19OQU1FX1NMSURFID0gJ3NsaWRlJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9FTkQgPSAnY2Fyb3VzZWwtaXRlbS1lbmQnO1xuICBjb25zdCBDTEFTU19OQU1FX1NUQVJUID0gJ2Nhcm91c2VsLWl0ZW0tc3RhcnQnO1xuICBjb25zdCBDTEFTU19OQU1FX05FWFQgPSAnY2Fyb3VzZWwtaXRlbS1uZXh0JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9QUkVWID0gJ2Nhcm91c2VsLWl0ZW0tcHJldic7XG4gIGNvbnN0IFNFTEVDVE9SX0FDVElWRSA9ICcuYWN0aXZlJztcbiAgY29uc3QgU0VMRUNUT1JfSVRFTSA9ICcuY2Fyb3VzZWwtaXRlbSc7XG4gIGNvbnN0IFNFTEVDVE9SX0FDVElWRV9JVEVNID0gU0VMRUNUT1JfQUNUSVZFICsgU0VMRUNUT1JfSVRFTTtcbiAgY29uc3QgU0VMRUNUT1JfSVRFTV9JTUcgPSAnLmNhcm91c2VsLWl0ZW0gaW1nJztcbiAgY29uc3QgU0VMRUNUT1JfSU5ESUNBVE9SUyA9ICcuY2Fyb3VzZWwtaW5kaWNhdG9ycyc7XG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfU0xJREUgPSAnW2RhdGEtYnMtc2xpZGVdLCBbZGF0YS1icy1zbGlkZS10b10nO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1JJREUgPSAnW2RhdGEtYnMtcmlkZT1cImNhcm91c2VsXCJdJztcbiAgY29uc3QgS0VZX1RPX0RJUkVDVElPTiA9IHtcbiAgICBbQVJST1dfTEVGVF9LRVkkMV06IERJUkVDVElPTl9SSUdIVCxcbiAgICBbQVJST1dfUklHSFRfS0VZJDFdOiBESVJFQ1RJT05fTEVGVFxuICB9O1xuICBjb25zdCBEZWZhdWx0JGIgPSB7XG4gICAgaW50ZXJ2YWw6IDUwMDAsXG4gICAga2V5Ym9hcmQ6IHRydWUsXG4gICAgcGF1c2U6ICdob3ZlcicsXG4gICAgcmlkZTogZmFsc2UsXG4gICAgdG91Y2g6IHRydWUsXG4gICAgd3JhcDogdHJ1ZVxuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSRiID0ge1xuICAgIGludGVydmFsOiAnKG51bWJlcnxib29sZWFuKScsXG4gICAgLy8gVE9ETzp2NiByZW1vdmUgYm9vbGVhbiBzdXBwb3J0XG4gICAga2V5Ym9hcmQ6ICdib29sZWFuJyxcbiAgICBwYXVzZTogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICAgIHJpZGU6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgICB0b3VjaDogJ2Jvb2xlYW4nLFxuICAgIHdyYXA6ICdib29sZWFuJ1xuICB9O1xuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBDYXJvdXNlbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnRvdWNoVGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLl9zd2lwZUhlbHBlciA9IG51bGw7XG4gICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfSU5ESUNBVE9SUywgdGhpcy5fZWxlbWVudCk7XG5cbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcucmlkZSA9PT0gQ0xBU1NfTkFNRV9DQVJPVVNFTCkge1xuICAgICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgICB9XG4gICAgfSAvLyBHZXR0ZXJzXG5cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JGI7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSRiO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJGM7XG4gICAgfSAvLyBQdWJsaWNcblxuXG4gICAgbmV4dCgpIHtcbiAgICAgIHRoaXMuX3NsaWRlKE9SREVSX05FWFQpO1xuICAgIH1cblxuICAgIG5leHRXaGVuVmlzaWJsZSgpIHtcbiAgICAgIC8vIEZJWE1FIFRPRE8gdXNlIGBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGVgXG4gICAgICAvLyBEb24ndCBjYWxsIG5leHQgd2hlbiB0aGUgcGFnZSBpc24ndCB2aXNpYmxlXG4gICAgICAvLyBvciB0aGUgY2Fyb3VzZWwgb3IgaXRzIHBhcmVudCBpc24ndCB2aXNpYmxlXG4gICAgICBpZiAoIWRvY3VtZW50LmhpZGRlbiAmJiBpc1Zpc2libGUodGhpcy5fZWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldigpIHtcbiAgICAgIHRoaXMuX3NsaWRlKE9SREVSX1BSRVYpO1xuICAgIH1cblxuICAgIHBhdXNlKCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2xlYXJJbnRlcnZhbCgpO1xuICAgIH1cblxuICAgIGN5Y2xlKCkge1xuICAgICAgdGhpcy5fY2xlYXJJbnRlcnZhbCgpO1xuXG4gICAgICB0aGlzLl91cGRhdGVJbnRlcnZhbCgpO1xuXG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMubmV4dFdoZW5WaXNpYmxlKCksIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCk7XG4gICAgfVxuXG4gICAgX21heWJlRW5hYmxlQ3ljbGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5yaWRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgICBFdmVudEhhbmRsZXIub25lKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NMSUQsICgpID0+IHRoaXMuY3ljbGUoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jeWNsZSgpO1xuICAgIH1cblxuICAgIHRvKGluZGV4KSB7XG4gICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zKCk7XG5cbiAgICAgIGlmIChpbmRleCA+IGl0ZW1zLmxlbmd0aCAtIDEgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgICBFdmVudEhhbmRsZXIub25lKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NMSUQsICgpID0+IHRoaXMudG8oaW5kZXgpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9nZXRBY3RpdmUoKSk7XG5cbiAgICAgIGlmIChhY3RpdmVJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcmRlciA9IGluZGV4ID4gYWN0aXZlSW5kZXggPyBPUkRFUl9ORVhUIDogT1JERVJfUFJFVjtcblxuICAgICAgdGhpcy5fc2xpZGUob3JkZXIsIGl0ZW1zW2luZGV4XSk7XG4gICAgfVxuXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIGlmICh0aGlzLl9zd2lwZUhlbHBlcikge1xuICAgICAgICB0aGlzLl9zd2lwZUhlbHBlci5kaXNwb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9IC8vIFByaXZhdGVcblxuXG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgICBjb25maWcuZGVmYXVsdEludGVydmFsID0gY29uZmlnLmludGVydmFsO1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOJDEsIGV2ZW50ID0+IHRoaXMuX2tleWRvd24oZXZlbnQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gJ2hvdmVyJykge1xuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VFTlRFUiQxLCAoKSA9PiB0aGlzLnBhdXNlKCkpO1xuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VMRUFWRSQxLCAoKSA9PiB0aGlzLl9tYXliZUVuYWJsZUN5Y2xlKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnRvdWNoICYmIFN3aXBlLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgdGhpcy5fYWRkVG91Y2hFdmVudExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgZm9yIChjb25zdCBpbWcgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNX0lNRywgdGhpcy5fZWxlbWVudCkpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKGltZywgRVZFTlRfRFJBR19TVEFSVCwgZXZlbnQgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVuZENhbGxCYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fY29uZmlnLnBhdXNlICE9PSAnaG92ZXInKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIElmIGl0J3MgYSB0b3VjaC1lbmFibGVkIGRldmljZSwgbW91c2VlbnRlci9sZWF2ZSBhcmUgZmlyZWQgYXNcbiAgICAgICAgLy8gcGFydCBvZiB0aGUgbW91c2UgY29tcGF0aWJpbGl0eSBldmVudHMgb24gZmlyc3QgdGFwIC0gdGhlIGNhcm91c2VsXG4gICAgICAgIC8vIHdvdWxkIHN0b3AgY3ljbGluZyB1bnRpbCB1c2VyIHRhcHBlZCBvdXQgb2YgaXQ7XG4gICAgICAgIC8vIGhlcmUsIHdlIGxpc3RlbiBmb3IgdG91Y2hlbmQsIGV4cGxpY2l0bHkgcGF1c2UgdGhlIGNhcm91c2VsXG4gICAgICAgIC8vIChhcyBpZiBpdCdzIHRoZSBzZWNvbmQgdGltZSB3ZSB0YXAgb24gaXQsIG1vdXNlZW50ZXIgY29tcGF0IGV2ZW50XG4gICAgICAgIC8vIGlzIE5PVCBmaXJlZCkgYW5kIGFmdGVyIGEgdGltZW91dCAodG8gYWxsb3cgZm9yIG1vdXNlIGNvbXBhdGliaWxpdHlcbiAgICAgICAgLy8gZXZlbnRzIHRvIGZpcmUpIHdlIGV4cGxpY2l0bHkgcmVzdGFydCBjeWNsaW5nXG5cblxuICAgICAgICB0aGlzLnBhdXNlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMudG91Y2hUaW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudG91Y2hUaW1lb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9tYXliZUVuYWJsZUN5Y2xlKCksIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgfTtcblxuICAgICAgY29uc3Qgc3dpcGVDb25maWcgPSB7XG4gICAgICAgIGxlZnRDYWxsYmFjazogKCkgPT4gdGhpcy5fc2xpZGUodGhpcy5fZGlyZWN0aW9uVG9PcmRlcihESVJFQ1RJT05fTEVGVCkpLFxuICAgICAgICByaWdodENhbGxiYWNrOiAoKSA9PiB0aGlzLl9zbGlkZSh0aGlzLl9kaXJlY3Rpb25Ub09yZGVyKERJUkVDVElPTl9SSUdIVCkpLFxuICAgICAgICBlbmRDYWxsYmFjazogZW5kQ2FsbEJhY2tcbiAgICAgIH07XG4gICAgICB0aGlzLl9zd2lwZUhlbHBlciA9IG5ldyBTd2lwZSh0aGlzLl9lbGVtZW50LCBzd2lwZUNvbmZpZyk7XG4gICAgfVxuXG4gICAgX2tleWRvd24oZXZlbnQpIHtcbiAgICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IEtFWV9UT19ESVJFQ1RJT05bZXZlbnQua2V5XTtcblxuICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoZGlyZWN0aW9uKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2dldEl0ZW1JbmRleChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0SXRlbXMoKS5pbmRleE9mKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIF9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX2luZGljYXRvcnNFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWN0aXZlSW5kaWNhdG9yID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9BQ1RJVkUsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KTtcbiAgICAgIGFjdGl2ZUluZGljYXRvci5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDIpO1xuICAgICAgYWN0aXZlSW5kaWNhdG9yLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50Jyk7XG4gICAgICBjb25zdCBuZXdBY3RpdmVJbmRpY2F0b3IgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKGBbZGF0YS1icy1zbGlkZS10bz1cIiR7aW5kZXh9XCJdYCwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpO1xuXG4gICAgICBpZiAobmV3QWN0aXZlSW5kaWNhdG9yKSB7XG4gICAgICAgIG5ld0FjdGl2ZUluZGljYXRvci5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDIpO1xuICAgICAgICBuZXdBY3RpdmVJbmRpY2F0b3Iuc2V0QXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnLCAndHJ1ZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF91cGRhdGVJbnRlcnZhbCgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9hY3RpdmVFbGVtZW50IHx8IHRoaXMuX2dldEFjdGl2ZSgpO1xuXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlbGVtZW50SW50ZXJ2YWwgPSBOdW1iZXIucGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtaW50ZXJ2YWwnKSwgMTApO1xuICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsID0gZWxlbWVudEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWw7XG4gICAgfVxuXG4gICAgX3NsaWRlKG9yZGVyLCBlbGVtZW50ID0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSB0aGlzLl9nZXRBY3RpdmUoKTtcblxuICAgICAgY29uc3QgaXNOZXh0ID0gb3JkZXIgPT09IE9SREVSX05FWFQ7XG4gICAgICBjb25zdCBuZXh0RWxlbWVudCA9IGVsZW1lbnQgfHwgZ2V0TmV4dEFjdGl2ZUVsZW1lbnQodGhpcy5fZ2V0SXRlbXMoKSwgYWN0aXZlRWxlbWVudCwgaXNOZXh0LCB0aGlzLl9jb25maWcud3JhcCk7XG5cbiAgICAgIGlmIChuZXh0RWxlbWVudCA9PT0gYWN0aXZlRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5leHRFbGVtZW50SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgobmV4dEVsZW1lbnQpO1xuXG4gICAgICBjb25zdCB0cmlnZ2VyRXZlbnQgPSBldmVudE5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZXZlbnROYW1lLCB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogbmV4dEVsZW1lbnQsXG4gICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKSxcbiAgICAgICAgICBmcm9tOiB0aGlzLl9nZXRJdGVtSW5kZXgoYWN0aXZlRWxlbWVudCksXG4gICAgICAgICAgdG86IG5leHRFbGVtZW50SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzbGlkZUV2ZW50ID0gdHJpZ2dlckV2ZW50KEVWRU5UX1NMSURFKTtcblxuICAgICAgaWYgKHNsaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghYWN0aXZlRWxlbWVudCB8fCAhbmV4dEVsZW1lbnQpIHtcbiAgICAgICAgLy8gU29tZSB3ZWlyZG5lc3MgaXMgaGFwcGVuaW5nLCBzbyB3ZSBiYWlsXG4gICAgICAgIC8vIHRvZG86IGNoYW5nZSB0ZXN0cyB0aGF0IHVzZSBlbXB0eSBkaXZzIHRvIGF2b2lkIHRoaXMgY2hlY2tcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0N5Y2xpbmcgPSBCb29sZWFuKHRoaXMuX2ludGVydmFsKTtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IHRydWU7XG5cbiAgICAgIHRoaXMuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQobmV4dEVsZW1lbnRJbmRleCk7XG5cbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gaXNOZXh0ID8gQ0xBU1NfTkFNRV9TVEFSVCA6IENMQVNTX05BTUVfRU5EO1xuICAgICAgY29uc3Qgb3JkZXJDbGFzc05hbWUgPSBpc05leHQgPyBDTEFTU19OQU1FX05FWFQgOiBDTEFTU19OQU1FX1BSRVY7XG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKG9yZGVyQ2xhc3NOYW1lKTtcbiAgICAgIHJlZmxvdyhuZXh0RWxlbWVudCk7XG4gICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xuICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlQ2FsbEJhY2sgPSAoKSA9PiB7XG4gICAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoZGlyZWN0aW9uYWxDbGFzc05hbWUsIG9yZGVyQ2xhc3NOYW1lKTtcbiAgICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQyKTtcbiAgICAgICAgYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDIsIG9yZGVyQ2xhc3NOYW1lLCBkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xuICAgICAgICB0cmlnZ2VyRXZlbnQoRVZFTlRfU0xJRCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlQ2FsbEJhY2ssIGFjdGl2ZUVsZW1lbnQsIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XG5cbiAgICAgIGlmIChpc0N5Y2xpbmcpIHtcbiAgICAgICAgdGhpcy5jeWNsZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9pc0FuaW1hdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0xJREUpO1xuICAgIH1cblxuICAgIF9nZXRBY3RpdmUoKSB7XG4gICAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9BQ1RJVkVfSVRFTSwgdGhpcy5fZWxlbWVudCk7XG4gICAgfVxuXG4gICAgX2dldEl0ZW1zKCkge1xuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSVRFTSwgdGhpcy5fZWxlbWVudCk7XG4gICAgfVxuXG4gICAgX2NsZWFySW50ZXJ2YWwoKSB7XG4gICAgICBpZiAodGhpcy5faW50ZXJ2YWwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfZGlyZWN0aW9uVG9PcmRlcihkaXJlY3Rpb24pIHtcbiAgICAgIGlmIChpc1JUTCgpKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERJUkVDVElPTl9MRUZUID8gT1JERVJfUFJFViA6IE9SREVSX05FWFQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERJUkVDVElPTl9MRUZUID8gT1JERVJfTkVYVCA6IE9SREVSX1BSRVY7XG4gICAgfVxuXG4gICAgX29yZGVyVG9EaXJlY3Rpb24ob3JkZXIpIHtcbiAgICAgIGlmIChpc1JUTCgpKSB7XG4gICAgICAgIHJldHVybiBvcmRlciA9PT0gT1JERVJfUFJFViA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3JkZXIgPT09IE9SREVSX1BSRVYgPyBESVJFQ1RJT05fUklHSFQgOiBESVJFQ1RJT05fTEVGVDtcbiAgICB9IC8vIFN0YXRpY1xuXG5cbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBDYXJvdXNlbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZGF0YS50byhjb25maWcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIH1cbiAgLyoqXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gICAqL1xuXG5cbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ1LCBTRUxFQ1RPUl9EQVRBX1NMSURFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpO1xuXG4gICAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9DQVJPVVNFTCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IGNhcm91c2VsID0gQ2Fyb3VzZWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpO1xuICAgIGNvbnN0IHNsaWRlSW5kZXggPSB0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS1icy1zbGlkZS10bycpO1xuXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgIGNhcm91c2VsLnRvKHNsaWRlSW5kZXgpO1xuXG4gICAgICBjYXJvdXNlbC5fbWF5YmVFbmFibGVDeWNsZSgpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGUodGhpcywgJ3NsaWRlJykgPT09ICduZXh0Jykge1xuICAgICAgY2Fyb3VzZWwubmV4dCgpO1xuXG4gICAgICBjYXJvdXNlbC5fbWF5YmVFbmFibGVDeWNsZSgpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2Fyb3VzZWwucHJldigpO1xuXG4gICAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKTtcbiAgfSk7XG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEkkMywgKCkgPT4ge1xuICAgIGNvbnN0IGNhcm91c2VscyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9SSURFKTtcblxuICAgIGZvciAoY29uc3QgY2Fyb3VzZWwgb2YgY2Fyb3VzZWxzKSB7XG4gICAgICBDYXJvdXNlbC5nZXRPckNyZWF0ZUluc3RhbmNlKGNhcm91c2VsKTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogalF1ZXJ5XG4gICAqL1xuXG4gIGRlZmluZUpRdWVyeVBsdWdpbihDYXJvdXNlbCk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogY29sbGFwc2UuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkYiA9ICdjb2xsYXBzZSc7XG4gIGNvbnN0IERBVEFfS0VZJDcgPSAnYnMuY29sbGFwc2UnO1xuICBjb25zdCBFVkVOVF9LRVkkNyA9IGAuJHtEQVRBX0tFWSQ3fWA7XG4gIGNvbnN0IERBVEFfQVBJX0tFWSQ0ID0gJy5kYXRhLWFwaSc7XG4gIGNvbnN0IEVWRU5UX1NIT1ckNiA9IGBzaG93JHtFVkVOVF9LRVkkN31gO1xuICBjb25zdCBFVkVOVF9TSE9XTiQ2ID0gYHNob3duJHtFVkVOVF9LRVkkN31gO1xuICBjb25zdCBFVkVOVF9ISURFJDYgPSBgaGlkZSR7RVZFTlRfS0VZJDd9YDtcbiAgY29uc3QgRVZFTlRfSElEREVOJDYgPSBgaGlkZGVuJHtFVkVOVF9LRVkkN31gO1xuICBjb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQ0ID0gYGNsaWNrJHtFVkVOVF9LRVkkN30ke0RBVEFfQVBJX0tFWSQ0fWA7XG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ3ID0gJ3Nob3cnO1xuICBjb25zdCBDTEFTU19OQU1FX0NPTExBUFNFID0gJ2NvbGxhcHNlJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTSU5HID0gJ2NvbGxhcHNpbmcnO1xuICBjb25zdCBDTEFTU19OQU1FX0NPTExBUFNFRCA9ICdjb2xsYXBzZWQnO1xuICBjb25zdCBDTEFTU19OQU1FX0RFRVBFUl9DSElMRFJFTiA9IGA6c2NvcGUgLiR7Q0xBU1NfTkFNRV9DT0xMQVBTRX0gLiR7Q0xBU1NfTkFNRV9DT0xMQVBTRX1gO1xuICBjb25zdCBDTEFTU19OQU1FX0hPUklaT05UQUwgPSAnY29sbGFwc2UtaG9yaXpvbnRhbCc7XG4gIGNvbnN0IFdJRFRIID0gJ3dpZHRoJztcbiAgY29uc3QgSEVJR0hUID0gJ2hlaWdodCc7XG4gIGNvbnN0IFNFTEVDVE9SX0FDVElWRVMgPSAnLmNvbGxhcHNlLnNob3csIC5jb2xsYXBzZS5jb2xsYXBzaW5nJztcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkNCA9ICdbZGF0YS1icy10b2dnbGU9XCJjb2xsYXBzZVwiXSc7XG4gIGNvbnN0IERlZmF1bHQkYSA9IHtcbiAgICBwYXJlbnQ6IG51bGwsXG4gICAgdG9nZ2xlOiB0cnVlXG4gIH07XG4gIGNvbnN0IERlZmF1bHRUeXBlJGEgPSB7XG4gICAgcGFyZW50OiAnKG51bGx8ZWxlbWVudCknLFxuICAgIHRvZ2dsZTogJ2Jvb2xlYW4nXG4gIH07XG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIENvbGxhcHNlIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSBbXTtcbiAgICAgIGNvbnN0IHRvZ2dsZUxpc3QgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQpO1xuXG4gICAgICBmb3IgKGNvbnN0IGVsZW0gb2YgdG9nZ2xlTGlzdCkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbSk7XG4gICAgICAgIGNvbnN0IGZpbHRlckVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yKS5maWx0ZXIoZm91bmRFbGVtZW50ID0+IGZvdW5kRWxlbWVudCA9PT0gdGhpcy5fZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsICYmIGZpbHRlckVsZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlckFycmF5LnB1c2goZWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdGlhbGl6ZUNoaWxkcmVuKCk7XG5cbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnBhcmVudCkge1xuICAgICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fdHJpZ2dlckFycmF5LCB0aGlzLl9pc1Nob3duKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnRvZ2dsZSkge1xuICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgfVxuICAgIH0gLy8gR2V0dGVyc1xuXG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCRhO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkYTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSRiO1xuICAgIH0gLy8gUHVibGljXG5cblxuICAgIHRvZ2dsZSgpIHtcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzaG93KCkge1xuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCB0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgYWN0aXZlQ2hpbGRyZW4gPSBbXTsgLy8gZmluZCBhY3RpdmUgY2hpbGRyZW5cblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgICAgYWN0aXZlQ2hpbGRyZW4gPSB0aGlzLl9nZXRGaXJzdExldmVsQ2hpbGRyZW4oU0VMRUNUT1JfQUNUSVZFUykuZmlsdGVyKGVsZW1lbnQgPT4gZWxlbWVudCAhPT0gdGhpcy5fZWxlbWVudCkubWFwKGVsZW1lbnQgPT4gQ29sbGFwc2UuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCB7XG4gICAgICAgICAgdG9nZ2xlOiBmYWxzZVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3RpdmVDaGlsZHJlbi5sZW5ndGggJiYgYWN0aXZlQ2hpbGRyZW5bMF0uX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDYpO1xuXG4gICAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBhY3RpdmVJbnN0YW5jZSBvZiBhY3RpdmVDaGlsZHJlbikge1xuICAgICAgICBhY3RpdmVJbnN0YW5jZS5oaWRlKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRSk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAwO1xuXG4gICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fdHJpZ2dlckFycmF5LCB0cnVlKTtcblxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNFLCBDTEFTU19OQU1FX1NIT1ckNyk7XG5cbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDYpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgY2FwaXRhbGl6ZWREaW1lbnNpb24gPSBkaW1lbnNpb25bMF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSgxKTtcbiAgICAgIGNvbnN0IHNjcm9sbFNpemUgPSBgc2Nyb2xsJHtjYXBpdGFsaXplZERpbWVuc2lvbn1gO1xuXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudFtzY3JvbGxTaXplXX1weGA7XG4gICAgfVxuXG4gICAgaGlkZSgpIHtcbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgIXRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDYpO1xuXG4gICAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IGAke3RoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZGltZW5zaW9uXX1weGA7XG4gICAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRSwgQ0xBU1NfTkFNRV9TSE9XJDcpO1xuXG4gICAgICBmb3IgKGNvbnN0IHRyaWdnZXIgb2YgdGhpcy5fdHJpZ2dlckFycmF5KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRyaWdnZXIpO1xuXG4gICAgICAgIGlmIChlbGVtZW50ICYmICF0aGlzLl9pc1Nob3duKGVsZW1lbnQpKSB7XG4gICAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFt0cmlnZ2VyXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcblxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTRSk7XG5cbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDYpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XG5cbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xuICAgIH1cblxuICAgIF9pc1Nob3duKGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDcpO1xuICAgIH0gLy8gUHJpdmF0ZVxuXG5cbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICAgIGNvbmZpZy50b2dnbGUgPSBCb29sZWFuKGNvbmZpZy50b2dnbGUpOyAvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlc1xuXG4gICAgICBjb25maWcucGFyZW50ID0gZ2V0RWxlbWVudChjb25maWcucGFyZW50KTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgX2dldERpbWVuc2lvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0hPUklaT05UQUwpID8gV0lEVEggOiBIRUlHSFQ7XG4gICAgfVxuXG4gICAgX2luaXRpYWxpemVDaGlsZHJlbigpIHtcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnBhcmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQpO1xuXG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhbZWxlbWVudF0sIHRoaXMuX2lzU2hvd24oc2VsZWN0ZWQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRGaXJzdExldmVsQ2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gU2VsZWN0b3JFbmdpbmUuZmluZChDTEFTU19OQU1FX0RFRVBFUl9DSElMRFJFTiwgdGhpcy5fY29uZmlnLnBhcmVudCk7IC8vIHJlbW92ZSBjaGlsZHJlbiBpZiBncmVhdGVyIGRlcHRoXG5cbiAgICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yLCB0aGlzLl9jb25maWcucGFyZW50KS5maWx0ZXIoZWxlbWVudCA9PiAhY2hpbGRyZW4uaW5jbHVkZXMoZWxlbWVudCkpO1xuICAgIH1cblxuICAgIF9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModHJpZ2dlckFycmF5LCBpc09wZW4pIHtcbiAgICAgIGlmICghdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0cmlnZ2VyQXJyYXkpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX05BTUVfQ09MTEFQU0VELCAhaXNPcGVuKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pO1xuICAgICAgfVxuICAgIH0gLy8gU3RhdGljXG5cblxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICBjb25zdCBfY29uZmlnID0ge307XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJyAmJiAvc2hvd3xoaWRlLy50ZXN0KGNvbmZpZykpIHtcbiAgICAgICAgX2NvbmZpZy50b2dnbGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBDb2xsYXBzZS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIF9jb25maWcpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIH1cbiAgLyoqXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gICAqL1xuXG5cbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ0LCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0LCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBwcmV2ZW50RGVmYXVsdCBvbmx5IGZvciA8YT4gZWxlbWVudHMgKHdoaWNoIGNoYW5nZSB0aGUgVVJMKSBub3QgaW5zaWRlIHRoZSBjb2xsYXBzaWJsZSBlbGVtZW50XG4gICAgaWYgKGV2ZW50LnRhcmdldC50YWdOYW1lID09PSAnQScgfHwgZXZlbnQuZGVsZWdhdGVUYXJnZXQgJiYgZXZlbnQuZGVsZWdhdGVUYXJnZXQudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKTtcbiAgICBjb25zdCBzZWxlY3RvckVsZW1lbnRzID0gU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3Rvcik7XG5cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2Ygc2VsZWN0b3JFbGVtZW50cykge1xuICAgICAgQ29sbGFwc2UuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCB7XG4gICAgICAgIHRvZ2dsZTogZmFsc2VcbiAgICAgIH0pLnRvZ2dsZSgpO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBqUXVlcnlcbiAgICovXG5cbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKENvbGxhcHNlKTtcblxuICB2YXIgdG9wID0gJ3RvcCc7XG4gIHZhciBib3R0b20gPSAnYm90dG9tJztcbiAgdmFyIHJpZ2h0ID0gJ3JpZ2h0JztcbiAgdmFyIGxlZnQgPSAnbGVmdCc7XG4gIHZhciBhdXRvID0gJ2F1dG8nO1xuICB2YXIgYmFzZVBsYWNlbWVudHMgPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcbiAgdmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbiAgdmFyIGVuZCA9ICdlbmQnO1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gJ2NsaXBwaW5nUGFyZW50cyc7XG4gIHZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG4gIHZhciBwb3BwZXIgPSAncG9wcGVyJztcbiAgdmFyIHJlZmVyZW5jZSA9ICdyZWZlcmVuY2UnO1xuICB2YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG4gIH0sIFtdKTtcbiAgdmFyIHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovW10uY29uY2F0KGJhc2VQbGFjZW1lbnRzLCBbYXV0b10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xuICB9LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5cbiAgdmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG4gIHZhciByZWFkID0gJ3JlYWQnO1xuICB2YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5cbiAgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG4gIHZhciBtYWluID0gJ21haW4nO1xuICB2YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcblxuICB2YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xuICB2YXIgd3JpdGUgPSAnd3JpdGUnO1xuICB2YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcbiAgdmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdO1xuXG4gIGZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG5cbiAgICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93IDogd2luZG93O1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICAgIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAgIC8vIElFIDExIGhhcyBubyBTaGFkb3dSb290XG4gICAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xuICB9XG5cbiAgLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG4gIGZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcbiAgICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgICAgLy8gZWZmZWN0aXZlIHdheSB0byBhcHBseSBzdHlsZXMgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuXG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVmZmVjdCQyKF9yZWYyKSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gICAgdmFyIGluaXRpYWxTdHlsZXMgPSB7XG4gICAgICBwb3BwZXI6IHtcbiAgICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICAgIGxlZnQ6ICcwJyxcbiAgICAgICAgdG9wOiAnMCcsXG4gICAgICAgIG1hcmdpbjogJzAnXG4gICAgICB9LFxuICAgICAgYXJyb3c6IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICAgIH0sXG4gICAgICByZWZlcmVuY2U6IHt9XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuICAgIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICAgIHZhciBzdHlsZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhzdGF0ZS5zdHlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBzdGF0ZS5zdHlsZXNbbmFtZV0gOiBpbml0aWFsU3R5bGVzW25hbWVdKTsgLy8gU2V0IGFsbCB2YWx1ZXMgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIHVuc2V0IHRoZW1cblxuICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbiAgY29uc3QgYXBwbHlTdHlsZXMkMSA9IHtcbiAgICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgcGhhc2U6ICd3cml0ZScsXG4gICAgZm46IGFwcGx5U3R5bGVzLFxuICAgIGVmZmVjdDogZWZmZWN0JDIsXG4gICAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIH1cblxuICB2YXIgbWF4ID0gTWF0aC5tYXg7XG4gIHZhciBtaW4gPSBNYXRoLm1pbjtcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcblxuICBmdW5jdGlvbiBnZXRVQVN0cmluZygpIHtcbiAgICB2YXIgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG5cbiAgICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLmJyYW5kcykge1xuICAgICAgcmV0dXJuIHVhRGF0YS5icmFuZHMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmJyYW5kICsgXCIvXCIgKyBpdGVtLnZlcnNpb247XG4gICAgICB9KS5qb2luKCcgJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICAgIHJldHVybiAhL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChnZXRVQVN0cmluZygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSkge1xuICAgIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzRml4ZWRTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHNjYWxlWCA9IDE7XG4gICAgdmFyIHNjYWxlWSA9IDE7XG5cbiAgICBpZiAoaW5jbHVkZVNjYWxlICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xuICAgICAgc2NhbGVZID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgPiAwID8gcm91bmQoY2xpZW50UmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSA6IDE7XG4gICAgfVxuXG4gICAgdmFyIF9yZWYgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3csXG4gICAgICAgIHZpc3VhbFZpZXdwb3J0ID0gX3JlZi52aXN1YWxWaWV3cG9ydDtcblxuICAgIHZhciBhZGRWaXN1YWxPZmZzZXRzID0gIWlzTGF5b3V0Vmlld3BvcnQoKSAmJiBpc0ZpeGVkU3RyYXRlZ3k7XG4gICAgdmFyIHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC8gc2NhbGVYO1xuICAgIHZhciB5ID0gKGNsaWVudFJlY3QudG9wICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3AgOiAwKSkgLyBzY2FsZVk7XG4gICAgdmFyIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlWDtcbiAgICB2YXIgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgdG9wOiB5LFxuICAgICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICAgIGxlZnQ6IHgsXG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gIH1cblxuICAvLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbiAgZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50KSB7XG4gICAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAgIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gICAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgICB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgICBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gICAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gICAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICAgIHZhciBuZXh0ID0gY2hpbGQ7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICAgIH0gd2hpbGUgKG5leHQpO1xuICAgICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KSB7XG4gICAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5kZXhPZihnZXROb2RlTmFtZShlbGVtZW50KSkgPj0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcblxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgICBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgfSAvLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xuICAvLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG4gIGZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gICAgdmFyIGlzRmlyZWZveCA9IC9maXJlZm94L2kudGVzdChnZXRVQVN0cmluZygpKTtcbiAgICB2YXIgaXNJRSA9IC9UcmlkZW50L2kudGVzdChnZXRVQVN0cmluZygpKTtcblxuICAgIGlmIChpc0lFICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcbiAgICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpO1xuXG4gICAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gICAgaWYgKGlzU2hhZG93Um9vdChjdXJyZW50Tm9kZSkpIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuaG9zdDtcbiAgICB9XG5cbiAgICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgWydodG1sJywgJ2JvZHknXS5pbmRleE9mKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkgPCAwKSB7XG4gICAgICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcblxuICAgICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuICAvLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuXG5cbiAgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUkMShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZSQxKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xuICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aGluKG1pbiQxLCB2YWx1ZSwgbWF4JDEpIHtcbiAgICByZXR1cm4gbWF4KG1pbiQxLCBtaW4odmFsdWUsIG1heCQxKSk7XG4gIH1cbiAgZnVuY3Rpb24gd2l0aGluTWF4Q2xhbXAobWluLCB2YWx1ZSwgbWF4KSB7XG4gICAgdmFyIHYgPSB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KTtcbiAgICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG4gIH1cblxuICBmdW5jdGlvbiBleHBhbmRUb0hhc2hNYXAodmFsdWUsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xuICAgICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gaGFzaE1hcDtcbiAgICB9LCB7fSk7XG4gIH1cblxuICB2YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gICAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgICB9KSkgOiBwYWRkaW5nO1xuICAgIHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gICAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gICAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhZGRpbmdPYmplY3QgPSB0b1BhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nLCBzdGF0ZSk7XG4gICAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICAgIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICAgIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICAgIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xuICAgIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICAgIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICAgIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICAgIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICAgIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICAgIHZhciBheGlzUHJvcCA9IGF4aXM7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVmZmVjdCQxKF9yZWYyKSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xuICAgIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxuICAgICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gICAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gICAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4gIGNvbnN0IGFycm93JDEgPSB7XG4gICAgbmFtZTogJ2Fycm93JyxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHBoYXNlOiAnbWFpbicsXG4gICAgZm46IGFycm93LFxuICAgIGVmZmVjdDogZWZmZWN0JDEsXG4gICAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICAgIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J11cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuICB9XG5cbiAgdmFyIHVuc2V0U2lkZXMgPSB7XG4gICAgdG9wOiAnYXV0bycsXG4gICAgcmlnaHQ6ICdhdXRvJyxcbiAgICBib3R0b206ICdhdXRvJyxcbiAgICBsZWZ0OiAnYXV0bydcbiAgfTsgLy8gUm91bmQgdGhlIG9mZnNldHMgdG8gdGhlIG5lYXJlc3Qgc3VpdGFibGUgc3VicGl4ZWwgYmFzZWQgb24gdGhlIERQUi5cbiAgLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbiAgLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5cbiAgZnVuY3Rpb24gcm91bmRPZmZzZXRzQnlEUFIoX3JlZikge1xuICAgIHZhciB4ID0gX3JlZi54LFxuICAgICAgICB5ID0gX3JlZi55O1xuICAgIHZhciB3aW4gPSB3aW5kb3c7XG4gICAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXG4gICAgICB5OiByb3VuZCh5ICogZHByKSAvIGRwciB8fCAwXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcFRvU3R5bGVzKF9yZWYyKSB7XG4gICAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICAgIHZhciBwb3BwZXIgPSBfcmVmMi5wb3BwZXIsXG4gICAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxuICAgICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICAgIHZhcmlhdGlvbiA9IF9yZWYyLnZhcmlhdGlvbixcbiAgICAgICAgb2Zmc2V0cyA9IF9yZWYyLm9mZnNldHMsXG4gICAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9yZWYyLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgICAgYWRhcHRpdmUgPSBfcmVmMi5hZGFwdGl2ZSxcbiAgICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzLFxuICAgICAgICBpc0ZpeGVkID0gX3JlZjIuaXNGaXhlZDtcbiAgICB2YXIgX29mZnNldHMkeCA9IG9mZnNldHMueCxcbiAgICAgICAgeCA9IF9vZmZzZXRzJHggPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR4LFxuICAgICAgICBfb2Zmc2V0cyR5ID0gb2Zmc2V0cy55LFxuICAgICAgICB5ID0gX29mZnNldHMkeSA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHk7XG5cbiAgICB2YXIgX3JlZjMgPSB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfSkgOiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG5cbiAgICB4ID0gX3JlZjMueDtcbiAgICB5ID0gX3JlZjMueTtcbiAgICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgICB2YXIgaGFzWSA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3knKTtcbiAgICB2YXIgc2lkZVggPSBsZWZ0O1xuICAgIHZhciBzaWRlWSA9IHRvcDtcbiAgICB2YXIgd2luID0gd2luZG93O1xuXG4gICAgaWYgKGFkYXB0aXZlKSB7XG4gICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgICB2YXIgaGVpZ2h0UHJvcCA9ICdjbGllbnRIZWlnaHQnO1xuICAgICAgdmFyIHdpZHRoUHJvcCA9ICdjbGllbnRXaWR0aCc7XG5cbiAgICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xuXG4gICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlJDEob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgICBoZWlnaHRQcm9wID0gJ3Njcm9sbEhlaWdodCc7XG4gICAgICAgICAgd2lkdGhQcm9wID0gJ3Njcm9sbFdpZHRoJztcbiAgICAgICAgfVxuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcblxuXG4gICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQ7XG5cbiAgICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICAgIHNpZGVZID0gYm90dG9tO1xuICAgICAgICB2YXIgb2Zmc2V0WSA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF07XG4gICAgICAgIHkgLT0gb2Zmc2V0WSAtIHBvcHBlclJlY3QuaGVpZ2h0O1xuICAgICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCAocGxhY2VtZW50ID09PSB0b3AgfHwgcGxhY2VtZW50ID09PSBib3R0b20pICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICAgIHNpZGVYID0gcmlnaHQ7XG4gICAgICAgIHZhciBvZmZzZXRYID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgb2Zmc2V0UGFyZW50W3dpZHRoUHJvcF07XG4gICAgICAgIHggLT0gb2Zmc2V0WCAtIHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgIH0sIGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpO1xuXG4gICAgdmFyIF9yZWY0ID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIoe1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9KSA6IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcblxuICAgIHggPSBfcmVmNC54O1xuICAgIHkgPSBfcmVmNC55O1xuXG4gICAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xuICAgICAgdmFyIF9PYmplY3QkYXNzaWduO1xuXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yLnRyYW5zZm9ybSA9ICcnLCBfT2JqZWN0JGFzc2lnbjIpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoX3JlZjUpIHtcbiAgICB2YXIgc3RhdGUgPSBfcmVmNS5zdGF0ZSxcbiAgICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gICAgdmFyIF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXG4gICAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgICAgYWRhcHRpdmUgPSBfb3B0aW9ucyRhZGFwdGl2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFkYXB0aXZlLFxuICAgICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcbiAgICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuXG4gICAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgICAgdmFyaWF0aW9uOiBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KSxcbiAgICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uOiBncHVBY2NlbGVyYXRpb24sXG4gICAgICBpc0ZpeGVkOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnXG4gICAgfTtcblxuICAgIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgICAgc3RhdGUuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5wb3BwZXIsIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgICBhZGFwdGl2ZTogYWRhcHRpdmUsXG4gICAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgICB9KSkpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5hcnJvdywgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBhZGFwdGl2ZTogZmFsc2UsXG4gICAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgICB9KSkpO1xuICAgIH1cblxuICAgIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgICB9KTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuICBjb25zdCBjb21wdXRlU3R5bGVzJDEgPSB7XG4gICAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gICAgZm46IGNvbXB1dGVTdHlsZXMsXG4gICAgZGF0YToge31cbiAgfTtcblxuICB2YXIgcGFzc2l2ZSA9IHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gZWZmZWN0KF9yZWYpIHtcbiAgICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gICAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXG4gICAgICAgIF9vcHRpb25zJHJlc2l6ZSA9IG9wdGlvbnMucmVzaXplLFxuICAgICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gICAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xuICAgIHZhciBzY3JvbGxQYXJlbnRzID0gW10uY29uY2F0KHN0YXRlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCBzdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG5cbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgICAgc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzaXplKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfVxuICAgIH07XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbiAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSB7XG4gICAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHBoYXNlOiAnd3JpdGUnLFxuICAgIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICAgIGVmZmVjdDogZWZmZWN0LFxuICAgIGRhdGE6IHt9XG4gIH07XG5cbiAgdmFyIGhhc2gkMSA9IHtcbiAgICBsZWZ0OiAncmlnaHQnLFxuICAgIHJpZ2h0OiAnbGVmdCcsXG4gICAgYm90dG9tOiAndG9wJyxcbiAgICB0b3A6ICdib3R0b20nXG4gIH07XG4gIGZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICAgIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgICByZXR1cm4gaGFzaCQxW21hdGNoZWRdO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc2ggPSB7XG4gICAgc3RhcnQ6ICdlbmQnLFxuICAgIGVuZDogJ3N0YXJ0J1xuICB9O1xuICBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICAgIHZhciB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XG4gICAgdmFyIHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQ7XG4gICAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAgIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbiAgICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAgIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cbiAgICAvLyBhbnl3YXkuXG4gICAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxuICAgIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgICB2YXIgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICAgIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICAgIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgICB2YXIgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHkgPSAwO1xuXG4gICAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgICAgdmFyIGxheW91dFZpZXdwb3J0ID0gaXNMYXlvdXRWaWV3cG9ydCgpO1xuXG4gICAgICBpZiAobGF5b3V0Vmlld3BvcnQgfHwgIWxheW91dFZpZXdwb3J0ICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgICAgeTogeVxuICAgIH07XG4gIH1cblxuICAvLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlXG5cbiAgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gICAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gICAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgICB2YXIgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xuICAgIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gICAgdmFyIHkgPSAtd2luU2Nyb2xsLnNjcm9sbFRvcDtcblxuICAgIGlmIChnZXRDb21wdXRlZFN0eWxlJDEoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApIC0gd2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAgIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcbiAgICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCksXG4gICAgICAgIG92ZXJmbG93ID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3csXG4gICAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcbiAgICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gICAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICAgIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG4gIH1cblxuICAvKlxuICBnaXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xuICB1bnRpbCB3ZSBnZXQgdG8gdGhlIHRvcCB3aW5kb3cgb2JqZWN0LiBUaGlzIGxpc3QgaXMgd2hhdCB3ZSBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyc1xuICB0bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG4gIHJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4gICovXG5cbiAgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICAgIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgICBsaXN0ID0gW107XG4gICAgfVxuXG4gICAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gICAgdmFyIHRhcmdldCA9IGlzQm9keSA/IFt3aW5dLmNvbmNhdCh3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzU2Nyb2xsUGFyZW50KHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXSkgOiBzY3JvbGxQYXJlbnQ7XG4gICAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgICB1cGRhdGVkTGlzdC5jb25jYXQobGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZSh0YXJnZXQpKSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgICAgbGVmdDogcmVjdC54LFxuICAgICAgdG9wOiByZWN0LnksXG4gICAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgZmFsc2UsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gICAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICAgIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICByZWN0LmhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIHJlY3QueCA9IHJlY3QubGVmdDtcbiAgICByZWN0LnkgPSByZWN0LnRvcDtcbiAgICByZXR1cm4gcmVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkge1xuICAgIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkpIDogaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSA/IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkgOiByZWN0VG9DbGllbnRSZWN0KGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpKTtcbiAgfSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuICAvLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbiAgLy8gYGluaXRpYWxgXG5cblxuICBmdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xuICAgIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgICB2YXIgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gICAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICAgIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGlwcGluZ1BhcmVudCkge1xuICAgICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5JztcbiAgICB9KTtcbiAgfSAvLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4gIC8vIGNsaXBwaW5nIHBhcmVudHNcblxuXG4gIGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSkge1xuICAgIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcbiAgICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KTtcbiAgICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgICByZXR1cm4gYWNjUmVjdDtcbiAgICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkpO1xuICAgIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICAgIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xuICAgIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgICByZXR1cm4gY2xpcHBpbmdSZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZU9mZnNldHMoX3JlZikge1xuICAgIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcbiAgICAgICAgcGxhY2VtZW50ID0gX3JlZi5wbGFjZW1lbnQ7XG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICAgIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XG4gICAgdmFyIGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcbiAgICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gICAgdmFyIG9mZnNldHM7XG5cbiAgICBzd2l0Y2ggKGJhc2VQbGFjZW1lbnQpIHtcbiAgICAgIGNhc2UgdG9wOlxuICAgICAgICBvZmZzZXRzID0ge1xuICAgICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBib3R0b206XG4gICAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgcmlnaHQ6XG4gICAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgICAgeTogY29tbW9uWVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBsZWZ0OlxuICAgICAgICBvZmZzZXRzID0ge1xuICAgICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZWxlbWVudC53aWR0aCxcbiAgICAgICAgICB5OiBjb21tb25ZXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvZmZzZXRzID0ge1xuICAgICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICAgIGNhc2Ugc3RhcnQ6XG4gICAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSAtIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGVuZDpcbiAgICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdICsgKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXRzO1xuICB9XG5cbiAgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgICAgX29wdGlvbnMkc3RyYXRlZ3kgPSBfb3B0aW9ucy5zdHJhdGVneSxcbiAgICAgICAgc3RyYXRlZ3kgPSBfb3B0aW9ucyRzdHJhdGVneSA9PT0gdm9pZCAwID8gc3RhdGUuc3RyYXRlZ3kgOiBfb3B0aW9ucyRzdHJhdGVneSxcbiAgICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBwb3BwZXIgOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXG4gICAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gICAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICAgIHZhciBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcbiAgICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgICB2YXIgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IGdldERvY3VtZW50RWxlbWVudChzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSk7XG4gICAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcbiAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gICAgfSk7XG4gICAgdmFyIHBvcHBlckNsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHBvcHBlck9mZnNldHMpKTtcbiAgICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgICB2YXIgb3ZlcmZsb3dPZmZzZXRzID0ge1xuICAgICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICAgIGxlZnQ6IGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCxcbiAgICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgICB9O1xuICAgIHZhciBvZmZzZXREYXRhID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7IC8vIE9mZnNldHMgY2FuIGJlIGFwcGxpZWQgb25seSB0byB0aGUgcG9wcGVyIGVsZW1lbnRcblxuICAgIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgICBPYmplY3Qua2V5cyhvdmVyZmxvd09mZnNldHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgICAgb3ZlcmZsb3dPZmZzZXRzW2tleV0gKz0gb2Zmc2V0W2F4aXNdICogbXVsdGlwbHk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3ZlcmZsb3dPZmZzZXRzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgICBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPSBfb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gICAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9PT0gdm9pZCAwID8gcGxhY2VtZW50cyA6IF9vcHRpb25zJGFsbG93ZWRBdXRvUDtcbiAgICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gICAgdmFyIHBsYWNlbWVudHMkMSA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICAgIH0pIDogYmFzZVBsYWNlbWVudHM7XG4gICAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyQxLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICByZXR1cm4gYWxsb3dlZEF1dG9QbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KSA+PSAwO1xuICAgIH0pO1xuXG4gICAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzJDE7XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgICB2YXIgb3ZlcmZsb3dzID0gYWxsb3dlZFBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgICAgfSlbZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpXTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICAgIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgICBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgPSBvcHRpb25zLmZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGZsaXBWYXJpYXRpbyxcbiAgICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gICAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICAgIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpO1xuICAgIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gICAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICAgIHZhciBwbGFjZW1lbnRzID0gW3ByZWZlcnJlZFBsYWNlbWVudF0uY29uY2F0KGZhbGxiYWNrUGxhY2VtZW50cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICAgIGZsaXBWYXJpYXRpb25zOiBmbGlwVmFyaWF0aW9ucyxcbiAgICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICAgIH0pIDogcGxhY2VtZW50KTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gICAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gICAgdmFyIGNoZWNrc01hcCA9IG5ldyBNYXAoKTtcbiAgICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgICAgdmFyIGlzU3RhcnRWYXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gc3RhcnQ7XG4gICAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgICAgfSk7XG4gICAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgICAgdmFyIGNoZWNrcyA9IFtdO1xuXG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICB9KSkge1xuICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gICAgfVxuXG4gICAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgICB2YXIgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcblxuICAgICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfaSA9IG51bWJlck9mQ2hlY2tzOyBfaSA+IDA7IF9pLS0pIHtcbiAgICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwID0gdHJ1ZTtcbiAgICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgICB9XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbiAgY29uc3QgZmxpcCQxID0ge1xuICAgIG5hbWU6ICdmbGlwJyxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHBoYXNlOiAnbWFpbicsXG4gICAgZm46IGZsaXAsXG4gICAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgICBkYXRhOiB7XG4gICAgICBfc2tpcDogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QsIHByZXZlbnRlZE9mZnNldHMpIHtcbiAgICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcbiAgICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgICByZXR1cm4gW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0uc29tZShmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAgIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICAgIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3c7XG4gICAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICAgIH0pO1xuICAgIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICAgIH0pO1xuICAgIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gICAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gICAgdmFyIGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XG4gICAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzLFxuICAgICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAgIGhhc1BvcHBlckVzY2FwZWQ6IGhhc1BvcHBlckVzY2FwZWRcbiAgICB9O1xuICAgIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgICB9KTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuICBjb25zdCBoaWRlJDEgPSB7XG4gICAgbmFtZTogJ2hpZGUnLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgcGhhc2U6ICdtYWluJyxcbiAgICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICAgIGZuOiBoaWRlXG4gIH07XG5cbiAgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gICAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xuXG4gICAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICAgIH0pKSA6IG9mZnNldCxcbiAgICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gICAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgICB4OiBkaXN0YW5jZSxcbiAgICAgIHk6IHNraWRkaW5nXG4gICAgfSA6IHtcbiAgICAgIHg6IHNraWRkaW5nLFxuICAgICAgeTogZGlzdGFuY2VcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxuICAgICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xuICAgIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXG4gICAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICAgIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0geDtcbiAgICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gICAgfVxuXG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbiAgY29uc3Qgb2Zmc2V0JDEgPSB7XG4gICAgbmFtZTogJ29mZnNldCcsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBwaGFzZTogJ21haW4nLFxuICAgIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgICBmbjogb2Zmc2V0XG4gIH07XG5cbiAgZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAgIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xuICAgICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gICAgfSk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbiAgY29uc3QgcG9wcGVyT2Zmc2V0cyQxID0ge1xuICAgIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHBoYXNlOiAncmVhZCcsXG4gICAgZm46IHBvcHBlck9mZnNldHMsXG4gICAgZGF0YToge31cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAgIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICAgIHRldGhlciA9IF9vcHRpb25zJHRldGhlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHRldGhlcixcbiAgICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gICAgfSk7XG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gICAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICAgIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICAgIHZhciBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICAgIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICAgIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICAgIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gICAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICAgIHZhciBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgICAgbWFpbkF4aXM6IHRldGhlck9mZnNldFZhbHVlLFxuICAgICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcbiAgICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgICBtYWluQXhpczogMCxcbiAgICAgIGFsdEF4aXM6IDBcbiAgICB9LCB0ZXRoZXJPZmZzZXRWYWx1ZSk7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyU3RhdGUgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0W3N0YXRlLnBsYWNlbWVudF0gOiBudWxsO1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuXG4gICAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQ7XG5cbiAgICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICAgIHZhciBtaW4kMSA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICAgIHZhciBtYXgkMSA9IG9mZnNldCAtIG92ZXJmbG93W2FsdFNpZGVdO1xuICAgICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuICAgICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgICB2YXIgbWF4TGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IC1wb3BwZXJSZWN0W2xlbl0gOiAtcmVmZXJlbmNlUmVjdFtsZW5dOyAvLyBXZSBuZWVkIHRvIGluY2x1ZGUgdGhlIGFycm93IGluIHRoZSBjYWxjdWxhdGlvbiBzbyB0aGUgYXJyb3cgZG9lc24ndCBnb1xuICAgICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuXG4gICAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KSA6IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfTtcbiAgICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxuICAgICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cbiAgICAgIC8vIHdpZHRoIG9yIGhlaWdodClcblxuICAgICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgICAgdmFyIG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IHJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgLSBhZGRpdGl2ZSAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWF4TGVuICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcbiAgICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJCA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbbWFpbkF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkIDogMDtcbiAgICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgICAgdmFyIHRldGhlck1heCA9IG9mZnNldCArIG1heE9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWU7XG4gICAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1pbihtaW4kMSwgdGV0aGVyTWluKSA6IG1pbiQxLCBvZmZzZXQsIHRldGhlciA/IG1heChtYXgkMSwgdGV0aGVyTWF4KSA6IG1heCQxKTtcbiAgICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDI7XG5cbiAgICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgICB2YXIgX29mZnNldCA9IHBvcHBlck9mZnNldHNbYWx0QXhpc107XG5cbiAgICAgIHZhciBfbGVuID0gYWx0QXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgICB2YXIgX21heCA9IF9vZmZzZXQgLSBvdmVyZmxvd1tfYWx0U2lkZV07XG5cbiAgICAgIHZhciBpc09yaWdpblNpZGUgPSBbdG9wLCBsZWZ0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAgICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XG5cbiAgICAgIHZhciBfdGV0aGVyTWluID0gaXNPcmlnaW5TaWRlID8gX21pbiA6IF9vZmZzZXQgLSByZWZlcmVuY2VSZWN0W19sZW5dIC0gcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXM7XG5cbiAgICAgIHZhciBfdGV0aGVyTWF4ID0gaXNPcmlnaW5TaWRlID8gX29mZnNldCArIHJlZmVyZW5jZVJlY3RbX2xlbl0gKyBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcyA6IF9tYXg7XG5cbiAgICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XG5cbiAgICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0O1xuICAgICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4gIGNvbnN0IHByZXZlbnRPdmVyZmxvdyQxID0ge1xuICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgcGhhc2U6ICdtYWluJyxcbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRWxlbWVudFNjYWxlZChlbGVtZW50KSB7XG4gICAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgICB2YXIgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbiAgfSAvLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4gIC8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cblxuXG4gIGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICAgIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gICAgdmFyIG9mZnNldFBhcmVudElzU2NhbGVkID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzRWxlbWVudFNjYWxlZChvZmZzZXRQYXJlbnQpO1xuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50SXNTY2FsZWQsIGlzRml4ZWQpO1xuICAgIHZhciBzY3JvbGwgPSB7XG4gICAgICBzY3JvbGxMZWZ0OiAwLFxuICAgICAgc2Nyb2xsVG9wOiAwXG4gICAgfTtcbiAgICB2YXIgb2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcblxuICAgIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gICAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9yZGVyKG1vZGlmaWVycykge1xuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gICAgfSk7IC8vIE9uIHZpc2l0aW5nIG9iamVjdCwgY2hlY2sgZm9yIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHZpc2l0IHRoZW0gcmVjdXJzaXZlbHlcblxuICAgIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXN1bHQucHVzaChtb2RpZmllcik7XG4gICAgfVxuXG4gICAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gICAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuXG4gICAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XG4gICAgICB9KSk7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgICB2YXIgcGVuZGluZztcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGVuZGluZztcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VCeU5hbWUobW9kaWZpZXJzKSB7XG4gICAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIGN1cnJlbnQsIHtcbiAgICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcbiAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxuICAgICAgfSkgOiBjdXJyZW50O1xuICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgIG1vZGlmaWVyczogW10sXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcbiAgfTtcblxuICBmdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcbiAgICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcbiAgICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgICAgcG9wcGVyOiBwb3BwZXJcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgIHN0eWxlczoge31cbiAgICAgIH07XG4gICAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhzZXRPcHRpb25zQWN0aW9uKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xuICAgICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxuICAgICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMobWVyZ2VCeU5hbWUoW10uY29uY2F0KGRlZmF1bHRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSkpOyAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG5cbiAgICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgICAgfSk7IC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBtb2RpZmllcnMgc28gdGhhdCB0aGUgY29uc3VtZXIgd2lsbCBnZXQgd2FybmVkXG5cbiAgICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgICAgLy8gbG9naWMuXG4gICAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxuICAgICAgICAgICAgICByZWZlcmVuY2UgPSBfc3RhdGUkZWxlbWVudHMucmVmZXJlbmNlLFxuICAgICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgICAvLyBhbnltb3JlXG5cbiAgICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuXG5cbiAgICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpXG4gICAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cbiAgICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kaWZpZXIuZGF0YSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcblxuICAgICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX3N0YXRlJG9yZGVyZWRNb2RpZmllID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxuICAgICAgICAgICAgICAgIF9vcHRpb25zID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9PT0gdm9pZCAwID8ge30gOiBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBzdGF0ZSA9IGZuKHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgICAgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICAgIHVwZGF0ZTogZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgICAvLyBjeWNsZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG1vZGlmaWVyIGFkZHMgc29tZSBwZXJzaXN0ZW50IGRhdGEgdGhhdFxuICAgICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgICAvLyBvbmUuXG5cbiAgICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICAgIHZhciBuYW1lID0gX3JlZjMubmFtZSxcbiAgICAgICAgICAgICAgX3JlZjMkb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnMsXG4gICAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmMyRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYzJG9wdGlvbnMsXG4gICAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYzLmVmZmVjdDtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG4gIHZhciBjcmVhdGVQb3BwZXIkMiA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG4gIHZhciBkZWZhdWx0TW9kaWZpZXJzJDEgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMkMSwgY29tcHV0ZVN0eWxlcyQxLCBhcHBseVN0eWxlcyQxXTtcbiAgdmFyIGNyZWF0ZVBvcHBlciQxID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gICAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVycyQxXG4gIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbiAgdmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMkMSwgY29tcHV0ZVN0eWxlcyQxLCBhcHBseVN0eWxlcyQxLCBvZmZzZXQkMSwgZmxpcCQxLCBwcmV2ZW50T3ZlcmZsb3ckMSwgYXJyb3ckMSwgaGlkZSQxXTtcbiAgdmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICAgIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbiAgfSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuICBjb25zdCBQb3BwZXIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSgvKiNfX1BVUkVfXyovT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgcG9wcGVyR2VuZXJhdG9yLFxuICAgIGRldGVjdE92ZXJmbG93LFxuICAgIGNyZWF0ZVBvcHBlckJhc2U6IGNyZWF0ZVBvcHBlciQyLFxuICAgIGNyZWF0ZVBvcHBlcixcbiAgICBjcmVhdGVQb3BwZXJMaXRlOiBjcmVhdGVQb3BwZXIkMSxcbiAgICB0b3AsXG4gICAgYm90dG9tLFxuICAgIHJpZ2h0LFxuICAgIGxlZnQsXG4gICAgYXV0byxcbiAgICBiYXNlUGxhY2VtZW50cyxcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgY2xpcHBpbmdQYXJlbnRzLFxuICAgIHZpZXdwb3J0LFxuICAgIHBvcHBlcixcbiAgICByZWZlcmVuY2UsXG4gICAgdmFyaWF0aW9uUGxhY2VtZW50cyxcbiAgICBwbGFjZW1lbnRzLFxuICAgIGJlZm9yZVJlYWQsXG4gICAgcmVhZCxcbiAgICBhZnRlclJlYWQsXG4gICAgYmVmb3JlTWFpbixcbiAgICBtYWluLFxuICAgIGFmdGVyTWFpbixcbiAgICBiZWZvcmVXcml0ZSxcbiAgICB3cml0ZSxcbiAgICBhZnRlcldyaXRlLFxuICAgIG1vZGlmaWVyUGhhc2VzLFxuICAgIGFwcGx5U3R5bGVzOiBhcHBseVN0eWxlcyQxLFxuICAgIGFycm93OiBhcnJvdyQxLFxuICAgIGNvbXB1dGVTdHlsZXM6IGNvbXB1dGVTdHlsZXMkMSxcbiAgICBldmVudExpc3RlbmVycyxcbiAgICBmbGlwOiBmbGlwJDEsXG4gICAgaGlkZTogaGlkZSQxLFxuICAgIG9mZnNldDogb2Zmc2V0JDEsXG4gICAgcG9wcGVyT2Zmc2V0czogcG9wcGVyT2Zmc2V0cyQxLFxuICAgIHByZXZlbnRPdmVyZmxvdzogcHJldmVudE92ZXJmbG93JDFcbiAgfSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KSk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogZHJvcGRvd24uanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkYSA9ICdkcm9wZG93bic7XG4gIGNvbnN0IERBVEFfS0VZJDYgPSAnYnMuZHJvcGRvd24nO1xuICBjb25zdCBFVkVOVF9LRVkkNiA9IGAuJHtEQVRBX0tFWSQ2fWA7XG4gIGNvbnN0IERBVEFfQVBJX0tFWSQzID0gJy5kYXRhLWFwaSc7XG4gIGNvbnN0IEVTQ0FQRV9LRVkkMiA9ICdFc2NhcGUnO1xuICBjb25zdCBUQUJfS0VZJDEgPSAnVGFiJztcbiAgY29uc3QgQVJST1dfVVBfS0VZJDEgPSAnQXJyb3dVcCc7XG4gIGNvbnN0IEFSUk9XX0RPV05fS0VZJDEgPSAnQXJyb3dEb3duJztcbiAgY29uc3QgUklHSFRfTU9VU0VfQlVUVE9OID0gMjsgLy8gTW91c2VFdmVudC5idXR0b24gdmFsdWUgZm9yIHRoZSBzZWNvbmRhcnkgYnV0dG9uLCB1c3VhbGx5IHRoZSByaWdodCBidXR0b25cblxuICBjb25zdCBFVkVOVF9ISURFJDUgPSBgaGlkZSR7RVZFTlRfS0VZJDZ9YDtcbiAgY29uc3QgRVZFTlRfSElEREVOJDUgPSBgaGlkZGVuJHtFVkVOVF9LRVkkNn1gO1xuICBjb25zdCBFVkVOVF9TSE9XJDUgPSBgc2hvdyR7RVZFTlRfS0VZJDZ9YDtcbiAgY29uc3QgRVZFTlRfU0hPV04kNSA9IGBzaG93biR7RVZFTlRfS0VZJDZ9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMyA9IGBjbGljayR7RVZFTlRfS0VZJDZ9JHtEQVRBX0FQSV9LRVkkM31gO1xuICBjb25zdCBFVkVOVF9LRVlET1dOX0RBVEFfQVBJID0gYGtleWRvd24ke0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfS0VZVVBfREFUQV9BUEkgPSBga2V5dXAke0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDYgPSAnc2hvdyc7XG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUFVQID0gJ2Ryb3B1cCc7XG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUEVORCA9ICdkcm9wZW5kJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9EUk9QU1RBUlQgPSAnZHJvcHN0YXJ0JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9EUk9QVVBfQ0VOVEVSID0gJ2Ryb3B1cC1jZW50ZXInO1xuICBjb25zdCBDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUiA9ICdkcm9wZG93bi1jZW50ZXInO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImRyb3Bkb3duXCJdOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJztcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEVfU0hPV04gPSBgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzfS4ke0NMQVNTX05BTUVfU0hPVyQ2fWA7XG4gIGNvbnN0IFNFTEVDVE9SX01FTlUgPSAnLmRyb3Bkb3duLW1lbnUnO1xuICBjb25zdCBTRUxFQ1RPUl9OQVZCQVIgPSAnLm5hdmJhcic7XG4gIGNvbnN0IFNFTEVDVE9SX05BVkJBUl9OQVYgPSAnLm5hdmJhci1uYXYnO1xuICBjb25zdCBTRUxFQ1RPUl9WSVNJQkxFX0lURU1TID0gJy5kcm9wZG93bi1tZW51IC5kcm9wZG93bi1pdGVtOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJztcbiAgY29uc3QgUExBQ0VNRU5UX1RPUCA9IGlzUlRMKCkgPyAndG9wLWVuZCcgOiAndG9wLXN0YXJ0JztcbiAgY29uc3QgUExBQ0VNRU5UX1RPUEVORCA9IGlzUlRMKCkgPyAndG9wLXN0YXJ0JyA6ICd0b3AtZW5kJztcbiAgY29uc3QgUExBQ0VNRU5UX0JPVFRPTSA9IGlzUlRMKCkgPyAnYm90dG9tLWVuZCcgOiAnYm90dG9tLXN0YXJ0JztcbiAgY29uc3QgUExBQ0VNRU5UX0JPVFRPTUVORCA9IGlzUlRMKCkgPyAnYm90dG9tLXN0YXJ0JyA6ICdib3R0b20tZW5kJztcbiAgY29uc3QgUExBQ0VNRU5UX1JJR0hUID0gaXNSVEwoKSA/ICdsZWZ0LXN0YXJ0JyA6ICdyaWdodC1zdGFydCc7XG4gIGNvbnN0IFBMQUNFTUVOVF9MRUZUID0gaXNSVEwoKSA/ICdyaWdodC1zdGFydCcgOiAnbGVmdC1zdGFydCc7XG4gIGNvbnN0IFBMQUNFTUVOVF9UT1BDRU5URVIgPSAndG9wJztcbiAgY29uc3QgUExBQ0VNRU5UX0JPVFRPTUNFTlRFUiA9ICdib3R0b20nO1xuICBjb25zdCBEZWZhdWx0JDkgPSB7XG4gICAgYXV0b0Nsb3NlOiB0cnVlLFxuICAgIGJvdW5kYXJ5OiAnY2xpcHBpbmdQYXJlbnRzJyxcbiAgICBkaXNwbGF5OiAnZHluYW1pYycsXG4gICAgb2Zmc2V0OiBbMCwgMl0sXG4gICAgcG9wcGVyQ29uZmlnOiBudWxsLFxuICAgIHJlZmVyZW5jZTogJ3RvZ2dsZSdcbiAgfTtcbiAgY29uc3QgRGVmYXVsdFR5cGUkOSA9IHtcbiAgICBhdXRvQ2xvc2U6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgICBib3VuZGFyeTogJyhzdHJpbmd8ZWxlbWVudCknLFxuICAgIGRpc3BsYXk6ICdzdHJpbmcnLFxuICAgIG9mZnNldDogJyhhcnJheXxzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3R8ZnVuY3Rpb24pJyxcbiAgICByZWZlcmVuY2U6ICcoc3RyaW5nfGVsZW1lbnR8b2JqZWN0KSdcbiAgfTtcbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgRHJvcGRvd24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuICAgICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlOyAvLyBkcm9wZG93biB3cmFwcGVyXG4gICAgICAvLyB0b2RvOiB2NiByZXZlcnQgIzM3MDExICYgY2hhbmdlIG1hcmt1cCBodHRwczovL2dldGJvb3RzdHJhcC5jb20vZG9jcy81LjIvZm9ybXMvaW5wdXQtZ3JvdXAvXG5cbiAgICAgIHRoaXMuX21lbnUgPSBTZWxlY3RvckVuZ2luZS5uZXh0KHRoaXMuX2VsZW1lbnQsIFNFTEVDVE9SX01FTlUpWzBdIHx8IFNlbGVjdG9yRW5naW5lLnByZXYodGhpcy5fZWxlbWVudCwgU0VMRUNUT1JfTUVOVSlbMF0gfHwgU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9NRU5VLCB0aGlzLl9wYXJlbnQpO1xuICAgICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcbiAgICB9IC8vIEdldHRlcnNcblxuXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQkOTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkYTtcbiAgICB9IC8vIFB1YmxpY1xuXG5cbiAgICB0b2dnbGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgICB9XG5cbiAgICBzaG93KCkge1xuICAgICAgaWYgKGlzRGlzYWJsZWQodGhpcy5fZWxlbWVudCkgfHwgdGhpcy5faXNTaG93bigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckNSwgcmVsYXRlZFRhcmdldCk7XG5cbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHBlcigpOyAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxuXG5cbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgIXRoaXMuX3BhcmVudC5jbG9zZXN0KFNFTEVDVE9SX05BVkJBUl9OQVYpKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcblxuICAgICAgdGhpcy5fbWVudS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ2KTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ2KTtcblxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kNSwgcmVsYXRlZFRhcmdldCk7XG4gICAgfVxuXG4gICAgaGlkZSgpIHtcbiAgICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8ICF0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9jb21wbGV0ZUhpZGUocmVsYXRlZFRhcmdldCk7XG4gICAgfVxuXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCk7XG5cbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0gLy8gUHJpdmF0ZVxuXG5cbiAgICBfY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNSwgcmVsYXRlZFRhcmdldCk7XG5cbiAgICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxuXG5cbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xuICAgICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbWVudS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ2KTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ2KTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcblxuICAgICAgTWFuaXB1bGF0b3IucmVtb3ZlRGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJyk7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kNSwgcmVsYXRlZFRhcmdldCk7XG4gICAgfVxuXG4gICAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9IHN1cGVyLl9nZXRDb25maWcoY29uZmlnKTtcblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcucmVmZXJlbmNlID09PSAnb2JqZWN0JyAmJiAhaXNFbGVtZW50JDEoY29uZmlnLnJlZmVyZW5jZSkgJiYgdHlwZW9mIGNvbmZpZy5yZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFBvcHBlciB2aXJ0dWFsIGVsZW1lbnRzIHJlcXVpcmUgYSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgbWV0aG9kXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7TkFNRSRhLnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCJyZWZlcmVuY2VcIiBwcm92aWRlZCB0eXBlIFwib2JqZWN0XCIgd2l0aG91dCBhIHJlcXVpcmVkIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIgbWV0aG9kLmApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIF9jcmVhdGVQb3BwZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyBkcm9wZG93bnMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZyknKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgIH0gZWxzZSBpZiAoaXNFbGVtZW50JDEodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IGdldEVsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fY29uZmlnLnJlZmVyZW5jZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcG9wcGVyQ29uZmlnID0gdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCk7XG5cbiAgICAgIHRoaXMuX3BvcHBlciA9IGNyZWF0ZVBvcHBlcihyZWZlcmVuY2VFbGVtZW50LCB0aGlzLl9tZW51LCBwb3BwZXJDb25maWcpO1xuICAgIH1cblxuICAgIF9pc1Nob3duKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ2KTtcbiAgICB9XG5cbiAgICBfZ2V0UGxhY2VtZW50KCkge1xuICAgICAgY29uc3QgcGFyZW50RHJvcGRvd24gPSB0aGlzLl9wYXJlbnQ7XG5cbiAgICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRU5EKSkge1xuICAgICAgICByZXR1cm4gUExBQ0VNRU5UX1JJR0hUO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFNUQVJUKSkge1xuICAgICAgICByZXR1cm4gUExBQ0VNRU5UX0xFRlQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QVVBfQ0VOVEVSKSkge1xuICAgICAgICByZXR1cm4gUExBQ0VNRU5UX1RPUENFTlRFUjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUikpIHtcbiAgICAgICAgcmV0dXJuIFBMQUNFTUVOVF9CT1RUT01DRU5URVI7XG4gICAgICB9IC8vIFdlIG5lZWQgdG8gdHJpbSB0aGUgdmFsdWUgYmVjYXVzZSBjdXN0b20gcHJvcGVydGllcyBjYW4gYWxzbyBpbmNsdWRlIHNwYWNlc1xuXG5cbiAgICAgIGNvbnN0IGlzRW5kID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9tZW51KS5nZXRQcm9wZXJ0eVZhbHVlKCctLWJzLXBvc2l0aW9uJykudHJpbSgpID09PSAnZW5kJztcblxuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BVUCkpIHtcbiAgICAgICAgcmV0dXJuIGlzRW5kID8gUExBQ0VNRU5UX1RPUEVORCA6IFBMQUNFTUVOVF9UT1A7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc0VuZCA/IFBMQUNFTUVOVF9CT1RUT01FTkQgOiBQTEFDRU1FTlRfQk9UVE9NO1xuICAgIH1cblxuICAgIF9kZXRlY3ROYXZiYXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX05BVkJBUikgIT09IG51bGw7XG4gICAgfVxuXG4gICAgX2dldE9mZnNldCgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xuXG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldC5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiBOdW1iZXIucGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBwb3BwZXJEYXRhID0+IG9mZnNldChwb3BwZXJEYXRhLCB0aGlzLl9lbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBfZ2V0UG9wcGVyQ29uZmlnKCkge1xuICAgICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxuICAgICAgICBtb2RpZmllcnM6IFt7XG4gICAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgYm91bmRhcnk6IHRoaXMuX2NvbmZpZy5ib3VuZGFyeVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgICB9XG4gICAgICAgIH1dXG4gICAgICB9OyAvLyBEaXNhYmxlIFBvcHBlciBpZiB3ZSBoYXZlIGEgc3RhdGljIGRpc3BsYXkgb3IgRHJvcGRvd24gaXMgaW4gTmF2YmFyXG5cbiAgICAgIGlmICh0aGlzLl9pbk5hdmJhciB8fCB0aGlzLl9jb25maWcuZGlzcGxheSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJywgJ3N0YXRpYycpOyAvLyB0b2RvOnY2IHJlbW92ZVxuXG4gICAgICAgIGRlZmF1bHRCc1BvcHBlckNvbmZpZy5tb2RpZmllcnMgPSBbe1xuICAgICAgICAgIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgfV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcbiAgICAgICAgLi4uKHR5cGVvZiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnID09PSAnZnVuY3Rpb24nID8gdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyhkZWZhdWx0QnNQb3BwZXJDb25maWcpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgX3NlbGVjdE1lbnVJdGVtKHtcbiAgICAgIGtleSxcbiAgICAgIHRhcmdldFxuICAgIH0pIHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9WSVNJQkxFX0lURU1TLCB0aGlzLl9tZW51KS5maWx0ZXIoZWxlbWVudCA9PiBpc1Zpc2libGUoZWxlbWVudCkpO1xuXG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGlmIHRhcmdldCBpc24ndCBpbmNsdWRlZCBpbiBpdGVtcyAoZS5nLiB3aGVuIGV4cGFuZGluZyB0aGUgZHJvcGRvd24pXG4gICAgICAvLyBhbGxvdyBjeWNsaW5nIHRvIGdldCB0aGUgbGFzdCBpdGVtIGluIGNhc2Uga2V5IGVxdWFscyBBUlJPV19VUF9LRVlcblxuXG4gICAgICBnZXROZXh0QWN0aXZlRWxlbWVudChpdGVtcywgdGFyZ2V0LCBrZXkgPT09IEFSUk9XX0RPV05fS0VZJDEsICFpdGVtcy5pbmNsdWRlcyh0YXJnZXQpKS5mb2N1cygpO1xuICAgIH0gLy8gU3RhdGljXG5cblxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xlYXJNZW51cyhldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gUklHSFRfTU9VU0VfQlVUVE9OIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ICE9PSBUQUJfS0VZJDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcGVuVG9nZ2xlcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEVfU0hPV04pO1xuXG4gICAgICBmb3IgKGNvbnN0IHRvZ2dsZSBvZiBvcGVuVG9nZ2xlcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gRHJvcGRvd24uZ2V0SW5zdGFuY2UodG9nZ2xlKTtcblxuICAgICAgICBpZiAoIWNvbnRleHQgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbXBvc2VkUGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgICAgICBjb25zdCBpc01lbnVUYXJnZXQgPSBjb21wb3NlZFBhdGguaW5jbHVkZXMoY29udGV4dC5fbWVudSk7XG5cbiAgICAgICAgaWYgKGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhjb250ZXh0Ll9lbGVtZW50KSB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSAnaW5zaWRlJyAmJiAhaXNNZW51VGFyZ2V0IHx8IGNvbnRleHQuX2NvbmZpZy5hdXRvQ2xvc2UgPT09ICdvdXRzaWRlJyAmJiBpc01lbnVUYXJnZXQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBUYWIgbmF2aWdhdGlvbiB0aHJvdWdoIHRoZSBkcm9wZG93biBtZW51IG9yIGV2ZW50cyBmcm9tIGNvbnRhaW5lZCBpbnB1dHMgc2hvdWxkbid0IGNsb3NlIHRoZSBtZW51XG5cblxuICAgICAgICBpZiAoY29udGV4dC5fbWVudS5jb250YWlucyhldmVudC50YXJnZXQpICYmIChldmVudC50eXBlID09PSAna2V5dXAnICYmIGV2ZW50LmtleSA9PT0gVEFCX0tFWSQxIHx8IC9pbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGZvcm0vaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogY29udGV4dC5fZWxlbWVudFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldC5jbGlja0V2ZW50ID0gZXZlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Ll9jb21wbGV0ZUhpZGUocmVsYXRlZFRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGRhdGFBcGlLZXlkb3duSGFuZGxlcihldmVudCkge1xuICAgICAgLy8gSWYgbm90IGFuIFVQIHwgRE9XTiB8IEVTQ0FQRSBrZXkgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgICAgLy8gSWYgaW5wdXQvdGV4dGFyZWEgJiYgaWYga2V5IGlzIG90aGVyIHRoYW4gRVNDQVBFID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcbiAgICAgIGNvbnN0IGlzSW5wdXQgPSAvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKTtcbiAgICAgIGNvbnN0IGlzRXNjYXBlRXZlbnQgPSBldmVudC5rZXkgPT09IEVTQ0FQRV9LRVkkMjtcbiAgICAgIGNvbnN0IGlzVXBPckRvd25FdmVudCA9IFtBUlJPV19VUF9LRVkkMSwgQVJST1dfRE9XTl9LRVkkMV0uaW5jbHVkZXMoZXZlbnQua2V5KTtcblxuICAgICAgaWYgKCFpc1VwT3JEb3duRXZlbnQgJiYgIWlzRXNjYXBlRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNJbnB1dCAmJiAhaXNFc2NhcGVFdmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHRvZG86IHY2IHJldmVydCAjMzcwMTEgJiBjaGFuZ2UgbWFya3VwIGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS9kb2NzLzUuMi9mb3Jtcy9pbnB1dC1ncm91cC9cblxuICAgICAgY29uc3QgZ2V0VG9nZ2xlQnV0dG9uID0gdGhpcy5tYXRjaGVzKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMpID8gdGhpcyA6IFNlbGVjdG9yRW5naW5lLnByZXYodGhpcywgU0VMRUNUT1JfREFUQV9UT0dHTEUkMylbMF0gfHwgU2VsZWN0b3JFbmdpbmUubmV4dCh0aGlzLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzKVswXSB8fCBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMsIGV2ZW50LmRlbGVnYXRlVGFyZ2V0LnBhcmVudE5vZGUpO1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBEcm9wZG93bi5nZXRPckNyZWF0ZUluc3RhbmNlKGdldFRvZ2dsZUJ1dHRvbik7XG5cbiAgICAgIGlmIChpc1VwT3JEb3duRXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGluc3RhbmNlLnNob3coKTtcblxuICAgICAgICBpbnN0YW5jZS5fc2VsZWN0TWVudUl0ZW0oZXZlbnQpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGluc3RhbmNlLl9pc1Nob3duKCkpIHtcbiAgICAgICAgLy8gZWxzZSBpcyBlc2NhcGUgYW5kIHdlIGNoZWNrIGlmIGl0IGlzIHNob3duXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgICAgIGdldFRvZ2dsZUJ1dHRvbi5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cblxuICB9XG4gIC8qKlxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICAgKi9cblxuXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgRHJvcGRvd24uZGF0YUFwaUtleWRvd25IYW5kbGVyKTtcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9LRVlET1dOX0RBVEFfQVBJLCBTRUxFQ1RPUl9NRU5VLCBEcm9wZG93bi5kYXRhQXBpS2V5ZG93bkhhbmRsZXIpO1xuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMsIERyb3Bkb3duLmNsZWFyTWVudXMpO1xuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWVVQX0RBVEFfQVBJLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQzLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykudG9nZ2xlKCk7XG4gIH0pO1xuICAvKipcbiAgICogalF1ZXJ5XG4gICAqL1xuXG4gIGRlZmluZUpRdWVyeVBsdWdpbihEcm9wZG93bik7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogdXRpbC9zY3JvbGxCYXIuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQgPSAnLmZpeGVkLXRvcCwgLmZpeGVkLWJvdHRvbSwgLmlzLWZpeGVkLCAuc3RpY2t5LXRvcCc7XG4gIGNvbnN0IFNFTEVDVE9SX1NUSUNLWV9DT05URU5UID0gJy5zdGlja3ktdG9wJztcbiAgY29uc3QgUFJPUEVSVFlfUEFERElORyA9ICdwYWRkaW5nLXJpZ2h0JztcbiAgY29uc3QgUFJPUEVSVFlfTUFSR0lOID0gJ21hcmdpbi1yaWdodCc7XG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIFNjcm9sbEJhckhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcbiAgICB9IC8vIFB1YmxpY1xuXG5cbiAgICBnZXRXaWR0aCgpIHtcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvaW5uZXJXaWR0aCN1c2FnZV9ub3Rlc1xuICAgICAgY29uc3QgZG9jdW1lbnRXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50V2lkdGgpO1xuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcblxuICAgICAgdGhpcy5fZGlzYWJsZU92ZXJGbG93KCk7IC8vIGdpdmUgcGFkZGluZyB0byBlbGVtZW50IHRvIGJhbGFuY2UgdGhlIGhpZGRlbiBzY3JvbGxiYXIgd2lkdGhcblxuXG4gICAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBQUk9QRVJUWV9QQURESU5HLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgd2lkdGgpOyAvLyB0cmljazogV2UgYWRqdXN0IHBvc2l0aXZlIHBhZGRpbmdSaWdodCBhbmQgbmVnYXRpdmUgbWFyZ2luUmlnaHQgdG8gc3RpY2t5LXRvcCBlbGVtZW50cyB0byBrZWVwIHNob3dpbmcgZnVsbHdpZHRoXG5cblxuICAgICAgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfRklYRURfQ09OVEVOVCwgUFJPUEVSVFlfUEFERElORywgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSArIHdpZHRoKTtcblxuICAgICAgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQsIFBST1BFUlRZX01BUkdJTiwgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSAtIHdpZHRoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgJ292ZXJmbG93Jyk7XG5cbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgUFJPUEVSVFlfUEFERElORyk7XG5cbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfRklYRURfQ09OVEVOVCwgUFJPUEVSVFlfUEFERElORyk7XG5cbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQsIFBST1BFUlRZX01BUkdJTik7XG4gICAgfVxuXG4gICAgaXNPdmVyZmxvd2luZygpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFdpZHRoKCkgPiAwO1xuICAgIH0gLy8gUHJpdmF0ZVxuXG5cbiAgICBfZGlzYWJsZU92ZXJGbG93KCkge1xuICAgICAgdGhpcy5fc2F2ZUluaXRpYWxBdHRyaWJ1dGUodGhpcy5fZWxlbWVudCwgJ292ZXJmbG93Jyk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9XG5cbiAgICBfc2V0RWxlbWVudEF0dHJpYnV0ZXMoc2VsZWN0b3IsIHN0eWxlUHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcblxuICAgICAgY29uc3QgbWFuaXB1bGF0aW9uQ2FsbEJhY2sgPSBlbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnQgIT09IHRoaXMuX2VsZW1lbnQgJiYgd2luZG93LmlubmVyV2lkdGggPiBlbGVtZW50LmNsaWVudFdpZHRoICsgc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KTtcblxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkVmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlUHJvcGVydHkpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHN0eWxlUHJvcGVydHksIGAke2NhbGxiYWNrKE51bWJlci5wYXJzZUZsb2F0KGNhbGN1bGF0ZWRWYWx1ZSkpfXB4YCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBtYW5pcHVsYXRpb25DYWxsQmFjayk7XG4gICAgfVxuXG4gICAgX3NhdmVJbml0aWFsQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpIHtcbiAgICAgIGNvbnN0IGFjdHVhbFZhbHVlID0gZWxlbWVudC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlUHJvcGVydHkpO1xuXG4gICAgICBpZiAoYWN0dWFsVmFsdWUpIHtcbiAgICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5LCBhY3R1YWxWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoc2VsZWN0b3IsIHN0eWxlUHJvcGVydHkpIHtcbiAgICAgIGNvbnN0IG1hbmlwdWxhdGlvbkNhbGxCYWNrID0gZWxlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KTsgLy8gV2Ugb25seSB3YW50IHRvIHJlbW92ZSB0aGUgcHJvcGVydHkgaWYgdGhlIHZhbHVlIGlzIGBudWxsYDsgdGhlIHZhbHVlIGNhbiBhbHNvIGJlIHplcm9cblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KHN0eWxlUHJvcGVydHkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIE1hbmlwdWxhdG9yLnJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSk7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgbWFuaXB1bGF0aW9uQ2FsbEJhY2spO1xuICAgIH1cblxuICAgIF9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBjYWxsQmFjaykge1xuICAgICAgaWYgKGlzRWxlbWVudCQxKHNlbGVjdG9yKSkge1xuICAgICAgICBjYWxsQmFjayhzZWxlY3Rvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBzZWwgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvciwgdGhpcy5fZWxlbWVudCkpIHtcbiAgICAgICAgY2FsbEJhY2soc2VsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IHV0aWwvYmFja2Ryb3AuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkOSA9ICdiYWNrZHJvcCc7XG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQ0ID0gJ2ZhZGUnO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckNSA9ICdzaG93JztcbiAgY29uc3QgRVZFTlRfTU9VU0VET1dOID0gYG1vdXNlZG93bi5icy4ke05BTUUkOX1gO1xuICBjb25zdCBEZWZhdWx0JDggPSB7XG4gICAgY2xhc3NOYW1lOiAnbW9kYWwtYmFja2Ryb3AnLFxuICAgIGNsaWNrQ2FsbGJhY2s6IG51bGwsXG4gICAgaXNBbmltYXRlZDogZmFsc2UsXG4gICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgIC8vIGlmIGZhbHNlLCB3ZSB1c2UgdGhlIGJhY2tkcm9wIGhlbHBlciB3aXRob3V0IGFkZGluZyBhbnkgZWxlbWVudCB0byB0aGUgZG9tXG4gICAgcm9vdEVsZW1lbnQ6ICdib2R5JyAvLyBnaXZlIHRoZSBjaG9pY2UgdG8gcGxhY2UgYmFja2Ryb3AgdW5kZXIgZGlmZmVyZW50IGVsZW1lbnRzXG5cbiAgfTtcbiAgY29uc3QgRGVmYXVsdFR5cGUkOCA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGNsaWNrQ2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknLFxuICAgIGlzQW5pbWF0ZWQ6ICdib29sZWFuJyxcbiAgICBpc1Zpc2libGU6ICdib29sZWFuJyxcbiAgICByb290RWxlbWVudDogJyhlbGVtZW50fHN0cmluZyknXG4gIH07XG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIEJhY2tkcm9wIGV4dGVuZHMgQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIHRoaXMuX2lzQXBwZW5kZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIH0gLy8gR2V0dGVyc1xuXG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCQ4O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkODtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSQ5O1xuICAgIH0gLy8gUHVibGljXG5cblxuICAgIHNob3coY2FsbGJhY2spIHtcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xuICAgICAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hcHBlbmQoKTtcblxuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2dldEVsZW1lbnQoKTtcblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKSB7XG4gICAgICAgIHJlZmxvdyhlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ1KTtcblxuICAgICAgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGlkZShjYWxsYmFjaykge1xuICAgICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XG4gICAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ1KTtcblxuICAgICAgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzQXBwZW5kZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFRE9XTik7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCk7XG5cbiAgICAgIHRoaXMuX2lzQXBwZW5kZWQgPSBmYWxzZTtcbiAgICB9IC8vIFByaXZhdGVcblxuXG4gICAgX2dldEVsZW1lbnQoKSB7XG4gICAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgYmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYmFja2Ryb3AuY2xhc3NOYW1lID0gdGhpcy5fY29uZmlnLmNsYXNzTmFtZTtcblxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcbiAgICAgICAgICBiYWNrZHJvcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSQ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBiYWNrZHJvcDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgfVxuXG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgICAvLyB1c2UgZ2V0RWxlbWVudCgpIHdpdGggdGhlIGRlZmF1bHQgXCJib2R5XCIgdG8gZ2V0IGEgZnJlc2ggRWxlbWVudCBvbiBlYWNoIGluc3RhbnRpYXRpb25cbiAgICAgIGNvbmZpZy5yb290RWxlbWVudCA9IGdldEVsZW1lbnQoY29uZmlnLnJvb3RFbGVtZW50KTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgX2FwcGVuZCgpIHtcbiAgICAgIGlmICh0aGlzLl9pc0FwcGVuZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2dldEVsZW1lbnQoKTtcblxuICAgICAgdGhpcy5fY29uZmlnLnJvb3RFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcblxuICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsIEVWRU5UX01PVVNFRE9XTiwgKCkgPT4ge1xuICAgICAgICBleGVjdXRlKHRoaXMuX2NvbmZpZy5jbGlja0NhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faXNBcHBlbmRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgX2VtdWxhdGVBbmltYXRpb24oY2FsbGJhY2spIHtcbiAgICAgIGV4ZWN1dGVBZnRlclRyYW5zaXRpb24oY2FsbGJhY2ssIHRoaXMuX2dldEVsZW1lbnQoKSwgdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpO1xuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogdXRpbC9mb2N1c3RyYXAuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkOCA9ICdmb2N1c3RyYXAnO1xuICBjb25zdCBEQVRBX0tFWSQ1ID0gJ2JzLmZvY3VzdHJhcCc7XG4gIGNvbnN0IEVWRU5UX0tFWSQ1ID0gYC4ke0RBVEFfS0VZJDV9YDtcbiAgY29uc3QgRVZFTlRfRk9DVVNJTiQyID0gYGZvY3VzaW4ke0VWRU5UX0tFWSQ1fWA7XG4gIGNvbnN0IEVWRU5UX0tFWURPV05fVEFCID0gYGtleWRvd24udGFiJHtFVkVOVF9LRVkkNX1gO1xuICBjb25zdCBUQUJfS0VZID0gJ1RhYic7XG4gIGNvbnN0IFRBQl9OQVZfRk9SV0FSRCA9ICdmb3J3YXJkJztcbiAgY29uc3QgVEFCX05BVl9CQUNLV0FSRCA9ICdiYWNrd2FyZCc7XG4gIGNvbnN0IERlZmF1bHQkNyA9IHtcbiAgICBhdXRvZm9jdXM6IHRydWUsXG4gICAgdHJhcEVsZW1lbnQ6IG51bGwgLy8gVGhlIGVsZW1lbnQgdG8gdHJhcCBmb2N1cyBpbnNpZGUgb2ZcblxuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSQ3ID0ge1xuICAgIGF1dG9mb2N1czogJ2Jvb2xlYW4nLFxuICAgIHRyYXBFbGVtZW50OiAnZWxlbWVudCdcbiAgfTtcbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgRm9jdXNUcmFwIGV4dGVuZHMgQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID0gbnVsbDtcbiAgICB9IC8vIEdldHRlcnNcblxuXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQkNztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDc7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkODtcbiAgICB9IC8vIFB1YmxpY1xuXG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLl9pc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcuYXV0b2ZvY3VzKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZy50cmFwRWxlbWVudC5mb2N1cygpO1xuICAgICAgfVxuXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9LRVkkNSk7IC8vIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgZm9jdXMgbG9vcFxuXG4gICAgICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0ZPQ1VTSU4kMiwgZXZlbnQgPT4gdGhpcy5faGFuZGxlRm9jdXNpbihldmVudCkpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9LRVlET1dOX1RBQiwgZXZlbnQgPT4gdGhpcy5faGFuZGxlS2V5ZG93bihldmVudCkpO1xuICAgICAgdGhpcy5faXNBY3RpdmUgPSB0cnVlO1xuICAgIH1cblxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0tFWSQ1KTtcbiAgICB9IC8vIFByaXZhdGVcblxuXG4gICAgX2hhbmRsZUZvY3VzaW4oZXZlbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHJhcEVsZW1lbnRcbiAgICAgIH0gPSB0aGlzLl9jb25maWc7XG5cbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGRvY3VtZW50IHx8IGV2ZW50LnRhcmdldCA9PT0gdHJhcEVsZW1lbnQgfHwgdHJhcEVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gU2VsZWN0b3JFbmdpbmUuZm9jdXNhYmxlQ2hpbGRyZW4odHJhcEVsZW1lbnQpO1xuXG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRyYXBFbGVtZW50LmZvY3VzKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPT09IFRBQl9OQVZfQkFDS1dBUkQpIHtcbiAgICAgICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0uZm9jdXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnRzWzBdLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2hhbmRsZUtleWRvd24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5rZXkgIT09IFRBQl9LRVkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID0gZXZlbnQuc2hpZnRLZXkgPyBUQUJfTkFWX0JBQ0tXQVJEIDogVEFCX05BVl9GT1JXQVJEO1xuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjUuMi4zKTogbW9kYWwuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkNyA9ICdtb2RhbCc7XG4gIGNvbnN0IERBVEFfS0VZJDQgPSAnYnMubW9kYWwnO1xuICBjb25zdCBFVkVOVF9LRVkkNCA9IGAuJHtEQVRBX0tFWSQ0fWA7XG4gIGNvbnN0IERBVEFfQVBJX0tFWSQyID0gJy5kYXRhLWFwaSc7XG4gIGNvbnN0IEVTQ0FQRV9LRVkkMSA9ICdFc2NhcGUnO1xuICBjb25zdCBFVkVOVF9ISURFJDQgPSBgaGlkZSR7RVZFTlRfS0VZJDR9YDtcbiAgY29uc3QgRVZFTlRfSElERV9QUkVWRU5URUQkMSA9IGBoaWRlUHJldmVudGVkJHtFVkVOVF9LRVkkNH1gO1xuICBjb25zdCBFVkVOVF9ISURERU4kNCA9IGBoaWRkZW4ke0VWRU5UX0tFWSQ0fWA7XG4gIGNvbnN0IEVWRU5UX1NIT1ckNCA9IGBzaG93JHtFVkVOVF9LRVkkNH1gO1xuICBjb25zdCBFVkVOVF9TSE9XTiQ0ID0gYHNob3duJHtFVkVOVF9LRVkkNH1gO1xuICBjb25zdCBFVkVOVF9SRVNJWkUkMSA9IGByZXNpemUke0VWRU5UX0tFWSQ0fWA7XG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RJU01JU1MgPSBgY2xpY2suZGlzbWlzcyR7RVZFTlRfS0VZJDR9YDtcbiAgY29uc3QgRVZFTlRfTU9VU0VET1dOX0RJU01JU1MgPSBgbW91c2Vkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQ0fWA7XG4gIGNvbnN0IEVWRU5UX0tFWURPV05fRElTTUlTUyQxID0gYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZJDR9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMiA9IGBjbGljayR7RVZFTlRfS0VZJDR9JHtEQVRBX0FQSV9LRVkkMn1gO1xuICBjb25zdCBDTEFTU19OQU1FX09QRU4gPSAnbW9kYWwtb3Blbic7XG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQzID0gJ2ZhZGUnO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckNCA9ICdzaG93JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TVEFUSUMgPSAnbW9kYWwtc3RhdGljJztcbiAgY29uc3QgT1BFTl9TRUxFQ1RPUiQxID0gJy5tb2RhbC5zaG93JztcbiAgY29uc3QgU0VMRUNUT1JfRElBTE9HID0gJy5tb2RhbC1kaWFsb2cnO1xuICBjb25zdCBTRUxFQ1RPUl9NT0RBTF9CT0RZID0gJy5tb2RhbC1ib2R5JztcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMiA9ICdbZGF0YS1icy10b2dnbGU9XCJtb2RhbFwiXSc7XG4gIGNvbnN0IERlZmF1bHQkNiA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBmb2N1czogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZVxuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSQ2ID0ge1xuICAgIGJhY2tkcm9wOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gICAgZm9jdXM6ICdib29sZWFuJyxcbiAgICBrZXlib2FyZDogJ2Jvb2xlYW4nXG4gIH07XG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIE1vZGFsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuICAgICAgdGhpcy5fZGlhbG9nID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9ESUFMT0csIHRoaXMuX2VsZW1lbnQpO1xuICAgICAgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKTtcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcCA9IHRoaXMuX2luaXRpYWxpemVGb2N1c1RyYXAoKTtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IFNjcm9sbEJhckhlbHBlcigpO1xuXG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH0gLy8gR2V0dGVyc1xuXG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCQ2O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkNjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSQ3O1xuICAgIH0gLy8gUHVibGljXG5cblxuICAgIHRvZ2dsZShyZWxhdGVkVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHJlbGF0ZWRUYXJnZXQpO1xuICAgIH1cblxuICAgIHNob3cocmVsYXRlZFRhcmdldCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ0LCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG5cbiAgICAgIHRoaXMuX3Njcm9sbEJhci5oaWRlKCk7XG5cbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX09QRU4pO1xuXG4gICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcblxuICAgICAgdGhpcy5fYmFja2Ryb3Auc2hvdygoKSA9PiB0aGlzLl9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSk7XG4gICAgfVxuXG4gICAgaGlkZSgpIHtcbiAgICAgIGlmICghdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDQpO1xuXG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDQpO1xuXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHRoaXMuX2hpZGVNb2RhbCgpLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xuICAgIH1cblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICBmb3IgKGNvbnN0IGh0bWxFbGVtZW50IG9mIFt3aW5kb3csIHRoaXMuX2RpYWxvZ10pIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihodG1sRWxlbWVudCwgRVZFTlRfS0VZJDQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCk7XG5cbiAgICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XG5cbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICBoYW5kbGVVcGRhdGUoKSB7XG4gICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgICB9IC8vIFByaXZhdGVcblxuXG4gICAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICAgIHJldHVybiBuZXcgQmFja2Ryb3Aoe1xuICAgICAgICBpc1Zpc2libGU6IEJvb2xlYW4odGhpcy5fY29uZmlnLmJhY2tkcm9wKSxcbiAgICAgICAgLy8gJ3N0YXRpYycgb3B0aW9uIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0cnVlLCBhbmQgYm9vbGVhbnMgd2lsbCBrZWVwIHRoZWlyIHZhbHVlLFxuICAgICAgICBpc0FuaW1hdGVkOiB0aGlzLl9pc0FuaW1hdGVkKClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xuICAgICAgcmV0dXJuIG5ldyBGb2N1c1RyYXAoe1xuICAgICAgICB0cmFwRWxlbWVudDogdGhpcy5fZWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIC8vIHRyeSB0byBhcHBlbmQgZHluYW1pYyBtb2RhbFxuICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJyk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICAgIGNvbnN0IG1vZGFsQm9keSA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfTU9EQUxfQk9EWSwgdGhpcy5fZGlhbG9nKTtcblxuICAgICAgaWYgKG1vZGFsQm9keSkge1xuICAgICAgICBtb2RhbEJvZHkuc2Nyb2xsVG9wID0gMDtcbiAgICAgIH1cblxuICAgICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDQpO1xuXG4gICAgICBjb25zdCB0cmFuc2l0aW9uQ29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9jb25maWcuZm9jdXMpIHtcbiAgICAgICAgICB0aGlzLl9mb2N1c3RyYXAuYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQ0LCB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2sodHJhbnNpdGlvbkNvbXBsZXRlLCB0aGlzLl9kaWFsb2csIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XG4gICAgfVxuXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUyQxLCBldmVudCA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXkgIT09IEVTQ0FQRV9LRVkkMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfUkVTSVpFJDEsICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2hvd24gJiYgIXRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRURPV05fRElTTUlTUywgZXZlbnQgPT4ge1xuICAgICAgICAvLyBhIGJhZCB0cmljayB0byBzZWdyZWdhdGUgY2xpY2tzIHRoYXQgbWF5IHN0YXJ0IGluc2lkZSBkaWFsb2cgYnV0IGVuZCBvdXRzaWRlLCBhbmQgYXZvaWQgbGlzdGVuIHRvIHNjcm9sbGJhciBjbGlja3NcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDS19ESVNNSVNTLCBldmVudDIgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50ICE9PSBldmVudC50YXJnZXQgfHwgdGhpcy5fZWxlbWVudCAhPT0gZXZlbnQyLnRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2hpZGVNb2RhbCgpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJyk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG5cbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9iYWNrZHJvcC5oaWRlKCgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfT1BFTik7XG5cbiAgICAgICAgdGhpcy5fcmVzZXRBZGp1c3RtZW50cygpO1xuXG4gICAgICAgIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQ0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9pc0FuaW1hdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQzKTtcbiAgICB9XG5cbiAgICBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREVfUFJFVkVOVEVEJDEpO1xuXG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICBjb25zdCBpbml0aWFsT3ZlcmZsb3dZID0gdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1k7IC8vIHJldHVybiBpZiB0aGUgZm9sbG93aW5nIGJhY2tncm91bmQgdHJhbnNpdGlvbiBoYXNuJ3QgeWV0IGNvbXBsZXRlZFxuXG4gICAgICBpZiAoaW5pdGlhbE92ZXJmbG93WSA9PT0gJ2hpZGRlbicgfHwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TVEFUSUMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU1RBVElDKTtcblxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NUQVRJQyk7XG5cbiAgICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSBpbml0aWFsT3ZlcmZsb3dZO1xuICAgICAgICB9LCB0aGlzLl9kaWFsb2cpO1xuICAgICAgfSwgdGhpcy5fZGlhbG9nKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xuICAgICAqL1xuXG5cbiAgICBfYWRqdXN0RGlhbG9nKCkge1xuICAgICAgY29uc3QgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXG4gICAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHRoaXMuX3Njcm9sbEJhci5nZXRXaWR0aCgpO1xuXG4gICAgICBjb25zdCBpc0JvZHlPdmVyZmxvd2luZyA9IHNjcm9sbGJhcldpZHRoID4gMDtcblxuICAgICAgaWYgKGlzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBpc1JUTCgpID8gJ3BhZGRpbmdMZWZ0JyA6ICdwYWRkaW5nUmlnaHQnO1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IGAke3Njcm9sbGJhcldpZHRofXB4YDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0JvZHlPdmVyZmxvd2luZyAmJiBpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBpc1JUTCgpID8gJ3BhZGRpbmdSaWdodCcgOiAncGFkZGluZ0xlZnQnO1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IGAke3Njcm9sbGJhcldpZHRofXB4YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVzZXRBZGp1c3RtZW50cygpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSAnJztcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XG4gICAgfSAvLyBTdGF0aWNcblxuXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcsIHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW2NvbmZpZ10ocmVsYXRlZFRhcmdldCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfVxuICAvKipcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAgICovXG5cblxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDIsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcyk7XG5cbiAgICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9TSE9XJDQsIHNob3dFdmVudCA9PiB7XG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgLy8gb25seSByZWdpc3RlciBmb2N1cyByZXN0b3JlciBpZiBtb2RhbCB3aWxsIGFjdHVhbGx5IGdldCBzaG93blxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9ISURERU4kNCwgKCkgPT4ge1xuICAgICAgICBpZiAoaXNWaXNpYmxlKHRoaXMpKSB7XG4gICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTsgLy8gYXZvaWQgY29uZmxpY3Qgd2hlbiBjbGlja2luZyBtb2RhbCB0b2dnbGVyIHdoaWxlIGFub3RoZXIgb25lIGlzIG9wZW5cblxuICAgIGNvbnN0IGFscmVhZHlPcGVuID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShPUEVOX1NFTEVDVE9SJDEpO1xuXG4gICAgaWYgKGFscmVhZHlPcGVuKSB7XG4gICAgICBNb2RhbC5nZXRJbnN0YW5jZShhbHJlYWR5T3BlbikuaGlkZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBNb2RhbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XG4gICAgZGF0YS50b2dnbGUodGhpcyk7XG4gIH0pO1xuICBlbmFibGVEaXNtaXNzVHJpZ2dlcihNb2RhbCk7XG4gIC8qKlxuICAgKiBqUXVlcnlcbiAgICovXG5cbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKE1vZGFsKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwICh2NS4yLjMpOiBvZmZjYW52YXMuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkNiA9ICdvZmZjYW52YXMnO1xuICBjb25zdCBEQVRBX0tFWSQzID0gJ2JzLm9mZmNhbnZhcyc7XG4gIGNvbnN0IEVWRU5UX0tFWSQzID0gYC4ke0RBVEFfS0VZJDN9YDtcbiAgY29uc3QgREFUQV9BUElfS0VZJDEgPSAnLmRhdGEtYXBpJztcbiAgY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQyID0gYGxvYWQke0VWRU5UX0tFWSQzfSR7REFUQV9BUElfS0VZJDF9YDtcbiAgY29uc3QgRVNDQVBFX0tFWSA9ICdFc2NhcGUnO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckMyA9ICdzaG93JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XSU5HJDEgPSAnc2hvd2luZyc7XG4gIGNvbnN0IENMQVNTX05BTUVfSElESU5HID0gJ2hpZGluZyc7XG4gIGNvbnN0IENMQVNTX05BTUVfQkFDS0RST1AgPSAnb2ZmY2FudmFzLWJhY2tkcm9wJztcbiAgY29uc3QgT1BFTl9TRUxFQ1RPUiA9ICcub2ZmY2FudmFzLnNob3cnO1xuICBjb25zdCBFVkVOVF9TSE9XJDMgPSBgc2hvdyR7RVZFTlRfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfU0hPV04kMyA9IGBzaG93biR7RVZFTlRfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfSElERSQzID0gYGhpZGUke0VWRU5UX0tFWSQzfWA7XG4gIGNvbnN0IEVWRU5UX0hJREVfUFJFVkVOVEVEID0gYGhpZGVQcmV2ZW50ZWQke0VWRU5UX0tFWSQzfWA7XG4gIGNvbnN0IEVWRU5UX0hJRERFTiQzID0gYGhpZGRlbiR7RVZFTlRfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfUkVTSVpFID0gYHJlc2l6ZSR7RVZFTlRfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMSA9IGBjbGljayR7RVZFTlRfS0VZJDN9JHtEQVRBX0FQSV9LRVkkMX1gO1xuICBjb25zdCBFVkVOVF9LRVlET1dOX0RJU01JU1MgPSBga2V5ZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkM31gO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxID0gJ1tkYXRhLWJzLXRvZ2dsZT1cIm9mZmNhbnZhc1wiXSc7XG4gIGNvbnN0IERlZmF1bHQkNSA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICBzY3JvbGw6IGZhbHNlXG4gIH07XG4gIGNvbnN0IERlZmF1bHRUeXBlJDUgPSB7XG4gICAgYmFja2Ryb3A6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxuICAgIHNjcm9sbDogJ2Jvb2xlYW4nXG4gIH07XG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIE9mZmNhbnZhcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKCk7XG4gICAgICB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCk7XG5cbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfSAvLyBHZXR0ZXJzXG5cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JDU7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ1O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDY7XG4gICAgfSAvLyBQdWJsaWNcblxuXG4gICAgdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldCk7XG4gICAgfVxuXG4gICAgc2hvdyhyZWxhdGVkVGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckMywge1xuICAgICAgICByZWxhdGVkVGFyZ2V0XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2JhY2tkcm9wLnNob3coKTtcblxuICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsKSB7XG4gICAgICAgIG5ldyBTY3JvbGxCYXJIZWxwZXIoKS5oaWRlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XSU5HJDEpO1xuXG4gICAgICBjb25zdCBjb21wbGV0ZUNhbGxCYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgdGhpcy5fY29uZmlnLmJhY2tkcm9wKSB7XG4gICAgICAgICAgdGhpcy5fZm9jdXN0cmFwLmFjdGl2YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDMpO1xuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkckMSk7XG5cbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kMywge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlQ2FsbEJhY2ssIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDMpO1xuXG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LmJsdXIoKTtcblxuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9ISURJTkcpO1xuXG4gICAgICB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckMywgQ0xBU1NfTkFNRV9ISURJTkcpO1xuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJyk7XG5cbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwpIHtcbiAgICAgICAgICBuZXcgU2Nyb2xsQmFySGVscGVyKCkucmVzZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQzKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsYmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKTtcblxuICAgICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKTtcblxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH0gLy8gUHJpdmF0ZVxuXG5cbiAgICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgICAgY29uc3QgY2xpY2tDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9OyAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWVcblxuXG4gICAgICBjb25zdCBpc1Zpc2libGUgPSBCb29sZWFuKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCk7XG4gICAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcbiAgICAgICAgY2xhc3NOYW1lOiBDTEFTU19OQU1FX0JBQ0tEUk9QLFxuICAgICAgICBpc1Zpc2libGUsXG4gICAgICAgIGlzQW5pbWF0ZWQ6IHRydWUsXG4gICAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICAgIGNsaWNrQ2FsbGJhY2s6IGlzVmlzaWJsZSA/IGNsaWNrQ2FsbGJhY2sgOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcbiAgICAgIHJldHVybiBuZXcgRm9jdXNUcmFwKHtcbiAgICAgICAgdHJhcEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOX0RJU01JU1MsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSAhPT0gRVNDQVBFX0tFWSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XG4gICAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERV9QUkVWRU5URUQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfSk7XG4gICAgfSAvLyBTdGF0aWNcblxuXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH1cbiAgLyoqXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gICAqL1xuXG5cbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQxLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpO1xuXG4gICAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9ISURERU4kMywgKCkgPT4ge1xuICAgICAgLy8gZm9jdXMgb24gdHJpZ2dlciB3aGVuIGl0IGlzIGNsb3NlZFxuICAgICAgaWYgKGlzVmlzaWJsZSh0aGlzKSkge1xuICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSk7IC8vIGF2b2lkIGNvbmZsaWN0IHdoZW4gY2xpY2tpbmcgYSB0b2dnbGVyIG9mIGFuIG9mZmNhbnZhcywgd2hpbGUgYW5vdGhlciBpcyBvcGVuXG5cbiAgICBjb25zdCBhbHJlYWR5T3BlbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoT1BFTl9TRUxFQ1RPUik7XG5cbiAgICBpZiAoYWxyZWFkeU9wZW4gJiYgYWxyZWFkeU9wZW4gIT09IHRhcmdldCkge1xuICAgICAgT2ZmY2FudmFzLmdldEluc3RhbmNlKGFscmVhZHlPcGVuKS5oaWRlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IE9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XG4gICAgZGF0YS50b2dnbGUodGhpcyk7XG4gIH0pO1xuICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJJDIsICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IHNlbGVjdG9yIG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoT1BFTl9TRUxFQ1RPUikpIHtcbiAgICAgIE9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKHNlbGVjdG9yKS5zaG93KCk7XG4gICAgfVxuICB9KTtcbiAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfUkVTSVpFLCAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoJ1thcmlhLW1vZGFsXVtjbGFzcyo9c2hvd11bY2xhc3MqPW9mZmNhbnZhcy1dJykpIHtcbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgIE9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQpLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBlbmFibGVEaXNtaXNzVHJpZ2dlcihPZmZjYW52YXMpO1xuICAvKipcbiAgICogalF1ZXJ5XG4gICAqL1xuXG4gIGRlZmluZUpRdWVyeVBsdWdpbihPZmZjYW52YXMpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IHV0aWwvc2FuaXRpemVyLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cbiAgY29uc3QgdXJpQXR0cmlidXRlcyA9IG5ldyBTZXQoWydiYWNrZ3JvdW5kJywgJ2NpdGUnLCAnaHJlZicsICdpdGVtdHlwZScsICdsb25nZGVzYycsICdwb3N0ZXInLCAnc3JjJywgJ3hsaW5rOmhyZWYnXSk7XG4gIGNvbnN0IEFSSUFfQVRUUklCVVRFX1BBVFRFUk4gPSAvXmFyaWEtW1xcdy1dKiQvaTtcbiAgLyoqXG4gICAqIEEgcGF0dGVybiB0aGF0IHJlY29nbml6ZXMgYSBjb21tb25seSB1c2VmdWwgc3Vic2V0IG9mIFVSTHMgdGhhdCBhcmUgc2FmZS5cbiAgICpcbiAgICogU2hvdXQtb3V0IHRvIEFuZ3VsYXIgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzEyLjIueC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50c1xuICAgKi9cblxuICBjb25zdCBTQUZFX1VSTF9QQVRURVJOID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZXxzbXMpOnxbXiMmLzo/XSooPzpbIy8/XXwkKSkvaTtcbiAgLyoqXG4gICAqIEEgcGF0dGVybiB0aGF0IG1hdGNoZXMgc2FmZSBkYXRhIFVSTHMuIE9ubHkgbWF0Y2hlcyBpbWFnZSwgdmlkZW8gYW5kIGF1ZGlvIHR5cGVzLlxuICAgKlxuICAgKiBTaG91dC1vdXQgdG8gQW5ndWxhciBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvMTIuMi54L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzXG4gICAqL1xuXG4gIGNvbnN0IERBVEFfVVJMX1BBVFRFUk4gPSAvXmRhdGE6KD86aW1hZ2VcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnApfHZpZGVvXFwvKD86bXBlZ3xtcDR8b2dnfHdlYm0pfGF1ZGlvXFwvKD86bXAzfG9nYXxvZ2d8b3B1cykpO2Jhc2U2NCxbXFxkKy9hLXpdKz0qJC9pO1xuXG4gIGNvbnN0IGFsbG93ZWRBdHRyaWJ1dGUgPSAoYXR0cmlidXRlLCBhbGxvd2VkQXR0cmlidXRlTGlzdCkgPT4ge1xuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChhbGxvd2VkQXR0cmlidXRlTGlzdC5pbmNsdWRlcyhhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgaWYgKHVyaUF0dHJpYnV0ZXMuaGFzKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKFNBRkVfVVJMX1BBVFRFUk4udGVzdChhdHRyaWJ1dGUubm9kZVZhbHVlKSB8fCBEQVRBX1VSTF9QQVRURVJOLnRlc3QoYXR0cmlidXRlLm5vZGVWYWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIENoZWNrIGlmIGEgcmVndWxhciBleHByZXNzaW9uIHZhbGlkYXRlcyB0aGUgYXR0cmlidXRlLlxuXG5cbiAgICByZXR1cm4gYWxsb3dlZEF0dHJpYnV0ZUxpc3QuZmlsdGVyKGF0dHJpYnV0ZVJlZ2V4ID0+IGF0dHJpYnV0ZVJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwKS5zb21lKHJlZ2V4ID0+IHJlZ2V4LnRlc3QoYXR0cmlidXRlTmFtZSkpO1xuICB9O1xuXG4gIGNvbnN0IERlZmF1bHRBbGxvd2xpc3QgPSB7XG4gICAgLy8gR2xvYmFsIGF0dHJpYnV0ZXMgYWxsb3dlZCBvbiBhbnkgc3VwcGxpZWQgZWxlbWVudCBiZWxvdy5cbiAgICAnKic6IFsnY2xhc3MnLCAnZGlyJywgJ2lkJywgJ2xhbmcnLCAncm9sZScsIEFSSUFfQVRUUklCVVRFX1BBVFRFUk5dLFxuICAgIGE6IFsndGFyZ2V0JywgJ2hyZWYnLCAndGl0bGUnLCAncmVsJ10sXG4gICAgYXJlYTogW10sXG4gICAgYjogW10sXG4gICAgYnI6IFtdLFxuICAgIGNvbDogW10sXG4gICAgY29kZTogW10sXG4gICAgZGl2OiBbXSxcbiAgICBlbTogW10sXG4gICAgaHI6IFtdLFxuICAgIGgxOiBbXSxcbiAgICBoMjogW10sXG4gICAgaDM6IFtdLFxuICAgIGg0OiBbXSxcbiAgICBoNTogW10sXG4gICAgaDY6IFtdLFxuICAgIGk6IFtdLFxuICAgIGltZzogWydzcmMnLCAnc3Jjc2V0JywgJ2FsdCcsICd0aXRsZScsICd3aWR0aCcsICdoZWlnaHQnXSxcbiAgICBsaTogW10sXG4gICAgb2w6IFtdLFxuICAgIHA6IFtdLFxuICAgIHByZTogW10sXG4gICAgczogW10sXG4gICAgc21hbGw6IFtdLFxuICAgIHNwYW46IFtdLFxuICAgIHN1YjogW10sXG4gICAgc3VwOiBbXSxcbiAgICBzdHJvbmc6IFtdLFxuICAgIHU6IFtdLFxuICAgIHVsOiBbXVxuICB9O1xuICBmdW5jdGlvbiBzYW5pdGl6ZUh0bWwodW5zYWZlSHRtbCwgYWxsb3dMaXN0LCBzYW5pdGl6ZUZ1bmN0aW9uKSB7XG4gICAgaWYgKCF1bnNhZmVIdG1sLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHVuc2FmZUh0bWw7XG4gICAgfVxuXG4gICAgaWYgKHNhbml0aXplRnVuY3Rpb24gJiYgdHlwZW9mIHNhbml0aXplRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBzYW5pdGl6ZUZ1bmN0aW9uKHVuc2FmZUh0bWwpO1xuICAgIH1cblxuICAgIGNvbnN0IGRvbVBhcnNlciA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCk7XG4gICAgY29uc3QgY3JlYXRlZERvY3VtZW50ID0gZG9tUGFyc2VyLnBhcnNlRnJvbVN0cmluZyh1bnNhZmVIdG1sLCAndGV4dC9odG1sJyk7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXS5jb25jYXQoLi4uY3JlYXRlZERvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbCgnKicpKTtcblxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgY29uc3QgZWxlbWVudE5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmICghT2JqZWN0LmtleXMoYWxsb3dMaXN0KS5pbmNsdWRlcyhlbGVtZW50TmFtZSkpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZUxpc3QgPSBbXS5jb25jYXQoLi4uZWxlbWVudC5hdHRyaWJ1dGVzKTtcbiAgICAgIGNvbnN0IGFsbG93ZWRBdHRyaWJ1dGVzID0gW10uY29uY2F0KGFsbG93TGlzdFsnKiddIHx8IFtdLCBhbGxvd0xpc3RbZWxlbWVudE5hbWVdIHx8IFtdKTtcblxuICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlTGlzdCkge1xuICAgICAgICBpZiAoIWFsbG93ZWRBdHRyaWJ1dGUoYXR0cmlidXRlLCBhbGxvd2VkQXR0cmlidXRlcykpIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUubm9kZU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZWREb2N1bWVudC5ib2R5LmlubmVySFRNTDtcbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IHV0aWwvdGVtcGxhdGUtZmFjdG9yeS5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSQ1ID0gJ1RlbXBsYXRlRmFjdG9yeSc7XG4gIGNvbnN0IERlZmF1bHQkNCA9IHtcbiAgICBhbGxvd0xpc3Q6IERlZmF1bHRBbGxvd2xpc3QsXG4gICAgY29udGVudDoge30sXG4gICAgLy8geyBzZWxlY3RvciA6IHRleHQgLCAgc2VsZWN0b3IyIDogdGV4dDIgLCB9XG4gICAgZXh0cmFDbGFzczogJycsXG4gICAgaHRtbDogZmFsc2UsXG4gICAgc2FuaXRpemU6IHRydWUsXG4gICAgc2FuaXRpemVGbjogbnVsbCxcbiAgICB0ZW1wbGF0ZTogJzxkaXY+PC9kaXY+J1xuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSQ0ID0ge1xuICAgIGFsbG93TGlzdDogJ29iamVjdCcsXG4gICAgY29udGVudDogJ29iamVjdCcsXG4gICAgZXh0cmFDbGFzczogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgICBodG1sOiAnYm9vbGVhbicsXG4gICAgc2FuaXRpemU6ICdib29sZWFuJyxcbiAgICBzYW5pdGl6ZUZuOiAnKG51bGx8ZnVuY3Rpb24pJyxcbiAgICB0ZW1wbGF0ZTogJ3N0cmluZydcbiAgfTtcbiAgY29uc3QgRGVmYXVsdENvbnRlbnRUeXBlID0ge1xuICAgIGVudHJ5OiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9ufG51bGwpJyxcbiAgICBzZWxlY3RvcjogJyhzdHJpbmd8ZWxlbWVudCknXG4gIH07XG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIFRlbXBsYXRlRmFjdG9yeSBleHRlbmRzIENvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgfSAvLyBHZXR0ZXJzXG5cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JDQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ0O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDU7XG4gICAgfSAvLyBQdWJsaWNcblxuXG4gICAgZ2V0Q29udGVudCgpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2NvbmZpZy5jb250ZW50KS5tYXAoY29uZmlnID0+IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGNvbmZpZykpLmZpbHRlcihCb29sZWFuKTtcbiAgICB9XG5cbiAgICBoYXNDb250ZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29udGVudCgpLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgY2hhbmdlQ29udGVudChjb250ZW50KSB7XG4gICAgICB0aGlzLl9jaGVja0NvbnRlbnQoY29udGVudCk7XG5cbiAgICAgIHRoaXMuX2NvbmZpZy5jb250ZW50ID0geyAuLi50aGlzLl9jb25maWcuY29udGVudCxcbiAgICAgICAgLi4uY29udGVudFxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRvSHRtbCgpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGVtcGxhdGVXcmFwcGVyLmlubmVySFRNTCA9IHRoaXMuX21heWJlU2FuaXRpemUodGhpcy5fY29uZmlnLnRlbXBsYXRlKTtcblxuICAgICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIHRleHRdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuX2NvbmZpZy5jb250ZW50KSkge1xuICAgICAgICB0aGlzLl9zZXRDb250ZW50KHRlbXBsYXRlV3JhcHBlciwgdGV4dCwgc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlV3JhcHBlci5jaGlsZHJlblswXTtcblxuICAgICAgY29uc3QgZXh0cmFDbGFzcyA9IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5leHRyYUNsYXNzKTtcblxuICAgICAgaWYgKGV4dHJhQ2xhc3MpIHtcbiAgICAgICAgdGVtcGxhdGUuY2xhc3NMaXN0LmFkZCguLi5leHRyYUNsYXNzLnNwbGl0KCcgJykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfSAvLyBQcml2YXRlXG5cblxuICAgIF90eXBlQ2hlY2tDb25maWcoY29uZmlnKSB7XG4gICAgICBzdXBlci5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XG5cbiAgICAgIHRoaXMuX2NoZWNrQ29udGVudChjb25maWcuY29udGVudCk7XG4gICAgfVxuXG4gICAgX2NoZWNrQ29udGVudChhcmcpIHtcbiAgICAgIGZvciAoY29uc3QgW3NlbGVjdG9yLCBjb250ZW50XSBvZiBPYmplY3QuZW50cmllcyhhcmcpKSB7XG4gICAgICAgIHN1cGVyLl90eXBlQ2hlY2tDb25maWcoe1xuICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgIGVudHJ5OiBjb250ZW50XG4gICAgICAgIH0sIERlZmF1bHRDb250ZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3NldENvbnRlbnQodGVtcGxhdGUsIGNvbnRlbnQsIHNlbGVjdG9yKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZUVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKHNlbGVjdG9yLCB0ZW1wbGF0ZSk7XG5cbiAgICAgIGlmICghdGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29udGVudCA9IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGNvbnRlbnQpO1xuXG4gICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgdGVtcGxhdGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VsZW1lbnQkMShjb250ZW50KSkge1xuICAgICAgICB0aGlzLl9wdXRFbGVtZW50SW5UZW1wbGF0ZShnZXRFbGVtZW50KGNvbnRlbnQpLCB0ZW1wbGF0ZUVsZW1lbnQpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5odG1sKSB7XG4gICAgICAgIHRlbXBsYXRlRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9tYXliZVNhbml0aXplKGNvbnRlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRlbXBsYXRlRWxlbWVudC50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgX21heWJlU2FuaXRpemUoYXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uZmlnLnNhbml0aXplID8gc2FuaXRpemVIdG1sKGFyZywgdGhpcy5fY29uZmlnLmFsbG93TGlzdCwgdGhpcy5fY29uZmlnLnNhbml0aXplRm4pIDogYXJnO1xuICAgIH1cblxuICAgIF9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nID8gYXJnKHRoaXMpIDogYXJnO1xuICAgIH1cblxuICAgIF9wdXRFbGVtZW50SW5UZW1wbGF0ZShlbGVtZW50LCB0ZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuaHRtbCkge1xuICAgICAgICB0ZW1wbGF0ZUVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHRlbXBsYXRlRWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGVtcGxhdGVFbGVtZW50LnRleHRDb250ZW50ID0gZWxlbWVudC50ZXh0Q29udGVudDtcbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IHRvb2x0aXAuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkNCA9ICd0b29sdGlwJztcbiAgY29uc3QgRElTQUxMT1dFRF9BVFRSSUJVVEVTID0gbmV3IFNldChbJ3Nhbml0aXplJywgJ2FsbG93TGlzdCcsICdzYW5pdGl6ZUZuJ10pO1xuICBjb25zdCBDTEFTU19OQU1FX0ZBREUkMiA9ICdmYWRlJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9NT0RBTCA9ICdtb2RhbCc7XG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQyID0gJ3Nob3cnO1xuICBjb25zdCBTRUxFQ1RPUl9UT09MVElQX0lOTkVSID0gJy50b29sdGlwLWlubmVyJztcbiAgY29uc3QgU0VMRUNUT1JfTU9EQUwgPSBgLiR7Q0xBU1NfTkFNRV9NT0RBTH1gO1xuICBjb25zdCBFVkVOVF9NT0RBTF9ISURFID0gJ2hpZGUuYnMubW9kYWwnO1xuICBjb25zdCBUUklHR0VSX0hPVkVSID0gJ2hvdmVyJztcbiAgY29uc3QgVFJJR0dFUl9GT0NVUyA9ICdmb2N1cyc7XG4gIGNvbnN0IFRSSUdHRVJfQ0xJQ0sgPSAnY2xpY2snO1xuICBjb25zdCBUUklHR0VSX01BTlVBTCA9ICdtYW51YWwnO1xuICBjb25zdCBFVkVOVF9ISURFJDIgPSAnaGlkZSc7XG4gIGNvbnN0IEVWRU5UX0hJRERFTiQyID0gJ2hpZGRlbic7XG4gIGNvbnN0IEVWRU5UX1NIT1ckMiA9ICdzaG93JztcbiAgY29uc3QgRVZFTlRfU0hPV04kMiA9ICdzaG93bic7XG4gIGNvbnN0IEVWRU5UX0lOU0VSVEVEID0gJ2luc2VydGVkJztcbiAgY29uc3QgRVZFTlRfQ0xJQ0skMSA9ICdjbGljayc7XG4gIGNvbnN0IEVWRU5UX0ZPQ1VTSU4kMSA9ICdmb2N1c2luJztcbiAgY29uc3QgRVZFTlRfRk9DVVNPVVQkMSA9ICdmb2N1c291dCc7XG4gIGNvbnN0IEVWRU5UX01PVVNFRU5URVIgPSAnbW91c2VlbnRlcic7XG4gIGNvbnN0IEVWRU5UX01PVVNFTEVBVkUgPSAnbW91c2VsZWF2ZSc7XG4gIGNvbnN0IEF0dGFjaG1lbnRNYXAgPSB7XG4gICAgQVVUTzogJ2F1dG8nLFxuICAgIFRPUDogJ3RvcCcsXG4gICAgUklHSFQ6IGlzUlRMKCkgPyAnbGVmdCcgOiAncmlnaHQnLFxuICAgIEJPVFRPTTogJ2JvdHRvbScsXG4gICAgTEVGVDogaXNSVEwoKSA/ICdyaWdodCcgOiAnbGVmdCdcbiAgfTtcbiAgY29uc3QgRGVmYXVsdCQzID0ge1xuICAgIGFsbG93TGlzdDogRGVmYXVsdEFsbG93bGlzdCxcbiAgICBhbmltYXRpb246IHRydWUsXG4gICAgYm91bmRhcnk6ICdjbGlwcGluZ1BhcmVudHMnLFxuICAgIGNvbnRhaW5lcjogZmFsc2UsXG4gICAgY3VzdG9tQ2xhc3M6ICcnLFxuICAgIGRlbGF5OiAwLFxuICAgIGZhbGxiYWNrUGxhY2VtZW50czogWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcbiAgICBodG1sOiBmYWxzZSxcbiAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIHBvcHBlckNvbmZpZzogbnVsbCxcbiAgICBzYW5pdGl6ZTogdHJ1ZSxcbiAgICBzYW5pdGl6ZUZuOiBudWxsLFxuICAgIHNlbGVjdG9yOiBmYWxzZSxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj4nICsgJzxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+JyArICc8ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PicgKyAnPC9kaXY+JyxcbiAgICB0aXRsZTogJycsXG4gICAgdHJpZ2dlcjogJ2hvdmVyIGZvY3VzJ1xuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSQzID0ge1xuICAgIGFsbG93TGlzdDogJ29iamVjdCcsXG4gICAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXG4gICAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgICBjb250YWluZXI6ICcoc3RyaW5nfGVsZW1lbnR8Ym9vbGVhbiknLFxuICAgIGN1c3RvbUNsYXNzOiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICAgIGRlbGF5OiAnKG51bWJlcnxvYmplY3QpJyxcbiAgICBmYWxsYmFja1BsYWNlbWVudHM6ICdhcnJheScsXG4gICAgaHRtbDogJ2Jvb2xlYW4nLFxuICAgIG9mZnNldDogJyhhcnJheXxzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgICBwbGFjZW1lbnQ6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXG4gICAgcG9wcGVyQ29uZmlnOiAnKG51bGx8b2JqZWN0fGZ1bmN0aW9uKScsXG4gICAgc2FuaXRpemU6ICdib29sZWFuJyxcbiAgICBzYW5pdGl6ZUZuOiAnKG51bGx8ZnVuY3Rpb24pJyxcbiAgICBzZWxlY3RvcjogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICAgIHRlbXBsYXRlOiAnc3RyaW5nJyxcbiAgICB0aXRsZTogJyhzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknLFxuICAgIHRyaWdnZXI6ICdzdHJpbmcnXG4gIH07XG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIHRvb2x0aXBzIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpJyk7XG4gICAgICB9XG5cbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7IC8vIFByaXZhdGVcblxuICAgICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSAwO1xuICAgICAgdGhpcy5faXNIb3ZlcmVkID0gbnVsbDtcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSB7fTtcbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG4gICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkgPSBudWxsO1xuICAgICAgdGhpcy5fbmV3Q29udGVudCA9IG51bGw7IC8vIFByb3RlY3RlZFxuXG4gICAgICB0aGlzLnRpcCA9IG51bGw7XG5cbiAgICAgIHRoaXMuX3NldExpc3RlbmVycygpO1xuXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zZWxlY3Rvcikge1xuICAgICAgICB0aGlzLl9maXhUaXRsZSgpO1xuICAgICAgfVxuICAgIH0gLy8gR2V0dGVyc1xuXG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCQzO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkMztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSQ0O1xuICAgIH0gLy8gUHVibGljXG5cblxuICAgIGVuYWJsZSgpIHtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZGlzYWJsZSgpIHtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRvZ2dsZUVuYWJsZWQoKSB7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSAhdGhpcy5faXNFbmFibGVkO1xuICAgIH1cblxuICAgIHRvZ2dsZSgpIHtcbiAgICAgIGlmICghdGhpcy5faXNFbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICF0aGlzLl9hY3RpdmVUcmlnZ2VyLmNsaWNrO1xuXG4gICAgICBpZiAodGhpcy5faXNTaG93bigpKSB7XG4gICAgICAgIHRoaXMuX2xlYXZlKCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbnRlcigpO1xuICAgIH1cblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9NT0RBTCksIEVWRU5UX01PREFMX0hJREUsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xuXG4gICAgICBpZiAodGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnKSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgndGl0bGUnLCB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuXG4gICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgc2hvdygpIHtcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSB1c2Ugc2hvdyBvbiB2aXNpYmxlIGVsZW1lbnRzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghKHRoaXMuX2lzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfU0hPVyQyKSk7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gZmluZFNoYWRvd1Jvb3QodGhpcy5fZWxlbWVudCk7XG5cbiAgICAgIGNvbnN0IGlzSW5UaGVEb20gPSAoc2hhZG93Um9vdCB8fCB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5jb250YWlucyh0aGlzLl9lbGVtZW50KTtcblxuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFpc0luVGhlRG9tKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gdG9kbyB2NiByZW1vdmUgdGhpcyBPUiBtYWtlIGl0IG9wdGlvbmFsXG5cblxuICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuXG4gICAgICBjb25zdCB0aXAgPSB0aGlzLl9nZXRUaXBFbGVtZW50KCk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGlwLmdldEF0dHJpYnV0ZSgnaWQnKSk7XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGFpbmVyXG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xuXG4gICAgICBpZiAoIXRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy50aXApKSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmQodGlwKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSU5TRVJURUQpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcG9wcGVyID0gdGhpcy5fY3JlYXRlUG9wcGVyKHRpcCk7XG4gICAgICB0aXAuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckMik7IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcbiAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XG4gICAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xuICAgICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXG5cbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xuICAgICAgICAgIEV2ZW50SGFuZGxlci5vbihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX1NIT1dOJDIpKTtcblxuICAgICAgICBpZiAodGhpcy5faXNIb3ZlcmVkID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2xlYXZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0hJREUkMikpO1xuXG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0aXAgPSB0aGlzLl9nZXRUaXBFbGVtZW50KCk7XG5cbiAgICAgIHRpcC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQyKTsgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcbiAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XG5cbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xuICAgICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9DTElDS10gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9GT0NVU10gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9IT1ZFUl0gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IG51bGw7IC8vIGl0IGlzIGEgdHJpY2sgdG8gc3VwcG9ydCBtYW51YWwgdHJpZ2dlcmluZ1xuXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5faXNIb3ZlcmVkKSB7XG4gICAgICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcblxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9ISURERU4kMikpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy50aXAsIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgICB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSAvLyBQcm90ZWN0ZWRcblxuXG4gICAgX2lzV2l0aENvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9nZXRUaXRsZSgpKTtcbiAgICB9XG5cbiAgICBfZ2V0VGlwRWxlbWVudCgpIHtcbiAgICAgIGlmICghdGhpcy50aXApIHtcbiAgICAgICAgdGhpcy50aXAgPSB0aGlzLl9jcmVhdGVUaXBFbGVtZW50KHRoaXMuX25ld0NvbnRlbnQgfHwgdGhpcy5fZ2V0Q29udGVudEZvclRlbXBsYXRlKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy50aXA7XG4gICAgfVxuXG4gICAgX2NyZWF0ZVRpcEVsZW1lbnQoY29udGVudCkge1xuICAgICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGVtcGxhdGVGYWN0b3J5KGNvbnRlbnQpLnRvSHRtbCgpOyAvLyB0b2RvOiByZW1vdmUgdGhpcyBjaGVjayBvbiB2NlxuXG5cbiAgICAgIGlmICghdGlwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aXAuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0ZBREUkMiwgQ0xBU1NfTkFNRV9TSE9XJDIpOyAvLyB0b2RvOiBvbiB2NiB0aGUgZm9sbG93aW5nIGNhbiBiZSBhY2hpZXZlZCB3aXRoIENTUyBvbmx5XG5cbiAgICAgIHRpcC5jbGFzc0xpc3QuYWRkKGBicy0ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXV0b2ApO1xuICAgICAgY29uc3QgdGlwSWQgPSBnZXRVSUQodGhpcy5jb25zdHJ1Y3Rvci5OQU1FKS50b1N0cmluZygpO1xuICAgICAgdGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aXBJZCk7XG5cbiAgICAgIGlmICh0aGlzLl9pc0FuaW1hdGVkKCkpIHtcbiAgICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9GQURFJDIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGlwO1xuICAgIH1cblxuICAgIHNldENvbnRlbnQoY29udGVudCkge1xuICAgICAgdGhpcy5fbmV3Q29udGVudCA9IGNvbnRlbnQ7XG5cbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuXG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRUZW1wbGF0ZUZhY3RvcnkoY29udGVudCkge1xuICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlRmFjdG9yeSkge1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkuY2hhbmdlQ29udGVudChjb250ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlRmFjdG9yeSA9IG5ldyBUZW1wbGF0ZUZhY3RvcnkoeyAuLi50aGlzLl9jb25maWcsXG4gICAgICAgICAgLy8gdGhlIGBjb250ZW50YCB2YXIgaGFzIHRvIGJlIGFmdGVyIGB0aGlzLl9jb25maWdgXG4gICAgICAgICAgLy8gdG8gb3ZlcnJpZGUgY29uZmlnLmNvbnRlbnQgaW4gY2FzZSBvZiBwb3BvdmVyXG4gICAgICAgICAgY29udGVudCxcbiAgICAgICAgICBleHRyYUNsYXNzOiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY3VzdG9tQ2xhc3MpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVGYWN0b3J5O1xuICAgIH1cblxuICAgIF9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbU0VMRUNUT1JfVE9PTFRJUF9JTk5FUl06IHRoaXMuX2dldFRpdGxlKClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgX2dldFRpdGxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy50aXRsZSkgfHwgdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnKTtcbiAgICB9IC8vIFByaXZhdGVcblxuXG4gICAgX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuZ2V0T3JDcmVhdGVJbnN0YW5jZShldmVudC5kZWxlZ2F0ZVRhcmdldCwgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSk7XG4gICAgfVxuXG4gICAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uZmlnLmFuaW1hdGlvbiB8fCB0aGlzLnRpcCAmJiB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDIpO1xuICAgIH1cblxuICAgIF9pc1Nob3duKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGlwICYmIHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckMik7XG4gICAgfVxuXG4gICAgX2NyZWF0ZVBvcHBlcih0aXApIHtcbiAgICAgIGNvbnN0IHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLl9jb25maWcucGxhY2VtZW50ID09PSAnZnVuY3Rpb24nID8gdGhpcy5fY29uZmlnLnBsYWNlbWVudC5jYWxsKHRoaXMsIHRpcCwgdGhpcy5fZWxlbWVudCkgOiB0aGlzLl9jb25maWcucGxhY2VtZW50O1xuICAgICAgY29uc3QgYXR0YWNobWVudCA9IEF0dGFjaG1lbnRNYXBbcGxhY2VtZW50LnRvVXBwZXJDYXNlKCldO1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvcHBlcih0aGlzLl9lbGVtZW50LCB0aXAsIHRoaXMuX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSk7XG4gICAgfVxuXG4gICAgX2dldE9mZnNldCgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xuXG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldC5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiBOdW1iZXIucGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBwb3BwZXJEYXRhID0+IG9mZnNldChwb3BwZXJEYXRhLCB0aGlzLl9lbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGFyZy5jYWxsKHRoaXMuX2VsZW1lbnQpIDogYXJnO1xuICAgIH1cblxuICAgIF9nZXRQb3BwZXJDb25maWcoYXR0YWNobWVudCkge1xuICAgICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IGF0dGFjaG1lbnQsXG4gICAgICAgIG1vZGlmaWVyczogW3tcbiAgICAgICAgICBuYW1lOiAnZmxpcCcsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiB0aGlzLl9jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRzXG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiAnYXJyb3cnLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGAuJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9LWFycm93YFxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6ICdwcmVTZXRQbGFjZW1lbnQnLFxuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgcGhhc2U6ICdiZWZvcmVNYWluJyxcbiAgICAgICAgICBmbjogZGF0YSA9PiB7XG4gICAgICAgICAgICAvLyBQcmUtc2V0IFBvcHBlcidzIHBsYWNlbWVudCBhdHRyaWJ1dGUgaW4gb3JkZXIgdG8gcmVhZCB0aGUgYXJyb3cgc2l6ZXMgcHJvcGVybHkuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIFBvcHBlciBtaXhlcyB1cCB0aGUgd2lkdGggYW5kIGhlaWdodCBkaW1lbnNpb25zIHNpbmNlIHRoZSBpbml0aWFsIGFycm93IHN0eWxlIGlzIGZvciB0b3AgcGxhY2VtZW50XG4gICAgICAgICAgICB0aGlzLl9nZXRUaXBFbGVtZW50KCkuc2V0QXR0cmlidXRlKCdkYXRhLXBvcHBlci1wbGFjZW1lbnQnLCBkYXRhLnN0YXRlLnBsYWNlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcbiAgICAgICAgLi4uKHR5cGVvZiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnID09PSAnZnVuY3Rpb24nID8gdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyhkZWZhdWx0QnNQb3BwZXJDb25maWcpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgX3NldExpc3RlbmVycygpIHtcbiAgICAgIGNvbnN0IHRyaWdnZXJzID0gdGhpcy5fY29uZmlnLnRyaWdnZXIuc3BsaXQoJyAnKTtcblxuICAgICAgZm9yIChjb25zdCB0cmlnZ2VyIG9mIHRyaWdnZXJzKSB7XG4gICAgICAgIGlmICh0cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0NMSUNLJDEpLCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpO1xuXG4gICAgICAgICAgICBjb250ZXh0LnRvZ2dsZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgIT09IFRSSUdHRVJfTUFOVUFMKSB7XG4gICAgICAgICAgY29uc3QgZXZlbnRJbiA9IHRyaWdnZXIgPT09IFRSSUdHRVJfSE9WRVIgPyB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9NT1VTRUVOVEVSKSA6IHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0ZPQ1VTSU4kMSk7XG4gICAgICAgICAgY29uc3QgZXZlbnRPdXQgPSB0cmlnZ2VyID09PSBUUklHR0VSX0hPVkVSID8gdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfTU9VU0VMRUFWRSkgOiB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9GT0NVU09VVCQxKTtcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgZXZlbnRJbiwgdGhpcy5fY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KTtcblxuICAgICAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNpbicgPyBUUklHR0VSX0ZPQ1VTIDogVFJJR0dFUl9IT1ZFUl0gPSB0cnVlO1xuXG4gICAgICAgICAgICBjb250ZXh0Ll9lbnRlcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBldmVudE91dCwgdGhpcy5fY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KTtcblxuICAgICAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNvdXQnID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gY29udGV4dC5fZWxlbWVudC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KTtcblxuICAgICAgICAgICAgY29udGV4dC5fbGVhdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX01PREFMKSwgRVZFTlRfTU9EQUxfSElERSwgdGhpcy5faGlkZU1vZGFsSGFuZGxlcik7XG4gICAgfVxuXG4gICAgX2ZpeFRpdGxlKCkge1xuICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKTtcblxuICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSAmJiAhdGhpcy5fZWxlbWVudC50ZXh0Q29udGVudC50cmltKCkpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJywgdGl0bGUpOyAvLyBETyBOT1QgVVNFIElULiBJcyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5cbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0aXRsZScpO1xuICAgIH1cblxuICAgIF9lbnRlcigpIHtcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKCkgfHwgdGhpcy5faXNIb3ZlcmVkKSB7XG4gICAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNIb3ZlcmVkID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9pc0hvdmVyZWQpIHtcbiAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5LnNob3cpO1xuICAgIH1cblxuICAgIF9sZWF2ZSgpIHtcbiAgICAgIGlmICh0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcblxuICAgICAgdGhpcy5fc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5faXNIb3ZlcmVkKSB7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheS5oaWRlKTtcbiAgICB9XG5cbiAgICBfc2V0VGltZW91dChoYW5kbGVyLCB0aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChoYW5kbGVyLCB0aW1lb3V0KTtcbiAgICB9XG5cbiAgICBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2FjdGl2ZVRyaWdnZXIpLmluY2x1ZGVzKHRydWUpO1xuICAgIH1cblxuICAgIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgICBjb25zdCBkYXRhQXR0cmlidXRlcyA9IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgICBmb3IgKGNvbnN0IGRhdGFBdHRyaWJ1dGUgb2YgT2JqZWN0LmtleXMoZGF0YUF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIGlmIChESVNBTExPV0VEX0FUVFJJQlVURVMuaGFzKGRhdGFBdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgZGVsZXRlIGRhdGFBdHRyaWJ1dGVzW2RhdGFBdHRyaWJ1dGVdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbmZpZyA9IHsgLi4uZGF0YUF0dHJpYnV0ZXMsXG4gICAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcbiAgICAgIH07XG4gICAgICBjb25maWcgPSB0aGlzLl9tZXJnZUNvbmZpZ09iaihjb25maWcpO1xuICAgICAgY29uZmlnID0gdGhpcy5fY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpO1xuXG4gICAgICB0aGlzLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKTtcblxuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICAgIGNvbmZpZy5jb250YWluZXIgPSBjb25maWcuY29udGFpbmVyID09PSBmYWxzZSA/IGRvY3VtZW50LmJvZHkgOiBnZXRFbGVtZW50KGNvbmZpZy5jb250YWluZXIpO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5kZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uZmlnLmRlbGF5ID0ge1xuICAgICAgICAgIHNob3c6IGNvbmZpZy5kZWxheSxcbiAgICAgICAgICBoaWRlOiBjb25maWcuZGVsYXlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcudGl0bGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmZpZy50aXRsZSA9IGNvbmZpZy50aXRsZS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5jb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25maWcuY29udGVudCA9IGNvbmZpZy5jb250ZW50LnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgX2dldERlbGVnYXRlQ29uZmlnKCkge1xuICAgICAgY29uc3QgY29uZmlnID0ge307XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuX2NvbmZpZykge1xuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2tleV0gIT09IHRoaXMuX2NvbmZpZ1trZXldKSB7XG4gICAgICAgICAgY29uZmlnW2tleV0gPSB0aGlzLl9jb25maWdba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25maWcuc2VsZWN0b3IgPSBmYWxzZTtcbiAgICAgIGNvbmZpZy50cmlnZ2VyID0gJ21hbnVhbCc7IC8vIEluIHRoZSBmdXR1cmUgY2FuIGJlIHJlcGxhY2VkIHdpdGg6XG4gICAgICAvLyBjb25zdCBrZXlzV2l0aERpZmZlcmVudFZhbHVlcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuX2NvbmZpZykuZmlsdGVyKGVudHJ5ID0+IHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtlbnRyeVswXV0gIT09IHRoaXMuX2NvbmZpZ1tlbnRyeVswXV0pXG4gICAgICAvLyBgT2JqZWN0LmZyb21FbnRyaWVzKGtleXNXaXRoRGlmZmVyZW50VmFsdWVzKWBcblxuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBfZGlzcG9zZVBvcHBlcigpIHtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcblxuICAgICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50aXApIHtcbiAgICAgICAgdGhpcy50aXAucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMudGlwID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IC8vIFN0YXRpY1xuXG5cbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBUb29sdGlwLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfVxuICAvKipcbiAgICogalF1ZXJ5XG4gICAqL1xuXG5cbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKFRvb2x0aXApO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IHBvcG92ZXIuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkMyA9ICdwb3BvdmVyJztcbiAgY29uc3QgU0VMRUNUT1JfVElUTEUgPSAnLnBvcG92ZXItaGVhZGVyJztcbiAgY29uc3QgU0VMRUNUT1JfQ09OVEVOVCA9ICcucG9wb3Zlci1ib2R5JztcbiAgY29uc3QgRGVmYXVsdCQyID0geyAuLi5Ub29sdGlwLkRlZmF1bHQsXG4gICAgY29udGVudDogJycsXG4gICAgb2Zmc2V0OiBbMCwgOF0sXG4gICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInBvcG92ZXJcIiByb2xlPVwidG9vbHRpcFwiPicgKyAnPGRpdiBjbGFzcz1cInBvcG92ZXItYXJyb3dcIj48L2Rpdj4nICsgJzxoMyBjbGFzcz1cInBvcG92ZXItaGVhZGVyXCI+PC9oMz4nICsgJzxkaXYgY2xhc3M9XCJwb3BvdmVyLWJvZHlcIj48L2Rpdj4nICsgJzwvZGl2PicsXG4gICAgdHJpZ2dlcjogJ2NsaWNrJ1xuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSQyID0geyAuLi5Ub29sdGlwLkRlZmF1bHRUeXBlLFxuICAgIGNvbnRlbnQ6ICcobnVsbHxzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknXG4gIH07XG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIFBvcG92ZXIgZXh0ZW5kcyBUb29sdGlwIHtcbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQkMjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDI7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkMztcbiAgICB9IC8vIE92ZXJyaWRlc1xuXG5cbiAgICBfaXNXaXRoQ29udGVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRUaXRsZSgpIHx8IHRoaXMuX2dldENvbnRlbnQoKTtcbiAgICB9IC8vIFByaXZhdGVcblxuXG4gICAgX2dldENvbnRlbnRGb3JUZW1wbGF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtTRUxFQ1RPUl9USVRMRV06IHRoaXMuX2dldFRpdGxlKCksXG4gICAgICAgIFtTRUxFQ1RPUl9DT05URU5UXTogdGhpcy5fZ2V0Q29udGVudCgpXG4gICAgICB9O1xuICAgIH1cblxuICAgIF9nZXRDb250ZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jb250ZW50KTtcbiAgICB9IC8vIFN0YXRpY1xuXG5cbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBQb3BvdmVyLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfVxuICAvKipcbiAgICogalF1ZXJ5XG4gICAqL1xuXG5cbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKFBvcG92ZXIpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IHNjcm9sbHNweS5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSQyID0gJ3Njcm9sbHNweSc7XG4gIGNvbnN0IERBVEFfS0VZJDIgPSAnYnMuc2Nyb2xsc3B5JztcbiAgY29uc3QgRVZFTlRfS0VZJDIgPSBgLiR7REFUQV9LRVkkMn1gO1xuICBjb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgY29uc3QgRVZFTlRfQUNUSVZBVEUgPSBgYWN0aXZhdGUke0VWRU5UX0tFWSQyfWA7XG4gIGNvbnN0IEVWRU5UX0NMSUNLID0gYGNsaWNrJHtFVkVOVF9LRVkkMn1gO1xuICBjb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDEgPSBgbG9hZCR7RVZFTlRfS0VZJDJ9JHtEQVRBX0FQSV9LRVl9YDtcbiAgY29uc3QgQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNID0gJ2Ryb3Bkb3duLWl0ZW0nO1xuICBjb25zdCBDTEFTU19OQU1FX0FDVElWRSQxID0gJ2FjdGl2ZSc7XG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfU1BZID0gJ1tkYXRhLWJzLXNweT1cInNjcm9sbFwiXSc7XG4gIGNvbnN0IFNFTEVDVE9SX1RBUkdFVF9MSU5LUyA9ICdbaHJlZl0nO1xuICBjb25zdCBTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCA9ICcubmF2LCAubGlzdC1ncm91cCc7XG4gIGNvbnN0IFNFTEVDVE9SX05BVl9MSU5LUyA9ICcubmF2LWxpbmsnO1xuICBjb25zdCBTRUxFQ1RPUl9OQVZfSVRFTVMgPSAnLm5hdi1pdGVtJztcbiAgY29uc3QgU0VMRUNUT1JfTElTVF9JVEVNUyA9ICcubGlzdC1ncm91cC1pdGVtJztcbiAgY29uc3QgU0VMRUNUT1JfTElOS19JVEVNUyA9IGAke1NFTEVDVE9SX05BVl9MSU5LU30sICR7U0VMRUNUT1JfTkFWX0lURU1TfSA+ICR7U0VMRUNUT1JfTkFWX0xJTktTfSwgJHtTRUxFQ1RPUl9MSVNUX0lURU1TfWA7XG4gIGNvbnN0IFNFTEVDVE9SX0RST1BET1dOID0gJy5kcm9wZG93bic7XG4gIGNvbnN0IFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxID0gJy5kcm9wZG93bi10b2dnbGUnO1xuICBjb25zdCBEZWZhdWx0JDEgPSB7XG4gICAgb2Zmc2V0OiBudWxsLFxuICAgIC8vIFRPRE86IHY2IEBkZXByZWNhdGVkLCBrZWVwIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zXG4gICAgcm9vdE1hcmdpbjogJzBweCAwcHggLTI1JScsXG4gICAgc21vb3RoU2Nyb2xsOiBmYWxzZSxcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgdGhyZXNob2xkOiBbMC4xLCAwLjUsIDFdXG4gIH07XG4gIGNvbnN0IERlZmF1bHRUeXBlJDEgPSB7XG4gICAgb2Zmc2V0OiAnKG51bWJlcnxudWxsKScsXG4gICAgLy8gVE9ETyB2NiBAZGVwcmVjYXRlZCwga2VlcCBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29uc1xuICAgIHJvb3RNYXJnaW46ICdzdHJpbmcnLFxuICAgIHNtb290aFNjcm9sbDogJ2Jvb2xlYW4nLFxuICAgIHRhcmdldDogJ2VsZW1lbnQnLFxuICAgIHRocmVzaG9sZDogJ2FycmF5J1xuICB9O1xuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBTY3JvbGxTcHkgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7IC8vIHRoaXMuX2VsZW1lbnQgaXMgdGhlIG9ic2VydmFibGVzQ29udGFpbmVyIGFuZCBjb25maWcudGFyZ2V0IHRoZSBtZW51IGxpbmtzIHdyYXBwZXJcblxuICAgICAgdGhpcy5fdGFyZ2V0TGlua3MgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLl9yb290RWxlbWVudCA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudCkub3ZlcmZsb3dZID09PSAndmlzaWJsZScgPyBudWxsIDogdGhpcy5fZWxlbWVudDtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG4gICAgICB0aGlzLl9wcmV2aW91c1Njcm9sbERhdGEgPSB7XG4gICAgICAgIHZpc2libGVFbnRyeVRvcDogMCxcbiAgICAgICAgcGFyZW50U2Nyb2xsVG9wOiAwXG4gICAgICB9O1xuICAgICAgdGhpcy5yZWZyZXNoKCk7IC8vIGluaXRpYWxpemVcbiAgICB9IC8vIEdldHRlcnNcblxuXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQkMTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDE7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkMjtcbiAgICB9IC8vIFB1YmxpY1xuXG5cbiAgICByZWZyZXNoKCkge1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZVRhcmdldHNBbmRPYnNlcnZhYmxlcygpO1xuXG4gICAgICB0aGlzLl9tYXliZUVuYWJsZVNtb290aFNjcm9sbCgpO1xuXG4gICAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSB0aGlzLl9nZXROZXdPYnNlcnZlcigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHNlY3Rpb24gb2YgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zLnZhbHVlcygpKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUoc2VjdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH0gLy8gUHJpdmF0ZVxuXG5cbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICAgIC8vIFRPRE86IG9uIHY2IHRhcmdldCBzaG91bGQgYmUgZ2l2ZW4gZXhwbGljaXRseSAmIHJlbW92ZSB0aGUge3RhcmdldDogJ3NzLXRhcmdldCd9IGNhc2VcbiAgICAgIGNvbmZpZy50YXJnZXQgPSBnZXRFbGVtZW50KGNvbmZpZy50YXJnZXQpIHx8IGRvY3VtZW50LmJvZHk7IC8vIFRPRE86IHY2IE9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnMuIFVzZSByb290TWFyZ2luIG9ubHlcblxuICAgICAgY29uZmlnLnJvb3RNYXJnaW4gPSBjb25maWcub2Zmc2V0ID8gYCR7Y29uZmlnLm9mZnNldH1weCAwcHggLTMwJWAgOiBjb25maWcucm9vdE1hcmdpbjtcblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcudGhyZXNob2xkID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25maWcudGhyZXNob2xkID0gY29uZmlnLnRocmVzaG9sZC5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiBOdW1iZXIucGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIF9tYXliZUVuYWJsZVNtb290aFNjcm9sbCgpIHtcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnNtb290aFNjcm9sbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHVucmVnaXN0ZXIgYW55IHByZXZpb3VzIGxpc3RlbmVyc1xuXG5cbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fY29uZmlnLnRhcmdldCwgRVZFTlRfQ0xJQ0spO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2NvbmZpZy50YXJnZXQsIEVWRU5UX0NMSUNLLCBTRUxFQ1RPUl9UQVJHRVRfTElOS1MsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZVNlY3Rpb24gPSB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMuZ2V0KGV2ZW50LnRhcmdldC5oYXNoKTtcblxuICAgICAgICBpZiAob2JzZXJ2YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLl9yb290RWxlbWVudCB8fCB3aW5kb3c7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gb2JzZXJ2YWJsZVNlY3Rpb24ub2Zmc2V0VG9wIC0gdGhpcy5fZWxlbWVudC5vZmZzZXRUb3A7XG5cbiAgICAgICAgICBpZiAocm9vdC5zY3JvbGxUbykge1xuICAgICAgICAgICAgcm9vdC5zY3JvbGxUbyh7XG4gICAgICAgICAgICAgIHRvcDogaGVpZ2h0LFxuICAgICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gQ2hyb21lIDYwIGRvZXNuJ3Qgc3VwcG9ydCBgc2Nyb2xsVG9gXG5cblxuICAgICAgICAgIHJvb3Quc2Nyb2xsVG9wID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfZ2V0TmV3T2JzZXJ2ZXIoKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICByb290OiB0aGlzLl9yb290RWxlbWVudCxcbiAgICAgICAgdGhyZXNob2xkOiB0aGlzLl9jb25maWcudGhyZXNob2xkLFxuICAgICAgICByb290TWFyZ2luOiB0aGlzLl9jb25maWcucm9vdE1hcmdpblxuICAgICAgfTtcbiAgICAgIHJldHVybiBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB0aGlzLl9vYnNlcnZlckNhbGxiYWNrKGVudHJpZXMpLCBvcHRpb25zKTtcbiAgICB9IC8vIFRoZSBsb2dpYyBvZiBzZWxlY3Rpb25cblxuXG4gICAgX29ic2VydmVyQ2FsbGJhY2soZW50cmllcykge1xuICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGVudHJ5ID0+IHRoaXMuX3RhcmdldExpbmtzLmdldChgIyR7ZW50cnkudGFyZ2V0LmlkfWApO1xuXG4gICAgICBjb25zdCBhY3RpdmF0ZSA9IGVudHJ5ID0+IHtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnZpc2libGVFbnRyeVRvcCA9IGVudHJ5LnRhcmdldC5vZmZzZXRUb3A7XG5cbiAgICAgICAgdGhpcy5fcHJvY2Vzcyh0YXJnZXRFbGVtZW50KGVudHJ5KSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBwYXJlbnRTY3JvbGxUb3AgPSAodGhpcy5fcm9vdEVsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5zY3JvbGxUb3A7XG4gICAgICBjb25zdCB1c2VyU2Nyb2xsc0Rvd24gPSBwYXJlbnRTY3JvbGxUb3AgPj0gdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnBhcmVudFNjcm9sbFRvcDtcbiAgICAgIHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS5wYXJlbnRTY3JvbGxUb3AgPSBwYXJlbnRTY3JvbGxUb3A7XG5cbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBpZiAoIWVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICAgIHRoaXMuX2NsZWFyQWN0aXZlQ2xhc3ModGFyZ2V0RWxlbWVudChlbnRyeSkpO1xuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMgPSBlbnRyeS50YXJnZXQub2Zmc2V0VG9wID49IHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS52aXNpYmxlRW50cnlUb3A7IC8vIGlmIHdlIGFyZSBzY3JvbGxpbmcgZG93biwgcGljayB0aGUgYmlnZ2VyIG9mZnNldFRvcFxuXG4gICAgICAgIGlmICh1c2VyU2Nyb2xsc0Rvd24gJiYgZW50cnlJc0xvd2VyVGhhblByZXZpb3VzKSB7XG4gICAgICAgICAgYWN0aXZhdGUoZW50cnkpOyAvLyBpZiBwYXJlbnQgaXNuJ3Qgc2Nyb2xsZWQsIGxldCdzIGtlZXAgdGhlIGZpcnN0IHZpc2libGUgaXRlbSwgYnJlYWtpbmcgdGhlIGl0ZXJhdGlvblxuXG4gICAgICAgICAgaWYgKCFwYXJlbnRTY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBpZiB3ZSBhcmUgc2Nyb2xsaW5nIHVwLCBwaWNrIHRoZSBzbWFsbGVzdCBvZmZzZXRUb3BcblxuXG4gICAgICAgIGlmICghdXNlclNjcm9sbHNEb3duICYmICFlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMpIHtcbiAgICAgICAgICBhY3RpdmF0ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfaW5pdGlhbGl6ZVRhcmdldHNBbmRPYnNlcnZhYmxlcygpIHtcbiAgICAgIHRoaXMuX3RhcmdldExpbmtzID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgdGFyZ2V0TGlua3MgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX1RBUkdFVF9MSU5LUywgdGhpcy5fY29uZmlnLnRhcmdldCk7XG5cbiAgICAgIGZvciAoY29uc3QgYW5jaG9yIG9mIHRhcmdldExpbmtzKSB7XG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBhbmNob3IgaGFzIGFuIGlkIGFuZCBpcyBub3QgZGlzYWJsZWRcbiAgICAgICAgaWYgKCFhbmNob3IuaGFzaCB8fCBpc0Rpc2FibGVkKGFuY2hvcikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9ic2VydmFibGVTZWN0aW9uID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShhbmNob3IuaGFzaCwgdGhpcy5fZWxlbWVudCk7IC8vIGVuc3VyZSB0aGF0IHRoZSBvYnNlcnZhYmxlU2VjdGlvbiBleGlzdHMgJiBpcyB2aXNpYmxlXG5cbiAgICAgICAgaWYgKGlzVmlzaWJsZShvYnNlcnZhYmxlU2VjdGlvbikpIHtcbiAgICAgICAgICB0aGlzLl90YXJnZXRMaW5rcy5zZXQoYW5jaG9yLmhhc2gsIGFuY2hvcik7XG5cbiAgICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMuc2V0KGFuY2hvci5oYXNoLCBvYnNlcnZhYmxlU2VjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcHJvY2Vzcyh0YXJnZXQpIHtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgPT09IHRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NsZWFyQWN0aXZlQ2xhc3ModGhpcy5fY29uZmlnLnRhcmdldCk7XG5cbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHRhcmdldDtcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuXG4gICAgICB0aGlzLl9hY3RpdmF0ZVBhcmVudHModGFyZ2V0KTtcblxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfQUNUSVZBVEUsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGFyZ2V0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfYWN0aXZhdGVQYXJlbnRzKHRhcmdldCkge1xuICAgICAgLy8gQWN0aXZhdGUgZHJvcGRvd24gcGFyZW50c1xuICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNKSkge1xuICAgICAgICBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxLCB0YXJnZXQuY2xvc2VzdChTRUxFQ1RPUl9EUk9QRE9XTikpLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBsaXN0R3JvdXAgb2YgU2VsZWN0b3JFbmdpbmUucGFyZW50cyh0YXJnZXQsIFNFTEVDVE9SX05BVl9MSVNUX0dST1VQKSkge1xuICAgICAgICAvLyBTZXQgdHJpZ2dlcmVkIGxpbmtzIHBhcmVudHMgYXMgYWN0aXZlXG4gICAgICAgIC8vIFdpdGggYm90aCA8dWw+IGFuZCA8bmF2PiBtYXJrdXAgYSBwYXJlbnQgaXMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYW55IG5hdiBhbmNlc3RvclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgU2VsZWN0b3JFbmdpbmUucHJldihsaXN0R3JvdXAsIFNFTEVDVE9SX0xJTktfSVRFTVMpKSB7XG4gICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2NsZWFyQWN0aXZlQ2xhc3MocGFyZW50KSB7XG4gICAgICBwYXJlbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQxKTtcbiAgICAgIGNvbnN0IGFjdGl2ZU5vZGVzID0gU2VsZWN0b3JFbmdpbmUuZmluZChgJHtTRUxFQ1RPUl9UQVJHRVRfTElOS1N9LiR7Q0xBU1NfTkFNRV9BQ1RJVkUkMX1gLCBwYXJlbnQpO1xuXG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgYWN0aXZlTm9kZXMpIHtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgICAgfVxuICAgIH0gLy8gU3RhdGljXG5cblxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFNjcm9sbFNweS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH1cbiAgLyoqXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gICAqL1xuXG5cbiAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQxLCAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBzcHkgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1NQWSkpIHtcbiAgICAgIFNjcm9sbFNweS5nZXRPckNyZWF0ZUluc3RhbmNlKHNweSk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oU2Nyb2xsU3B5KTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwICh2NS4yLjMpOiB0YWIuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkMSA9ICd0YWInO1xuICBjb25zdCBEQVRBX0tFWSQxID0gJ2JzLnRhYic7XG4gIGNvbnN0IEVWRU5UX0tFWSQxID0gYC4ke0RBVEFfS0VZJDF9YDtcbiAgY29uc3QgRVZFTlRfSElERSQxID0gYGhpZGUke0VWRU5UX0tFWSQxfWA7XG4gIGNvbnN0IEVWRU5UX0hJRERFTiQxID0gYGhpZGRlbiR7RVZFTlRfS0VZJDF9YDtcbiAgY29uc3QgRVZFTlRfU0hPVyQxID0gYHNob3cke0VWRU5UX0tFWSQxfWA7XG4gIGNvbnN0IEVWRU5UX1NIT1dOJDEgPSBgc2hvd24ke0VWRU5UX0tFWSQxfWA7XG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVkkMX1gO1xuICBjb25zdCBFVkVOVF9LRVlET1dOID0gYGtleWRvd24ke0VWRU5UX0tFWSQxfWA7XG4gIGNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkgPSBgbG9hZCR7RVZFTlRfS0VZJDF9YDtcbiAgY29uc3QgQVJST1dfTEVGVF9LRVkgPSAnQXJyb3dMZWZ0JztcbiAgY29uc3QgQVJST1dfUklHSFRfS0VZID0gJ0Fycm93UmlnaHQnO1xuICBjb25zdCBBUlJPV19VUF9LRVkgPSAnQXJyb3dVcCc7XG4gIGNvbnN0IEFSUk9XX0RPV05fS0VZID0gJ0Fycm93RG93bic7XG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFID0gJ2FjdGl2ZSc7XG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQxID0gJ2ZhZGUnO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckMSA9ICdzaG93JztcbiAgY29uc3QgQ0xBU1NfRFJPUERPV04gPSAnZHJvcGRvd24nO1xuICBjb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUgPSAnLmRyb3Bkb3duLXRvZ2dsZSc7XG4gIGNvbnN0IFNFTEVDVE9SX0RST1BET1dOX01FTlUgPSAnLmRyb3Bkb3duLW1lbnUnO1xuICBjb25zdCBOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFID0gJzpub3QoLmRyb3Bkb3duLXRvZ2dsZSknO1xuICBjb25zdCBTRUxFQ1RPUl9UQUJfUEFORUwgPSAnLmxpc3QtZ3JvdXAsIC5uYXYsIFtyb2xlPVwidGFibGlzdFwiXSc7XG4gIGNvbnN0IFNFTEVDVE9SX09VVEVSID0gJy5uYXYtaXRlbSwgLmxpc3QtZ3JvdXAtaXRlbSc7XG4gIGNvbnN0IFNFTEVDVE9SX0lOTkVSID0gYC5uYXYtbGluayR7Tk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRX0sIC5saXN0LWdyb3VwLWl0ZW0ke05PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9LCBbcm9sZT1cInRhYlwiXSR7Tk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRX1gO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS1icy10b2dnbGU9XCJ0YWJcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cInBpbGxcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cImxpc3RcIl0nOyAvLyB0b2RvOnY2OiBjb3VsZCBiZSBvbmx5IGB0YWJgXG5cbiAgY29uc3QgU0VMRUNUT1JfSU5ORVJfRUxFTSA9IGAke1NFTEVDVE9SX0lOTkVSfSwgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRX1gO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUgPSBgLiR7Q0xBU1NfTkFNRV9BQ1RJVkV9W2RhdGEtYnMtdG9nZ2xlPVwidGFiXCJdLCAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJwaWxsXCJdLCAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJsaXN0XCJdYDtcbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgVGFiIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgICAgc3VwZXIoZWxlbWVudCk7XG4gICAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoU0VMRUNUT1JfVEFCX1BBTkVMKTtcblxuICAgICAgaWYgKCF0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuOyAvLyB0b2RvOiBzaG91bGQgVGhyb3cgZXhjZXB0aW9uIG9uIHY2XG4gICAgICAgIC8vIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZWxlbWVudC5vdXRlckhUTUx9IGhhcyBub3QgYSB2YWxpZCBwYXJlbnQgJHtTRUxFQ1RPUl9JTk5FUl9FTEVNfWApXG4gICAgICB9IC8vIFNldCB1cCBpbml0aWFsIGFyaWEgYXR0cmlidXRlc1xuXG5cbiAgICAgIHRoaXMuX3NldEluaXRpYWxBdHRyaWJ1dGVzKHRoaXMuX3BhcmVudCwgdGhpcy5fZ2V0Q2hpbGRyZW4oKSk7XG5cbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOLCBldmVudCA9PiB0aGlzLl9rZXlkb3duKGV2ZW50KSk7XG4gICAgfSAvLyBHZXR0ZXJzXG5cblxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDE7XG4gICAgfSAvLyBQdWJsaWNcblxuXG4gICAgc2hvdygpIHtcbiAgICAgIC8vIFNob3dzIHRoaXMgZWxlbSBhbmQgZGVhY3RpdmF0ZSB0aGUgYWN0aXZlIHNpYmxpbmcgaWYgZXhpc3RzXG4gICAgICBjb25zdCBpbm5lckVsZW0gPSB0aGlzLl9lbGVtZW50O1xuXG4gICAgICBpZiAodGhpcy5fZWxlbUlzQWN0aXZlKGlubmVyRWxlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBTZWFyY2ggZm9yIGFjdGl2ZSB0YWIgb24gc2FtZSBwYXJlbnQgdG8gZGVhY3RpdmF0ZSBpdFxuXG5cbiAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW0oKTtcblxuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gYWN0aXZlID8gRXZlbnRIYW5kbGVyLnRyaWdnZXIoYWN0aXZlLCBFVkVOVF9ISURFJDEsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogaW5uZXJFbGVtXG4gICAgICB9KSA6IG51bGw7XG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcihpbm5lckVsZW0sIEVWRU5UX1NIT1ckMSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBhY3RpdmVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgaGlkZUV2ZW50ICYmIGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZGVhY3RpdmF0ZShhY3RpdmUsIGlubmVyRWxlbSk7XG5cbiAgICAgIHRoaXMuX2FjdGl2YXRlKGlubmVyRWxlbSwgYWN0aXZlKTtcbiAgICB9IC8vIFByaXZhdGVcblxuXG4gICAgX2FjdGl2YXRlKGVsZW1lbnQsIHJlbGF0ZWRFbGVtKSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xuXG4gICAgICB0aGlzLl9hY3RpdmF0ZShnZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpKTsgLy8gU2VhcmNoIGFuZCBhY3RpdmF0ZS9zaG93IHRoZSBwcm9wZXIgc2VjdGlvblxuXG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIHRydWUpO1xuXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKGVsZW1lbnQsIEVWRU5UX1NIT1dOJDEsIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkRWxlbVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIGVsZW1lbnQsIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQxKSk7XG4gICAgfVxuXG4gICAgX2RlYWN0aXZhdGUoZWxlbWVudCwgcmVsYXRlZEVsZW0pIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgICBlbGVtZW50LmJsdXIoKTtcblxuICAgICAgdGhpcy5fZGVhY3RpdmF0ZShnZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpKTsgLy8gU2VhcmNoIGFuZCBkZWFjdGl2YXRlIHRoZSBzaG93biBzZWN0aW9uIHRvb1xuXG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcblxuICAgICAgICB0aGlzLl90b2dnbGVEcm9wRG93bihlbGVtZW50LCBmYWxzZSk7XG5cbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIoZWxlbWVudCwgRVZFTlRfSElEREVOJDEsIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkRWxlbVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIGVsZW1lbnQsIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQxKSk7XG4gICAgfVxuXG4gICAgX2tleWRvd24oZXZlbnQpIHtcbiAgICAgIGlmICghW0FSUk9XX0xFRlRfS0VZLCBBUlJPV19SSUdIVF9LRVksIEFSUk9XX1VQX0tFWSwgQVJST1dfRE9XTl9LRVldLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3RvcFByb3BhZ2F0aW9uL3ByZXZlbnREZWZhdWx0IGJvdGggYWRkZWQgdG8gc3VwcG9ydCB1cC9kb3duIGtleXMgd2l0aG91dCBzY3JvbGxpbmcgdGhlIHBhZ2VcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGlzTmV4dCA9IFtBUlJPV19SSUdIVF9LRVksIEFSUk9XX0RPV05fS0VZXS5pbmNsdWRlcyhldmVudC5rZXkpO1xuICAgICAgY29uc3QgbmV4dEFjdGl2ZUVsZW1lbnQgPSBnZXROZXh0QWN0aXZlRWxlbWVudCh0aGlzLl9nZXRDaGlsZHJlbigpLmZpbHRlcihlbGVtZW50ID0+ICFpc0Rpc2FibGVkKGVsZW1lbnQpKSwgZXZlbnQudGFyZ2V0LCBpc05leHQsIHRydWUpO1xuXG4gICAgICBpZiAobmV4dEFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgbmV4dEFjdGl2ZUVsZW1lbnQuZm9jdXMoe1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKG5leHRBY3RpdmVFbGVtZW50KS5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2dldENoaWxkcmVuKCkge1xuICAgICAgLy8gY29sbGVjdGlvbiBvZiBpbm5lciBlbGVtZW50c1xuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSU5ORVJfRUxFTSwgdGhpcy5fcGFyZW50KTtcbiAgICB9XG5cbiAgICBfZ2V0QWN0aXZlRWxlbSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDaGlsZHJlbigpLmZpbmQoY2hpbGQgPT4gdGhpcy5fZWxlbUlzQWN0aXZlKGNoaWxkKSkgfHwgbnVsbDtcbiAgICB9XG5cbiAgICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXMocGFyZW50LCBjaGlsZHJlbikge1xuICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMocGFyZW50LCAncm9sZScsICd0YWJsaXN0Jyk7XG5cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5fc2V0SW5pdGlhbEF0dHJpYnV0ZXNPbkNoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPbkNoaWxkKGNoaWxkKSB7XG4gICAgICBjaGlsZCA9IHRoaXMuX2dldElubmVyRWxlbWVudChjaGlsZCk7XG5cbiAgICAgIGNvbnN0IGlzQWN0aXZlID0gdGhpcy5fZWxlbUlzQWN0aXZlKGNoaWxkKTtcblxuICAgICAgY29uc3Qgb3V0ZXJFbGVtID0gdGhpcy5fZ2V0T3V0ZXJFbGVtZW50KGNoaWxkKTtcblxuICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgaXNBY3RpdmUpO1xuXG4gICAgICBpZiAob3V0ZXJFbGVtICE9PSBjaGlsZCkge1xuICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhvdXRlckVsZW0sICdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMoY2hpbGQsICdyb2xlJywgJ3RhYicpOyAvLyBzZXQgYXR0cmlidXRlcyB0byB0aGUgcmVsYXRlZCBwYW5lbCB0b29cblxuXG4gICAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlc09uVGFyZ2V0UGFuZWwoY2hpbGQpO1xuICAgIH1cblxuICAgIF9zZXRJbml0aWFsQXR0cmlidXRlc09uVGFyZ2V0UGFuZWwoY2hpbGQpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IoY2hpbGQpO1xuXG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKHRhcmdldCwgJ3JvbGUnLCAndGFicGFuZWwnKTtcblxuICAgICAgaWYgKGNoaWxkLmlkKSB7XG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKHRhcmdldCwgJ2FyaWEtbGFiZWxsZWRieScsIGAjJHtjaGlsZC5pZH1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdG9nZ2xlRHJvcERvd24oZWxlbWVudCwgb3Blbikge1xuICAgICAgY29uc3Qgb3V0ZXJFbGVtID0gdGhpcy5fZ2V0T3V0ZXJFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICBpZiAoIW91dGVyRWxlbS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfRFJPUERPV04pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9nZ2xlID0gKHNlbGVjdG9yLCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoc2VsZWN0b3IsIG91dGVyRWxlbSk7XG5cbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lLCBvcGVuKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdG9nZ2xlKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSwgQ0xBU1NfTkFNRV9BQ1RJVkUpO1xuICAgICAgdG9nZ2xlKFNFTEVDVE9SX0RST1BET1dOX01FTlUsIENMQVNTX05BTUVfU0hPVyQxKTtcbiAgICAgIG91dGVyRWxlbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBvcGVuKTtcbiAgICB9XG5cbiAgICBfc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9lbGVtSXNBY3RpdmUoZWxlbSkge1xuICAgICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICB9IC8vIFRyeSB0byBnZXQgdGhlIGlubmVyIGVsZW1lbnQgKHVzdWFsbHkgdGhlIC5uYXYtbGluaylcblxuXG4gICAgX2dldElubmVyRWxlbWVudChlbGVtKSB7XG4gICAgICByZXR1cm4gZWxlbS5tYXRjaGVzKFNFTEVDVE9SX0lOTkVSX0VMRU0pID8gZWxlbSA6IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfSU5ORVJfRUxFTSwgZWxlbSk7XG4gICAgfSAvLyBUcnkgdG8gZ2V0IHRoZSBvdXRlciBlbGVtZW50ICh1c3VhbGx5IHRoZSAubmF2LWl0ZW0pXG5cblxuICAgIF9nZXRPdXRlckVsZW1lbnQoZWxlbSkge1xuICAgICAgcmV0dXJuIGVsZW0uY2xvc2VzdChTRUxFQ1RPUl9PVVRFUikgfHwgZWxlbTtcbiAgICB9IC8vIFN0YXRpY1xuXG5cbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfVxuICAvKipcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAgICovXG5cblxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpLnNob3coKTtcbiAgfSk7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIG9uIGZvY3VzXG4gICAqL1xuXG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEksICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUpKSB7XG4gICAgICBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogalF1ZXJ5XG4gICAqL1xuXG4gIGRlZmluZUpRdWVyeVBsdWdpbihUYWIpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IHRvYXN0LmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FID0gJ3RvYXN0JztcbiAgY29uc3QgREFUQV9LRVkgPSAnYnMudG9hc3QnO1xuICBjb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YDtcbiAgY29uc3QgRVZFTlRfTU9VU0VPVkVSID0gYG1vdXNlb3ZlciR7RVZFTlRfS0VZfWA7XG4gIGNvbnN0IEVWRU5UX01PVVNFT1VUID0gYG1vdXNlb3V0JHtFVkVOVF9LRVl9YDtcbiAgY29uc3QgRVZFTlRfRk9DVVNJTiA9IGBmb2N1c2luJHtFVkVOVF9LRVl9YDtcbiAgY29uc3QgRVZFTlRfRk9DVVNPVVQgPSBgZm9jdXNvdXQke0VWRU5UX0tFWX1gO1xuICBjb25zdCBFVkVOVF9ISURFID0gYGhpZGUke0VWRU5UX0tFWX1gO1xuICBjb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YDtcbiAgY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YDtcbiAgY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gO1xuICBjb25zdCBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSc7XG4gIGNvbnN0IENMQVNTX05BTUVfSElERSA9ICdoaWRlJzsgLy8gQGRlcHJlY2F0ZWQgLSBrZXB0IGhlcmUgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuICBjb25zdCBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdyc7XG4gIGNvbnN0IENMQVNTX05BTUVfU0hPV0lORyA9ICdzaG93aW5nJztcbiAgY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gICAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXG4gICAgYXV0b2hpZGU6ICdib29sZWFuJyxcbiAgICBkZWxheTogJ251bWJlcidcbiAgfTtcbiAgY29uc3QgRGVmYXVsdCA9IHtcbiAgICBhbmltYXRpb246IHRydWUsXG4gICAgYXV0b2hpZGU6IHRydWUsXG4gICAgZGVsYXk6IDUwMDBcbiAgfTtcbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgVG9hc3QgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBmYWxzZTtcblxuICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XG4gICAgfSAvLyBHZXR0ZXJzXG5cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGU7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUU7XG4gICAgfSAvLyBQdWJsaWNcblxuXG4gICAgc2hvdygpIHtcbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1cpO1xuXG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XSU5HKTtcblxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTik7XG5cbiAgICAgICAgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0hJREUpOyAvLyBAZGVwcmVjYXRlZFxuXG5cbiAgICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVywgQ0xBU1NfTkFNRV9TSE9XSU5HKTtcblxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbik7XG4gICAgfVxuXG4gICAgaGlkZSgpIHtcbiAgICAgIGlmICghdGhpcy5pc1Nob3duKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFKTtcblxuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0hJREUpOyAvLyBAZGVwcmVjYXRlZFxuXG5cbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORywgQ0xBU1NfTkFNRV9TSE9XKTtcblxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4pO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPV0lORyk7XG5cbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xuICAgIH1cblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcblxuICAgICAgaWYgKHRoaXMuaXNTaG93bigpKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1cpO1xuICAgICAgfVxuXG4gICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgaXNTaG93bigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1cpO1xuICAgIH0gLy8gUHJpdmF0ZVxuXG5cbiAgICBfbWF5YmVTY2hlZHVsZUhpZGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5hdXRvaGlkZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uIHx8IHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5KTtcbiAgICB9XG5cbiAgICBfb25JbnRlcmFjdGlvbihldmVudCwgaXNJbnRlcmFjdGluZykge1xuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ21vdXNlb3Zlcic6XG4gICAgICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gaXNJbnRlcmFjdGluZztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBpc0ludGVyYWN0aW5nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNJbnRlcmFjdGluZykge1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcblxuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQgPT09IG5leHRFbGVtZW50IHx8IHRoaXMuX2VsZW1lbnQuY29udGFpbnMobmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcbiAgICB9XG5cbiAgICBfc2V0TGlzdGVuZXJzKCkge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFT1ZFUiwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgdHJ1ZSkpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFT1VULCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCBmYWxzZSkpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0ZPQ1VTSU4sIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIHRydWUpKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9GT0NVU09VVCwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgZmFsc2UpKTtcbiAgICB9XG5cbiAgICBfY2xlYXJUaW1lb3V0KCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgfSAvLyBTdGF0aWNcblxuXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gVG9hc3QuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICB9XG4gIC8qKlxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICAgKi9cblxuXG4gIGVuYWJsZURpc21pc3NUcmlnZ2VyKFRvYXN0KTtcbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oVG9hc3QpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgKHY1LjIuMyk6IGluZGV4LnVtZC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG4gIGNvbnN0IGluZGV4X3VtZCA9IHtcbiAgICBBbGVydCxcbiAgICBCdXR0b24sXG4gICAgQ2Fyb3VzZWwsXG4gICAgQ29sbGFwc2UsXG4gICAgRHJvcGRvd24sXG4gICAgTW9kYWwsXG4gICAgT2ZmY2FudmFzLFxuICAgIFBvcG92ZXIsXG4gICAgU2Nyb2xsU3B5LFxuICAgIFRhYixcbiAgICBUb2FzdCxcbiAgICBUb29sdGlwXG4gIH07XG5cbiAgcmV0dXJuIGluZGV4X3VtZDtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vdHN0cmFwLmJ1bmRsZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImdsb2JhbFRoaXMiLCJzZWxmIiwiYm9vdHN0cmFwIiwiTUFYX1VJRCIsIk1JTExJU0VDT05EU19NVUxUSVBMSUVSIiwiVFJBTlNJVElPTl9FTkQiLCJ0b1R5cGUiLCJvYmplY3QiLCJ1bmRlZmluZWQiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJtYXRjaCIsInRvTG93ZXJDYXNlIiwiZ2V0VUlEIiwicHJlZml4IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImdldFNlbGVjdG9yIiwiZWxlbWVudCIsInNlbGVjdG9yIiwiZ2V0QXR0cmlidXRlIiwiaHJlZkF0dHJpYnV0ZSIsImluY2x1ZGVzIiwic3RhcnRzV2l0aCIsInNwbGl0IiwidHJpbSIsImdldFNlbGVjdG9yRnJvbUVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiZ2V0RWxlbWVudEZyb21TZWxlY3RvciIsImdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50Iiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25EZWxheSIsImZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uIiwiTnVtYmVyIiwicGFyc2VGbG9hdCIsImZsb2F0VHJhbnNpdGlvbkRlbGF5IiwidHJpZ2dlclRyYW5zaXRpb25FbmQiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJpc0VsZW1lbnQkMSIsImpxdWVyeSIsIm5vZGVUeXBlIiwiZ2V0RWxlbWVudCIsImxlbmd0aCIsImlzVmlzaWJsZSIsImdldENsaWVudFJlY3RzIiwiZWxlbWVudElzVmlzaWJsZSIsImdldFByb3BlcnR5VmFsdWUiLCJjbG9zZWREZXRhaWxzIiwiY2xvc2VzdCIsInN1bW1hcnkiLCJwYXJlbnROb2RlIiwiaXNEaXNhYmxlZCIsIk5vZGUiLCJFTEVNRU5UX05PREUiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImRpc2FibGVkIiwiaGFzQXR0cmlidXRlIiwiZmluZFNoYWRvd1Jvb3QiLCJkb2N1bWVudEVsZW1lbnQiLCJhdHRhY2hTaGFkb3ciLCJnZXRSb290Tm9kZSIsInJvb3QiLCJTaGFkb3dSb290Iiwibm9vcCIsInJlZmxvdyIsIm9mZnNldEhlaWdodCIsImdldGpRdWVyeSIsImpRdWVyeSIsImJvZHkiLCJET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzIiwib25ET01Db250ZW50TG9hZGVkIiwiY2FsbGJhY2siLCJyZWFkeVN0YXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInB1c2giLCJpc1JUTCIsImRpciIsImRlZmluZUpRdWVyeVBsdWdpbiIsInBsdWdpbiIsIiQiLCJuYW1lIiwiTkFNRSIsIkpRVUVSWV9OT19DT05GTElDVCIsImZuIiwialF1ZXJ5SW50ZXJmYWNlIiwiQ29uc3RydWN0b3IiLCJub0NvbmZsaWN0IiwiZXhlY3V0ZSIsImV4ZWN1dGVBZnRlclRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uRWxlbWVudCIsIndhaXRGb3JUcmFuc2l0aW9uIiwiZHVyYXRpb25QYWRkaW5nIiwiZW11bGF0ZWREdXJhdGlvbiIsImNhbGxlZCIsImhhbmRsZXIiLCJ0YXJnZXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2V0VGltZW91dCIsImdldE5leHRBY3RpdmVFbGVtZW50IiwibGlzdCIsImFjdGl2ZUVsZW1lbnQiLCJzaG91bGRHZXROZXh0IiwiaXNDeWNsZUFsbG93ZWQiLCJsaXN0TGVuZ3RoIiwiaW5kZXgiLCJpbmRleE9mIiwibWF4IiwibWluIiwibmFtZXNwYWNlUmVnZXgiLCJzdHJpcE5hbWVSZWdleCIsInN0cmlwVWlkUmVnZXgiLCJldmVudFJlZ2lzdHJ5IiwidWlkRXZlbnQiLCJjdXN0b21FdmVudHMiLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsIm5hdGl2ZUV2ZW50cyIsIlNldCIsIm1ha2VFdmVudFVpZCIsInVpZCIsImdldEVsZW1lbnRFdmVudHMiLCJib290c3RyYXBIYW5kbGVyIiwiZXZlbnQiLCJoeWRyYXRlT2JqIiwiZGVsZWdhdGVUYXJnZXQiLCJvbmVPZmYiLCJFdmVudEhhbmRsZXIiLCJvZmYiLCJ0eXBlIiwiYXBwbHkiLCJib290c3RyYXBEZWxlZ2F0aW9uSGFuZGxlciIsImRvbUVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImRvbUVsZW1lbnQiLCJmaW5kSGFuZGxlciIsImV2ZW50cyIsImNhbGxhYmxlIiwiZGVsZWdhdGlvblNlbGVjdG9yIiwidmFsdWVzIiwiZmluZCIsIm5vcm1hbGl6ZVBhcmFtZXRlcnMiLCJvcmlnaW5hbFR5cGVFdmVudCIsImRlbGVnYXRpb25GdW5jdGlvbiIsImlzRGVsZWdhdGVkIiwidHlwZUV2ZW50IiwiZ2V0VHlwZUV2ZW50IiwiaGFzIiwiYWRkSGFuZGxlciIsIndyYXBGdW5jdGlvbiIsInJlbGF0ZWRUYXJnZXQiLCJoYW5kbGVycyIsInByZXZpb3VzRnVuY3Rpb24iLCJyZXBsYWNlIiwicmVtb3ZlSGFuZGxlciIsIkJvb2xlYW4iLCJyZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMiLCJuYW1lc3BhY2UiLCJzdG9yZUVsZW1lbnRFdmVudCIsImtleXMiLCJoYW5kbGVyS2V5Iiwib24iLCJvbmUiLCJpbk5hbWVzcGFjZSIsImlzTmFtZXNwYWNlIiwiZWxlbWVudEV2ZW50Iiwic2xpY2UiLCJrZXlIYW5kbGVycyIsInRyaWdnZXIiLCJhcmdzIiwialF1ZXJ5RXZlbnQiLCJidWJibGVzIiwibmF0aXZlRGlzcGF0Y2giLCJkZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCIsImlzRGVmYXVsdFByZXZlbnRlZCIsImV2dCIsImNhbmNlbGFibGUiLCJwcmV2ZW50RGVmYXVsdCIsIm9iaiIsIm1ldGEiLCJrZXkiLCJ2YWx1ZSIsIl91bnVzZWQiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImdldCIsImVudHJpZXMiLCJlbGVtZW50TWFwIiwiTWFwIiwiRGF0YSIsInNldCIsImluc3RhbmNlIiwiaW5zdGFuY2VNYXAiLCJzaXplIiwiY29uc29sZSIsImVycm9yIiwiQXJyYXkiLCJmcm9tIiwicmVtb3ZlIiwibm9ybWFsaXplRGF0YSIsIkpTT04iLCJwYXJzZSIsImRlY29kZVVSSUNvbXBvbmVudCIsIm5vcm1hbGl6ZURhdGFLZXkiLCJjaHIiLCJNYW5pcHVsYXRvciIsInNldERhdGFBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVEYXRhQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiZ2V0RGF0YUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwiYnNLZXlzIiwiZGF0YXNldCIsImZpbHRlciIsInB1cmVLZXkiLCJjaGFyQXQiLCJnZXREYXRhQXR0cmlidXRlIiwiQ29uZmlnIiwiY29uZmlnIiwiX21lcmdlQ29uZmlnT2JqIiwiX2NvbmZpZ0FmdGVyTWVyZ2UiLCJfdHlwZUNoZWNrQ29uZmlnIiwianNvbkNvbmZpZyIsImNvbnN0cnVjdG9yIiwiRGVmYXVsdCIsImNvbmZpZ1R5cGVzIiwiRGVmYXVsdFR5cGUiLCJwcm9wZXJ0eSIsImV4cGVjdGVkVHlwZXMiLCJ2YWx1ZVR5cGUiLCJSZWdFeHAiLCJ0ZXN0IiwiVHlwZUVycm9yIiwidG9VcHBlckNhc2UiLCJFcnJvciIsIlZFUlNJT04iLCJCYXNlQ29tcG9uZW50IiwiX2VsZW1lbnQiLCJfY29uZmlnIiwiX2dldENvbmZpZyIsIkRBVEFfS0VZIiwiRVZFTlRfS0VZIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInByb3BlcnR5TmFtZSIsImlzQW5pbWF0ZWQiLCJnZXRJbnN0YW5jZSIsImVuYWJsZURpc21pc3NUcmlnZ2VyIiwiY29tcG9uZW50IiwibWV0aG9kIiwiY2xpY2tFdmVudCIsInRhZ05hbWUiLCJnZXRPckNyZWF0ZUluc3RhbmNlIiwiTkFNRSRmIiwiREFUQV9LRVkkYSIsIkVWRU5UX0tFWSRiIiwiRVZFTlRfQ0xPU0UiLCJFVkVOVF9DTE9TRUQiLCJDTEFTU19OQU1FX0ZBREUkNSIsIkNMQVNTX05BTUVfU0hPVyQ4IiwiQWxlcnQiLCJjbG9zZUV2ZW50IiwiX3F1ZXVlQ2FsbGJhY2siLCJfZGVzdHJveUVsZW1lbnQiLCJkaXNwb3NlIiwiZWFjaCIsImRhdGEiLCJOQU1FJGUiLCJEQVRBX0tFWSQ5IiwiRVZFTlRfS0VZJGEiLCJEQVRBX0FQSV9LRVkkNiIsIkNMQVNTX05BTUVfQUNUSVZFJDMiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1IiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNiIsIkJ1dHRvbiIsInRvZ2dsZSIsImJ1dHRvbiIsIlNlbGVjdG9yRW5naW5lIiwiY29uY2F0IiwiRWxlbWVudCIsImZpbmRPbmUiLCJjaGlsZHJlbiIsImNoaWxkIiwibWF0Y2hlcyIsInBhcmVudHMiLCJhbmNlc3RvciIsInByZXYiLCJwcmV2aW91cyIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJuZXh0IiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiZm9jdXNhYmxlQ2hpbGRyZW4iLCJmb2N1c2FibGVzIiwibWFwIiwiam9pbiIsImVsIiwiTkFNRSRkIiwiRVZFTlRfS0VZJDkiLCJFVkVOVF9UT1VDSFNUQVJUIiwiRVZFTlRfVE9VQ0hNT1ZFIiwiRVZFTlRfVE9VQ0hFTkQiLCJFVkVOVF9QT0lOVEVSRE9XTiIsIkVWRU5UX1BPSU5URVJVUCIsIlBPSU5URVJfVFlQRV9UT1VDSCIsIlBPSU5URVJfVFlQRV9QRU4iLCJDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQiLCJTV0lQRV9USFJFU0hPTEQiLCJEZWZhdWx0JGMiLCJlbmRDYWxsYmFjayIsImxlZnRDYWxsYmFjayIsInJpZ2h0Q2FsbGJhY2siLCJEZWZhdWx0VHlwZSRjIiwiU3dpcGUiLCJpc1N1cHBvcnRlZCIsIl9kZWx0YVgiLCJfc3VwcG9ydFBvaW50ZXJFdmVudHMiLCJQb2ludGVyRXZlbnQiLCJfaW5pdEV2ZW50cyIsInRvdWNoZXMiLCJjbGllbnRYIiwiX2V2ZW50SXNQb2ludGVyUGVuVG91Y2giLCJfaGFuZGxlU3dpcGUiLCJhYnNEZWx0YVgiLCJhYnMiLCJkaXJlY3Rpb24iLCJfc3RhcnQiLCJfZW5kIiwiYWRkIiwiX21vdmUiLCJwb2ludGVyVHlwZSIsIm5hdmlnYXRvciIsIm1heFRvdWNoUG9pbnRzIiwiTkFNRSRjIiwiREFUQV9LRVkkOCIsIkVWRU5UX0tFWSQ4IiwiREFUQV9BUElfS0VZJDUiLCJBUlJPV19MRUZUX0tFWSQxIiwiQVJST1dfUklHSFRfS0VZJDEiLCJUT1VDSEVWRU5UX0NPTVBBVF9XQUlUIiwiT1JERVJfTkVYVCIsIk9SREVSX1BSRVYiLCJESVJFQ1RJT05fTEVGVCIsIkRJUkVDVElPTl9SSUdIVCIsIkVWRU5UX1NMSURFIiwiRVZFTlRfU0xJRCIsIkVWRU5UX0tFWURPV04kMSIsIkVWRU5UX01PVVNFRU5URVIkMSIsIkVWRU5UX01PVVNFTEVBVkUkMSIsIkVWRU5UX0RSQUdfU1RBUlQiLCJFVkVOVF9MT0FEX0RBVEFfQVBJJDMiLCJFVkVOVF9DTElDS19EQVRBX0FQSSQ1IiwiQ0xBU1NfTkFNRV9DQVJPVVNFTCIsIkNMQVNTX05BTUVfQUNUSVZFJDIiLCJDTEFTU19OQU1FX1NMSURFIiwiQ0xBU1NfTkFNRV9FTkQiLCJDTEFTU19OQU1FX1NUQVJUIiwiQ0xBU1NfTkFNRV9ORVhUIiwiQ0xBU1NfTkFNRV9QUkVWIiwiU0VMRUNUT1JfQUNUSVZFIiwiU0VMRUNUT1JfSVRFTSIsIlNFTEVDVE9SX0FDVElWRV9JVEVNIiwiU0VMRUNUT1JfSVRFTV9JTUciLCJTRUxFQ1RPUl9JTkRJQ0FUT1JTIiwiU0VMRUNUT1JfREFUQV9TTElERSIsIlNFTEVDVE9SX0RBVEFfUklERSIsIktFWV9UT19ESVJFQ1RJT04iLCJEZWZhdWx0JGIiLCJpbnRlcnZhbCIsImtleWJvYXJkIiwicGF1c2UiLCJyaWRlIiwidG91Y2giLCJ3cmFwIiwiRGVmYXVsdFR5cGUkYiIsIkNhcm91c2VsIiwiX2ludGVydmFsIiwiX2FjdGl2ZUVsZW1lbnQiLCJfaXNTbGlkaW5nIiwidG91Y2hUaW1lb3V0IiwiX3N3aXBlSGVscGVyIiwiX2luZGljYXRvcnNFbGVtZW50IiwiX2FkZEV2ZW50TGlzdGVuZXJzIiwiY3ljbGUiLCJfc2xpZGUiLCJoaWRkZW4iLCJfY2xlYXJJbnRlcnZhbCIsIl91cGRhdGVJbnRlcnZhbCIsInNldEludGVydmFsIiwibmV4dFdoZW5WaXNpYmxlIiwiaXRlbXMiLCJfZ2V0SXRlbXMiLCJ0byIsImFjdGl2ZUluZGV4IiwiX2dldEl0ZW1JbmRleCIsIl9nZXRBY3RpdmUiLCJvcmRlciIsImRlZmF1bHRJbnRlcnZhbCIsIl9rZXlkb3duIiwiX21heWJlRW5hYmxlQ3ljbGUiLCJfYWRkVG91Y2hFdmVudExpc3RlbmVycyIsImltZyIsImVuZENhbGxCYWNrIiwiY2xlYXJUaW1lb3V0Iiwic3dpcGVDb25maWciLCJfZGlyZWN0aW9uVG9PcmRlciIsImFjdGl2ZUluZGljYXRvciIsIm5ld0FjdGl2ZUluZGljYXRvciIsImVsZW1lbnRJbnRlcnZhbCIsInBhcnNlSW50IiwiaXNOZXh0IiwibmV4dEVsZW1lbnQiLCJuZXh0RWxlbWVudEluZGV4IiwidHJpZ2dlckV2ZW50IiwiZXZlbnROYW1lIiwiX29yZGVyVG9EaXJlY3Rpb24iLCJzbGlkZUV2ZW50IiwiaXNDeWNsaW5nIiwiX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQiLCJkaXJlY3Rpb25hbENsYXNzTmFtZSIsIm9yZGVyQ2xhc3NOYW1lIiwiY29tcGxldGVDYWxsQmFjayIsIl9pc0FuaW1hdGVkIiwiY2xlYXJJbnRlcnZhbCIsImNhcm91c2VsIiwic2xpZGVJbmRleCIsImNhcm91c2VscyIsIk5BTUUkYiIsIkRBVEFfS0VZJDciLCJFVkVOVF9LRVkkNyIsIkRBVEFfQVBJX0tFWSQ0IiwiRVZFTlRfU0hPVyQ2IiwiRVZFTlRfU0hPV04kNiIsIkVWRU5UX0hJREUkNiIsIkVWRU5UX0hJRERFTiQ2IiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCIsIkNMQVNTX05BTUVfU0hPVyQ3IiwiQ0xBU1NfTkFNRV9DT0xMQVBTRSIsIkNMQVNTX05BTUVfQ09MTEFQU0lORyIsIkNMQVNTX05BTUVfQ09MTEFQU0VEIiwiQ0xBU1NfTkFNRV9ERUVQRVJfQ0hJTERSRU4iLCJDTEFTU19OQU1FX0hPUklaT05UQUwiLCJXSURUSCIsIkhFSUdIVCIsIlNFTEVDVE9SX0FDVElWRVMiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0IiwiRGVmYXVsdCRhIiwicGFyZW50IiwiRGVmYXVsdFR5cGUkYSIsIkNvbGxhcHNlIiwiX2lzVHJhbnNpdGlvbmluZyIsIl90cmlnZ2VyQXJyYXkiLCJ0b2dnbGVMaXN0IiwiZWxlbSIsImZpbHRlckVsZW1lbnQiLCJmb3VuZEVsZW1lbnQiLCJfaW5pdGlhbGl6ZUNoaWxkcmVuIiwiX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyIsIl9pc1Nob3duIiwiaGlkZSIsInNob3ciLCJhY3RpdmVDaGlsZHJlbiIsIl9nZXRGaXJzdExldmVsQ2hpbGRyZW4iLCJzdGFydEV2ZW50IiwiYWN0aXZlSW5zdGFuY2UiLCJkaW1lbnNpb24iLCJfZ2V0RGltZW5zaW9uIiwic3R5bGUiLCJjb21wbGV0ZSIsImNhcGl0YWxpemVkRGltZW5zaW9uIiwic2Nyb2xsU2l6ZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNlbGVjdGVkIiwidHJpZ2dlckFycmF5IiwiaXNPcGVuIiwic2VsZWN0b3JFbGVtZW50cyIsInRvcCIsImJvdHRvbSIsInJpZ2h0IiwibGVmdCIsImF1dG8iLCJiYXNlUGxhY2VtZW50cyIsInN0YXJ0IiwiZW5kIiwiY2xpcHBpbmdQYXJlbnRzIiwidmlld3BvcnQiLCJwb3BwZXIiLCJyZWZlcmVuY2UiLCJ2YXJpYXRpb25QbGFjZW1lbnRzIiwicmVkdWNlIiwiYWNjIiwicGxhY2VtZW50IiwicGxhY2VtZW50cyIsImJlZm9yZVJlYWQiLCJyZWFkIiwiYWZ0ZXJSZWFkIiwiYmVmb3JlTWFpbiIsIm1haW4iLCJhZnRlck1haW4iLCJiZWZvcmVXcml0ZSIsIndyaXRlIiwiYWZ0ZXJXcml0ZSIsIm1vZGlmaWVyUGhhc2VzIiwiZ2V0Tm9kZU5hbWUiLCJub2RlTmFtZSIsImdldFdpbmRvdyIsIm5vZGUiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJpc0VsZW1lbnQiLCJPd25FbGVtZW50IiwiaXNIVE1MRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNTaGFkb3dSb290IiwiYXBwbHlTdHlsZXMiLCJfcmVmIiwic3RhdGUiLCJlbGVtZW50cyIsImZvckVhY2giLCJzdHlsZXMiLCJhc3NpZ24iLCJlZmZlY3QkMiIsIl9yZWYyIiwiaW5pdGlhbFN0eWxlcyIsInBvc2l0aW9uIiwib3B0aW9ucyIsInN0cmF0ZWd5IiwibWFyZ2luIiwiYXJyb3ciLCJzdHlsZVByb3BlcnRpZXMiLCJoYXNPd25Qcm9wZXJ0eSIsImF0dHJpYnV0ZSIsImFwcGx5U3R5bGVzJDEiLCJlbmFibGVkIiwicGhhc2UiLCJlZmZlY3QiLCJyZXF1aXJlcyIsImdldEJhc2VQbGFjZW1lbnQiLCJyb3VuZCIsImdldFVBU3RyaW5nIiwidWFEYXRhIiwidXNlckFnZW50RGF0YSIsImJyYW5kcyIsIml0ZW0iLCJicmFuZCIsInZlcnNpb24iLCJ1c2VyQWdlbnQiLCJpc0xheW91dFZpZXdwb3J0IiwiaW5jbHVkZVNjYWxlIiwiaXNGaXhlZFN0cmF0ZWd5IiwiY2xpZW50UmVjdCIsInNjYWxlWCIsInNjYWxlWSIsIm9mZnNldFdpZHRoIiwid2lkdGgiLCJoZWlnaHQiLCJ2aXN1YWxWaWV3cG9ydCIsImFkZFZpc3VhbE9mZnNldHMiLCJ4Iiwib2Zmc2V0TGVmdCIsInkiLCJvZmZzZXRUb3AiLCJnZXRMYXlvdXRSZWN0Iiwicm9vdE5vZGUiLCJpc1NhbWVOb2RlIiwiaG9zdCIsImdldENvbXB1dGVkU3R5bGUkMSIsImlzVGFibGVFbGVtZW50IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiZ2V0UGFyZW50Tm9kZSIsImFzc2lnbmVkU2xvdCIsImdldFRydWVPZmZzZXRQYXJlbnQiLCJvZmZzZXRQYXJlbnQiLCJnZXRDb250YWluaW5nQmxvY2siLCJpc0ZpcmVmb3giLCJpc0lFIiwiZWxlbWVudENzcyIsImN1cnJlbnROb2RlIiwiY3NzIiwidHJhbnNmb3JtIiwicGVyc3BlY3RpdmUiLCJjb250YWluIiwid2lsbENoYW5nZSIsImdldE9mZnNldFBhcmVudCIsImdldE1haW5BeGlzRnJvbVBsYWNlbWVudCIsIndpdGhpbiIsIm1pbiQxIiwibWF4JDEiLCJ3aXRoaW5NYXhDbGFtcCIsInYiLCJnZXRGcmVzaFNpZGVPYmplY3QiLCJtZXJnZVBhZGRpbmdPYmplY3QiLCJwYWRkaW5nT2JqZWN0IiwiZXhwYW5kVG9IYXNoTWFwIiwiaGFzaE1hcCIsInRvUGFkZGluZ09iamVjdCIsInBhZGRpbmciLCJyZWN0cyIsIl9zdGF0ZSRtb2RpZmllcnNEYXRhJCIsImFycm93RWxlbWVudCIsInBvcHBlck9mZnNldHMiLCJtb2RpZmllcnNEYXRhIiwiYmFzZVBsYWNlbWVudCIsImF4aXMiLCJpc1ZlcnRpY2FsIiwibGVuIiwiYXJyb3dSZWN0IiwibWluUHJvcCIsIm1heFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiYXJyb3dPZmZzZXRQYXJlbnQiLCJjbGllbnRTaXplIiwiY2xpZW50SGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJjZW50ZXJUb1JlZmVyZW5jZSIsImNlbnRlciIsIm9mZnNldCIsImF4aXNQcm9wIiwiY2VudGVyT2Zmc2V0IiwiZWZmZWN0JDEiLCJfb3B0aW9ucyRlbGVtZW50IiwiYXJyb3ckMSIsInJlcXVpcmVzSWZFeGlzdHMiLCJnZXRWYXJpYXRpb24iLCJ1bnNldFNpZGVzIiwicm91bmRPZmZzZXRzQnlEUFIiLCJ3aW4iLCJkcHIiLCJkZXZpY2VQaXhlbFJhdGlvIiwibWFwVG9TdHlsZXMiLCJfT2JqZWN0JGFzc2lnbjIiLCJwb3BwZXJSZWN0IiwidmFyaWF0aW9uIiwib2Zmc2V0cyIsImdwdUFjY2VsZXJhdGlvbiIsImFkYXB0aXZlIiwicm91bmRPZmZzZXRzIiwiaXNGaXhlZCIsIl9vZmZzZXRzJHgiLCJfb2Zmc2V0cyR5IiwiX3JlZjMiLCJoYXNYIiwiaGFzWSIsInNpZGVYIiwic2lkZVkiLCJoZWlnaHRQcm9wIiwid2lkdGhQcm9wIiwib2Zmc2V0WSIsIm9mZnNldFgiLCJjb21tb25TdHlsZXMiLCJfcmVmNCIsIl9PYmplY3QkYXNzaWduIiwiY29tcHV0ZVN0eWxlcyIsIl9yZWY1IiwiX29wdGlvbnMkZ3B1QWNjZWxlcmF0IiwiX29wdGlvbnMkYWRhcHRpdmUiLCJfb3B0aW9ucyRyb3VuZE9mZnNldHMiLCJjb21wdXRlU3R5bGVzJDEiLCJwYXNzaXZlIiwiX29wdGlvbnMkc2Nyb2xsIiwic2Nyb2xsIiwiX29wdGlvbnMkcmVzaXplIiwicmVzaXplIiwic2Nyb2xsUGFyZW50cyIsInNjcm9sbFBhcmVudCIsInVwZGF0ZSIsImV2ZW50TGlzdGVuZXJzIiwiaGFzaCQxIiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJtYXRjaGVkIiwiaGFzaCIsImdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IiwiZ2V0V2luZG93U2Nyb2xsIiwic2Nyb2xsTGVmdCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsVG9wIiwicGFnZVlPZmZzZXQiLCJnZXRXaW5kb3dTY3JvbGxCYXJYIiwiZ2V0Vmlld3BvcnRSZWN0IiwiaHRtbCIsImxheW91dFZpZXdwb3J0IiwiZ2V0RG9jdW1lbnRSZWN0IiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwid2luU2Nyb2xsIiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJpc1Njcm9sbFBhcmVudCIsIl9nZXRDb21wdXRlZFN0eWxlIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJnZXRTY3JvbGxQYXJlbnQiLCJsaXN0U2Nyb2xsUGFyZW50cyIsImlzQm9keSIsInVwZGF0ZWRMaXN0IiwicmVjdFRvQ2xpZW50UmVjdCIsInJlY3QiLCJnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFRvcCIsImNsaWVudExlZnQiLCJnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZSIsImNsaXBwaW5nUGFyZW50IiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwiY2FuRXNjYXBlQ2xpcHBpbmciLCJjbGlwcGVyRWxlbWVudCIsImdldENsaXBwaW5nUmVjdCIsImJvdW5kYXJ5Iiwicm9vdEJvdW5kYXJ5IiwibWFpbkNsaXBwaW5nUGFyZW50cyIsImZpcnN0Q2xpcHBpbmdQYXJlbnQiLCJjbGlwcGluZ1JlY3QiLCJhY2NSZWN0IiwiY29tcHV0ZU9mZnNldHMiLCJjb21tb25YIiwiY29tbW9uWSIsIm1haW5BeGlzIiwiZGV0ZWN0T3ZlcmZsb3ciLCJfb3B0aW9ucyIsIl9vcHRpb25zJHBsYWNlbWVudCIsIl9vcHRpb25zJHN0cmF0ZWd5IiwiX29wdGlvbnMkYm91bmRhcnkiLCJfb3B0aW9ucyRyb290Qm91bmRhcnkiLCJfb3B0aW9ucyRlbGVtZW50Q29udGUiLCJlbGVtZW50Q29udGV4dCIsIl9vcHRpb25zJGFsdEJvdW5kYXJ5IiwiYWx0Qm91bmRhcnkiLCJfb3B0aW9ucyRwYWRkaW5nIiwiYWx0Q29udGV4dCIsImNsaXBwaW5nQ2xpZW50UmVjdCIsImNvbnRleHRFbGVtZW50IiwicmVmZXJlbmNlQ2xpZW50UmVjdCIsInBvcHBlckNsaWVudFJlY3QiLCJlbGVtZW50Q2xpZW50UmVjdCIsIm92ZXJmbG93T2Zmc2V0cyIsIm9mZnNldERhdGEiLCJtdWx0aXBseSIsImNvbXB1dGVBdXRvUGxhY2VtZW50IiwiZmxpcFZhcmlhdGlvbnMiLCJfb3B0aW9ucyRhbGxvd2VkQXV0b1AiLCJhbGxvd2VkQXV0b1BsYWNlbWVudHMiLCJwbGFjZW1lbnRzJDEiLCJhbGxvd2VkUGxhY2VtZW50cyIsIm92ZXJmbG93cyIsInNvcnQiLCJhIiwiYiIsImdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzIiwib3Bwb3NpdGVQbGFjZW1lbnQiLCJmbGlwIiwiX3NraXAiLCJfb3B0aW9ucyRtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJfb3B0aW9ucyRhbHRBeGlzIiwiYWx0QXhpcyIsImNoZWNrQWx0QXhpcyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrUGxhY2VtZW50cyIsIl9vcHRpb25zJGZsaXBWYXJpYXRpbyIsInByZWZlcnJlZFBsYWNlbWVudCIsImlzQmFzZVBsYWNlbWVudCIsInJlZmVyZW5jZVJlY3QiLCJjaGVja3NNYXAiLCJtYWtlRmFsbGJhY2tDaGVja3MiLCJmaXJzdEZpdHRpbmdQbGFjZW1lbnQiLCJpIiwiX2Jhc2VQbGFjZW1lbnQiLCJpc1N0YXJ0VmFyaWF0aW9uIiwibWFpblZhcmlhdGlvblNpZGUiLCJhbHRWYXJpYXRpb25TaWRlIiwiY2hlY2tzIiwiZXZlcnkiLCJjaGVjayIsIm51bWJlck9mQ2hlY2tzIiwiX2xvb3AiLCJfaSIsImZpdHRpbmdQbGFjZW1lbnQiLCJfcmV0IiwicmVzZXQiLCJmbGlwJDEiLCJnZXRTaWRlT2Zmc2V0cyIsInByZXZlbnRlZE9mZnNldHMiLCJpc0FueVNpZGVGdWxseUNsaXBwZWQiLCJzb21lIiwic2lkZSIsInByZXZlbnRPdmVyZmxvdyIsInJlZmVyZW5jZU92ZXJmbG93IiwicG9wcGVyQWx0T3ZlcmZsb3ciLCJyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMiLCJwb3BwZXJFc2NhcGVPZmZzZXRzIiwiaXNSZWZlcmVuY2VIaWRkZW4iLCJoYXNQb3BwZXJFc2NhcGVkIiwiaGlkZSQxIiwiZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkiLCJpbnZlcnREaXN0YW5jZSIsInNraWRkaW5nIiwiZGlzdGFuY2UiLCJfb3B0aW9ucyRvZmZzZXQiLCJfZGF0YSRzdGF0ZSRwbGFjZW1lbnQiLCJvZmZzZXQkMSIsInBvcHBlck9mZnNldHMkMSIsImdldEFsdEF4aXMiLCJfb3B0aW9ucyR0ZXRoZXIiLCJ0ZXRoZXIiLCJfb3B0aW9ucyR0ZXRoZXJPZmZzZXQiLCJ0ZXRoZXJPZmZzZXQiLCJ0ZXRoZXJPZmZzZXRWYWx1ZSIsIm5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSIsIm9mZnNldE1vZGlmaWVyU3RhdGUiLCJfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQiLCJtYWluU2lkZSIsImFsdFNpZGUiLCJhZGRpdGl2ZSIsIm1pbkxlbiIsIm1heExlbiIsImFycm93UGFkZGluZ09iamVjdCIsImFycm93UGFkZGluZ01pbiIsImFycm93UGFkZGluZ01heCIsImFycm93TGVuIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiY2xpZW50T2Zmc2V0Iiwib2Zmc2V0TW9kaWZpZXJWYWx1ZSIsInRldGhlck1pbiIsInRldGhlck1heCIsInByZXZlbnRlZE9mZnNldCIsIl9vZmZzZXRNb2RpZmllclN0YXRlJDIiLCJfbWFpblNpZGUiLCJfYWx0U2lkZSIsIl9vZmZzZXQiLCJfbGVuIiwiX21pbiIsIl9tYXgiLCJpc09yaWdpblNpZGUiLCJfb2Zmc2V0TW9kaWZpZXJWYWx1ZSIsIl90ZXRoZXJNaW4iLCJfdGV0aGVyTWF4IiwiX3ByZXZlbnRlZE9mZnNldCIsInByZXZlbnRPdmVyZmxvdyQxIiwiZ2V0SFRNTEVsZW1lbnRTY3JvbGwiLCJnZXROb2RlU2Nyb2xsIiwiaXNFbGVtZW50U2NhbGVkIiwiZ2V0Q29tcG9zaXRlUmVjdCIsImVsZW1lbnRPclZpcnR1YWxFbGVtZW50IiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJvZmZzZXRQYXJlbnRJc1NjYWxlZCIsIm1vZGlmaWVycyIsInZpc2l0ZWQiLCJyZXN1bHQiLCJtb2RpZmllciIsImRlcCIsImRlcE1vZGlmaWVyIiwib3JkZXJNb2RpZmllcnMiLCJvcmRlcmVkTW9kaWZpZXJzIiwiZGVib3VuY2UiLCJwZW5kaW5nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwibWVyZ2VCeU5hbWUiLCJtZXJnZWQiLCJjdXJyZW50IiwiZXhpc3RpbmciLCJERUZBVUxUX09QVElPTlMiLCJhcmVWYWxpZEVsZW1lbnRzIiwiYXJndW1lbnRzIiwiX2tleSIsInBvcHBlckdlbmVyYXRvciIsImdlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZiIsImRlZmF1bHRNb2RpZmllcnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyIiwiZGVmYXVsdE9wdGlvbnMiLCJjcmVhdGVQb3BwZXIiLCJlZmZlY3RDbGVhbnVwRm5zIiwiaXNEZXN0cm95ZWQiLCJzZXRPcHRpb25zIiwic2V0T3B0aW9uc0FjdGlvbiIsImNsZWFudXBNb2RpZmllckVmZmVjdHMiLCJtIiwicnVuTW9kaWZpZXJFZmZlY3RzIiwiZm9yY2VVcGRhdGUiLCJfc3RhdGUkZWxlbWVudHMiLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUiLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUyIiwiZGVzdHJveSIsIm9uRmlyc3RVcGRhdGUiLCJfcmVmMyRvcHRpb25zIiwiY2xlYW51cEZuIiwibm9vcEZuIiwiY3JlYXRlUG9wcGVyJDIiLCJkZWZhdWx0TW9kaWZpZXJzJDEiLCJjcmVhdGVQb3BwZXIkMSIsIlBvcHBlciIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsImNyZWF0ZVBvcHBlckJhc2UiLCJjcmVhdGVQb3BwZXJMaXRlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJOQU1FJGEiLCJEQVRBX0tFWSQ2IiwiRVZFTlRfS0VZJDYiLCJEQVRBX0FQSV9LRVkkMyIsIkVTQ0FQRV9LRVkkMiIsIlRBQl9LRVkkMSIsIkFSUk9XX1VQX0tFWSQxIiwiQVJST1dfRE9XTl9LRVkkMSIsIlJJR0hUX01PVVNFX0JVVFRPTiIsIkVWRU5UX0hJREUkNSIsIkVWRU5UX0hJRERFTiQ1IiwiRVZFTlRfU0hPVyQ1IiwiRVZFTlRfU0hPV04kNSIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJJDMiLCJFVkVOVF9LRVlET1dOX0RBVEFfQVBJIiwiRVZFTlRfS0VZVVBfREFUQV9BUEkiLCJDTEFTU19OQU1FX1NIT1ckNiIsIkNMQVNTX05BTUVfRFJPUFVQIiwiQ0xBU1NfTkFNRV9EUk9QRU5EIiwiQ0xBU1NfTkFNRV9EUk9QU1RBUlQiLCJDTEFTU19OQU1FX0RST1BVUF9DRU5URVIiLCJDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUiIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFJDMiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRV9TSE9XTiIsIlNFTEVDVE9SX01FTlUiLCJTRUxFQ1RPUl9OQVZCQVIiLCJTRUxFQ1RPUl9OQVZCQVJfTkFWIiwiU0VMRUNUT1JfVklTSUJMRV9JVEVNUyIsIlBMQUNFTUVOVF9UT1AiLCJQTEFDRU1FTlRfVE9QRU5EIiwiUExBQ0VNRU5UX0JPVFRPTSIsIlBMQUNFTUVOVF9CT1RUT01FTkQiLCJQTEFDRU1FTlRfUklHSFQiLCJQTEFDRU1FTlRfTEVGVCIsIlBMQUNFTUVOVF9UT1BDRU5URVIiLCJQTEFDRU1FTlRfQk9UVE9NQ0VOVEVSIiwiRGVmYXVsdCQ5IiwiYXV0b0Nsb3NlIiwiZGlzcGxheSIsInBvcHBlckNvbmZpZyIsIkRlZmF1bHRUeXBlJDkiLCJEcm9wZG93biIsIl9wb3BwZXIiLCJfcGFyZW50IiwiX21lbnUiLCJfaW5OYXZiYXIiLCJfZGV0ZWN0TmF2YmFyIiwic2hvd0V2ZW50IiwiX2NyZWF0ZVBvcHBlciIsImZvY3VzIiwiX2NvbXBsZXRlSGlkZSIsImhpZGVFdmVudCIsInJlZmVyZW5jZUVsZW1lbnQiLCJfZ2V0UG9wcGVyQ29uZmlnIiwicGFyZW50RHJvcGRvd24iLCJpc0VuZCIsInBvcHBlckRhdGEiLCJkZWZhdWx0QnNQb3BwZXJDb25maWciLCJfZ2V0UGxhY2VtZW50IiwiX2dldE9mZnNldCIsIm9wZW5Ub2dnbGVzIiwiY29udGV4dCIsImNvbXBvc2VkUGF0aCIsImlzTWVudVRhcmdldCIsImlzSW5wdXQiLCJpc0VzY2FwZUV2ZW50IiwiaXNVcE9yRG93bkV2ZW50IiwiZ2V0VG9nZ2xlQnV0dG9uIiwic3RvcFByb3BhZ2F0aW9uIiwiX3NlbGVjdE1lbnVJdGVtIiwiZGF0YUFwaUtleWRvd25IYW5kbGVyIiwiY2xlYXJNZW51cyIsIlNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQiLCJTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCIsIlBST1BFUlRZX1BBRERJTkciLCJQUk9QRVJUWV9NQVJHSU4iLCJTY3JvbGxCYXJIZWxwZXIiLCJkb2N1bWVudFdpZHRoIiwiaW5uZXJXaWR0aCIsImdldFdpZHRoIiwiX2Rpc2FibGVPdmVyRmxvdyIsIl9zZXRFbGVtZW50QXR0cmlidXRlcyIsImNhbGN1bGF0ZWRWYWx1ZSIsIl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzIiwiX3NhdmVJbml0aWFsQXR0cmlidXRlIiwic3R5bGVQcm9wZXJ0eSIsInNjcm9sbGJhcldpZHRoIiwibWFuaXB1bGF0aW9uQ2FsbEJhY2siLCJzZXRQcm9wZXJ0eSIsIl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrIiwiYWN0dWFsVmFsdWUiLCJyZW1vdmVQcm9wZXJ0eSIsImNhbGxCYWNrIiwic2VsIiwiTkFNRSQ5IiwiQ0xBU1NfTkFNRV9GQURFJDQiLCJDTEFTU19OQU1FX1NIT1ckNSIsIkVWRU5UX01PVVNFRE9XTiIsIkRlZmF1bHQkOCIsImNsYXNzTmFtZSIsImNsaWNrQ2FsbGJhY2siLCJyb290RWxlbWVudCIsIkRlZmF1bHRUeXBlJDgiLCJCYWNrZHJvcCIsIl9pc0FwcGVuZGVkIiwiX2FwcGVuZCIsIl9nZXRFbGVtZW50IiwiX2VtdWxhdGVBbmltYXRpb24iLCJiYWNrZHJvcCIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmQiLCJOQU1FJDgiLCJEQVRBX0tFWSQ1IiwiRVZFTlRfS0VZJDUiLCJFVkVOVF9GT0NVU0lOJDIiLCJFVkVOVF9LRVlET1dOX1RBQiIsIlRBQl9LRVkiLCJUQUJfTkFWX0ZPUldBUkQiLCJUQUJfTkFWX0JBQ0tXQVJEIiwiRGVmYXVsdCQ3IiwiYXV0b2ZvY3VzIiwidHJhcEVsZW1lbnQiLCJEZWZhdWx0VHlwZSQ3IiwiRm9jdXNUcmFwIiwiX2lzQWN0aXZlIiwiX2xhc3RUYWJOYXZEaXJlY3Rpb24iLCJfaGFuZGxlRm9jdXNpbiIsIl9oYW5kbGVLZXlkb3duIiwic2hpZnRLZXkiLCJOQU1FJDciLCJEQVRBX0tFWSQ0IiwiRVZFTlRfS0VZJDQiLCJEQVRBX0FQSV9LRVkkMiIsIkVTQ0FQRV9LRVkkMSIsIkVWRU5UX0hJREUkNCIsIkVWRU5UX0hJREVfUFJFVkVOVEVEJDEiLCJFVkVOVF9ISURERU4kNCIsIkVWRU5UX1NIT1ckNCIsIkVWRU5UX1NIT1dOJDQiLCJFVkVOVF9SRVNJWkUkMSIsIkVWRU5UX0NMSUNLX0RJU01JU1MiLCJFVkVOVF9NT1VTRURPV05fRElTTUlTUyIsIkVWRU5UX0tFWURPV05fRElTTUlTUyQxIiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMiIsIkNMQVNTX05BTUVfT1BFTiIsIkNMQVNTX05BTUVfRkFERSQzIiwiQ0xBU1NfTkFNRV9TSE9XJDQiLCJDTEFTU19OQU1FX1NUQVRJQyIsIk9QRU5fU0VMRUNUT1IkMSIsIlNFTEVDVE9SX0RJQUxPRyIsIlNFTEVDVE9SX01PREFMX0JPRFkiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyIiwiRGVmYXVsdCQ2IiwiRGVmYXVsdFR5cGUkNiIsIk1vZGFsIiwiX2RpYWxvZyIsIl9iYWNrZHJvcCIsIl9pbml0aWFsaXplQmFja0Ryb3AiLCJfZm9jdXN0cmFwIiwiX2luaXRpYWxpemVGb2N1c1RyYXAiLCJfc2Nyb2xsQmFyIiwiX2FkanVzdERpYWxvZyIsIl9zaG93RWxlbWVudCIsImRlYWN0aXZhdGUiLCJfaGlkZU1vZGFsIiwiaHRtbEVsZW1lbnQiLCJtb2RhbEJvZHkiLCJ0cmFuc2l0aW9uQ29tcGxldGUiLCJhY3RpdmF0ZSIsIl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uIiwiZXZlbnQyIiwiX3Jlc2V0QWRqdXN0bWVudHMiLCJpc01vZGFsT3ZlcmZsb3dpbmciLCJpbml0aWFsT3ZlcmZsb3dZIiwiaXNCb2R5T3ZlcmZsb3dpbmciLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImFscmVhZHlPcGVuIiwiTkFNRSQ2IiwiREFUQV9LRVkkMyIsIkVWRU5UX0tFWSQzIiwiREFUQV9BUElfS0VZJDEiLCJFVkVOVF9MT0FEX0RBVEFfQVBJJDIiLCJFU0NBUEVfS0VZIiwiQ0xBU1NfTkFNRV9TSE9XJDMiLCJDTEFTU19OQU1FX1NIT1dJTkckMSIsIkNMQVNTX05BTUVfSElESU5HIiwiQ0xBU1NfTkFNRV9CQUNLRFJPUCIsIk9QRU5fU0VMRUNUT1IiLCJFVkVOVF9TSE9XJDMiLCJFVkVOVF9TSE9XTiQzIiwiRVZFTlRfSElERSQzIiwiRVZFTlRfSElERV9QUkVWRU5URUQiLCJFVkVOVF9ISURERU4kMyIsIkVWRU5UX1JFU0laRSIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJJDEiLCJFVkVOVF9LRVlET1dOX0RJU01JU1MiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxIiwiRGVmYXVsdCQ1IiwiRGVmYXVsdFR5cGUkNSIsIk9mZmNhbnZhcyIsImJsdXIiLCJjb21wbGV0ZUNhbGxiYWNrIiwidXJpQXR0cmlidXRlcyIsIkFSSUFfQVRUUklCVVRFX1BBVFRFUk4iLCJTQUZFX1VSTF9QQVRURVJOIiwiREFUQV9VUkxfUEFUVEVSTiIsImFsbG93ZWRBdHRyaWJ1dGUiLCJhbGxvd2VkQXR0cmlidXRlTGlzdCIsImF0dHJpYnV0ZU5hbWUiLCJub2RlVmFsdWUiLCJhdHRyaWJ1dGVSZWdleCIsInJlZ2V4IiwiRGVmYXVsdEFsbG93bGlzdCIsImFyZWEiLCJiciIsImNvbCIsImNvZGUiLCJkaXYiLCJlbSIsImhyIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwibGkiLCJvbCIsInAiLCJwcmUiLCJzIiwic21hbGwiLCJzcGFuIiwic3ViIiwic3VwIiwic3Ryb25nIiwidSIsInVsIiwic2FuaXRpemVIdG1sIiwidW5zYWZlSHRtbCIsImFsbG93TGlzdCIsInNhbml0aXplRnVuY3Rpb24iLCJkb21QYXJzZXIiLCJET01QYXJzZXIiLCJjcmVhdGVkRG9jdW1lbnQiLCJwYXJzZUZyb21TdHJpbmciLCJlbGVtZW50TmFtZSIsImF0dHJpYnV0ZUxpc3QiLCJhbGxvd2VkQXR0cmlidXRlcyIsImlubmVySFRNTCIsIk5BTUUkNSIsIkRlZmF1bHQkNCIsImNvbnRlbnQiLCJleHRyYUNsYXNzIiwic2FuaXRpemUiLCJzYW5pdGl6ZUZuIiwidGVtcGxhdGUiLCJEZWZhdWx0VHlwZSQ0IiwiRGVmYXVsdENvbnRlbnRUeXBlIiwiZW50cnkiLCJUZW1wbGF0ZUZhY3RvcnkiLCJfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24iLCJnZXRDb250ZW50IiwiX2NoZWNrQ29udGVudCIsInRlbXBsYXRlV3JhcHBlciIsIl9tYXliZVNhbml0aXplIiwidGV4dCIsIl9zZXRDb250ZW50IiwiYXJnIiwidGVtcGxhdGVFbGVtZW50IiwiX3B1dEVsZW1lbnRJblRlbXBsYXRlIiwidGV4dENvbnRlbnQiLCJOQU1FJDQiLCJESVNBTExPV0VEX0FUVFJJQlVURVMiLCJDTEFTU19OQU1FX0ZBREUkMiIsIkNMQVNTX05BTUVfTU9EQUwiLCJDTEFTU19OQU1FX1NIT1ckMiIsIlNFTEVDVE9SX1RPT0xUSVBfSU5ORVIiLCJTRUxFQ1RPUl9NT0RBTCIsIkVWRU5UX01PREFMX0hJREUiLCJUUklHR0VSX0hPVkVSIiwiVFJJR0dFUl9GT0NVUyIsIlRSSUdHRVJfQ0xJQ0siLCJUUklHR0VSX01BTlVBTCIsIkVWRU5UX0hJREUkMiIsIkVWRU5UX0hJRERFTiQyIiwiRVZFTlRfU0hPVyQyIiwiRVZFTlRfU0hPV04kMiIsIkVWRU5UX0lOU0VSVEVEIiwiRVZFTlRfQ0xJQ0skMSIsIkVWRU5UX0ZPQ1VTSU4kMSIsIkVWRU5UX0ZPQ1VTT1VUJDEiLCJFVkVOVF9NT1VTRUVOVEVSIiwiRVZFTlRfTU9VU0VMRUFWRSIsIkF0dGFjaG1lbnRNYXAiLCJBVVRPIiwiVE9QIiwiUklHSFQiLCJCT1RUT00iLCJMRUZUIiwiRGVmYXVsdCQzIiwiYW5pbWF0aW9uIiwiY29udGFpbmVyIiwiY3VzdG9tQ2xhc3MiLCJkZWxheSIsInRpdGxlIiwiRGVmYXVsdFR5cGUkMyIsIlRvb2x0aXAiLCJfaXNFbmFibGVkIiwiX3RpbWVvdXQiLCJfaXNIb3ZlcmVkIiwiX2FjdGl2ZVRyaWdnZXIiLCJfdGVtcGxhdGVGYWN0b3J5IiwiX25ld0NvbnRlbnQiLCJ0aXAiLCJfc2V0TGlzdGVuZXJzIiwiX2ZpeFRpdGxlIiwiY2xpY2siLCJfbGVhdmUiLCJfZW50ZXIiLCJfaGlkZU1vZGFsSGFuZGxlciIsIl9kaXNwb3NlUG9wcGVyIiwiX2lzV2l0aENvbnRlbnQiLCJzaGFkb3dSb290IiwiaXNJblRoZURvbSIsIl9nZXRUaXBFbGVtZW50IiwiX2lzV2l0aEFjdGl2ZVRyaWdnZXIiLCJfZ2V0VGl0bGUiLCJfY3JlYXRlVGlwRWxlbWVudCIsIl9nZXRDb250ZW50Rm9yVGVtcGxhdGUiLCJfZ2V0VGVtcGxhdGVGYWN0b3J5IiwidG9IdG1sIiwidGlwSWQiLCJjaGFuZ2VDb250ZW50IiwiX2dldERlbGVnYXRlQ29uZmlnIiwiYXR0YWNobWVudCIsInRyaWdnZXJzIiwiX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCIsImV2ZW50SW4iLCJldmVudE91dCIsIl9zZXRUaW1lb3V0IiwidGltZW91dCIsImRhdGFBdHRyaWJ1dGVzIiwiZGF0YUF0dHJpYnV0ZSIsIk5BTUUkMyIsIlNFTEVDVE9SX1RJVExFIiwiU0VMRUNUT1JfQ09OVEVOVCIsIkRlZmF1bHQkMiIsIkRlZmF1bHRUeXBlJDIiLCJQb3BvdmVyIiwiX2dldENvbnRlbnQiLCJOQU1FJDIiLCJEQVRBX0tFWSQyIiwiRVZFTlRfS0VZJDIiLCJEQVRBX0FQSV9LRVkiLCJFVkVOVF9BQ1RJVkFURSIsIkVWRU5UX0NMSUNLIiwiRVZFTlRfTE9BRF9EQVRBX0FQSSQxIiwiQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNIiwiQ0xBU1NfTkFNRV9BQ1RJVkUkMSIsIlNFTEVDVE9SX0RBVEFfU1BZIiwiU0VMRUNUT1JfVEFSR0VUX0xJTktTIiwiU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAiLCJTRUxFQ1RPUl9OQVZfTElOS1MiLCJTRUxFQ1RPUl9OQVZfSVRFTVMiLCJTRUxFQ1RPUl9MSVNUX0lURU1TIiwiU0VMRUNUT1JfTElOS19JVEVNUyIsIlNFTEVDVE9SX0RST1BET1dOIiwiU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEiLCJEZWZhdWx0JDEiLCJyb290TWFyZ2luIiwic21vb3RoU2Nyb2xsIiwidGhyZXNob2xkIiwiRGVmYXVsdFR5cGUkMSIsIlNjcm9sbFNweSIsIl90YXJnZXRMaW5rcyIsIl9vYnNlcnZhYmxlU2VjdGlvbnMiLCJfcm9vdEVsZW1lbnQiLCJfYWN0aXZlVGFyZ2V0IiwiX29ic2VydmVyIiwiX3ByZXZpb3VzU2Nyb2xsRGF0YSIsInZpc2libGVFbnRyeVRvcCIsInBhcmVudFNjcm9sbFRvcCIsInJlZnJlc2giLCJfaW5pdGlhbGl6ZVRhcmdldHNBbmRPYnNlcnZhYmxlcyIsIl9tYXliZUVuYWJsZVNtb290aFNjcm9sbCIsImRpc2Nvbm5lY3QiLCJfZ2V0TmV3T2JzZXJ2ZXIiLCJzZWN0aW9uIiwib2JzZXJ2ZSIsIm9ic2VydmFibGVTZWN0aW9uIiwic2Nyb2xsVG8iLCJiZWhhdmlvciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiX29ic2VydmVyQ2FsbGJhY2siLCJ0YXJnZXRFbGVtZW50IiwiaWQiLCJfcHJvY2VzcyIsInVzZXJTY3JvbGxzRG93biIsImlzSW50ZXJzZWN0aW5nIiwiX2NsZWFyQWN0aXZlQ2xhc3MiLCJlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMiLCJ0YXJnZXRMaW5rcyIsImFuY2hvciIsIl9hY3RpdmF0ZVBhcmVudHMiLCJsaXN0R3JvdXAiLCJhY3RpdmVOb2RlcyIsInNweSIsIk5BTUUkMSIsIkRBVEFfS0VZJDEiLCJFVkVOVF9LRVkkMSIsIkVWRU5UX0hJREUkMSIsIkVWRU5UX0hJRERFTiQxIiwiRVZFTlRfU0hPVyQxIiwiRVZFTlRfU0hPV04kMSIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJIiwiRVZFTlRfS0VZRE9XTiIsIkVWRU5UX0xPQURfREFUQV9BUEkiLCJBUlJPV19MRUZUX0tFWSIsIkFSUk9XX1JJR0hUX0tFWSIsIkFSUk9XX1VQX0tFWSIsIkFSUk9XX0RPV05fS0VZIiwiQ0xBU1NfTkFNRV9BQ1RJVkUiLCJDTEFTU19OQU1FX0ZBREUkMSIsIkNMQVNTX05BTUVfU0hPVyQxIiwiQ0xBU1NfRFJPUERPV04iLCJTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUiLCJTRUxFQ1RPUl9EUk9QRE9XTl9NRU5VIiwiTk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRSIsIlNFTEVDVE9SX1RBQl9QQU5FTCIsIlNFTEVDVE9SX09VVEVSIiwiU0VMRUNUT1JfSU5ORVIiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSIsIlNFTEVDVE9SX0lOTkVSX0VMRU0iLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUiLCJUYWIiLCJfc2V0SW5pdGlhbEF0dHJpYnV0ZXMiLCJfZ2V0Q2hpbGRyZW4iLCJpbm5lckVsZW0iLCJfZWxlbUlzQWN0aXZlIiwiYWN0aXZlIiwiX2dldEFjdGl2ZUVsZW0iLCJfZGVhY3RpdmF0ZSIsIl9hY3RpdmF0ZSIsInJlbGF0ZWRFbGVtIiwiX3RvZ2dsZURyb3BEb3duIiwibmV4dEFjdGl2ZUVsZW1lbnQiLCJwcmV2ZW50U2Nyb2xsIiwiX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzIiwiX3NldEluaXRpYWxBdHRyaWJ1dGVzT25DaGlsZCIsIl9nZXRJbm5lckVsZW1lbnQiLCJpc0FjdGl2ZSIsIm91dGVyRWxlbSIsIl9nZXRPdXRlckVsZW1lbnQiLCJfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPblRhcmdldFBhbmVsIiwib3BlbiIsIkVWRU5UX01PVVNFT1ZFUiIsIkVWRU5UX01PVVNFT1VUIiwiRVZFTlRfRk9DVVNJTiIsIkVWRU5UX0ZPQ1VTT1VUIiwiRVZFTlRfSElERSIsIkVWRU5UX0hJRERFTiIsIkVWRU5UX1NIT1ciLCJFVkVOVF9TSE9XTiIsIkNMQVNTX05BTUVfRkFERSIsIkNMQVNTX05BTUVfSElERSIsIkNMQVNTX05BTUVfU0hPVyIsIkNMQVNTX05BTUVfU0hPV0lORyIsImF1dG9oaWRlIiwiVG9hc3QiLCJfaGFzTW91c2VJbnRlcmFjdGlvbiIsIl9oYXNLZXlib2FyZEludGVyYWN0aW9uIiwiX2NsZWFyVGltZW91dCIsIl9tYXliZVNjaGVkdWxlSGlkZSIsImlzU2hvd24iLCJpc0ludGVyYWN0aW5nIiwiX29uSW50ZXJhY3Rpb24iLCJpbmRleF91bWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/bootstrap.bundle.js\n");

/***/ }),

/***/ "./resources/js/user/app.js":
/*!**********************************!*\
  !*** ./resources/js/user/app.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bootstrap_bundle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bootstrap.bundle */ "./resources/js/bootstrap.bundle.js");
/* harmony import */ var _bootstrap_bundle__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_bootstrap_bundle__WEBPACK_IMPORTED_MODULE_0__);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/js/user/app.js");
/******/ 	
/******/ })()
;